"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudFormationDeployments = exports.replaceEnvPlaceholders = void 0;
const cxapi = require("@aws-cdk/cx-api");
const cdk_assets_1 = require("cdk-assets");
const logging_1 = require("../logging");
const asset_publishing_1 = require("../util/asset-publishing");
const aws_auth_1 = require("./aws-auth");
const deploy_stack_1 = require("./deploy-stack");
const toolkit_info_1 = require("./toolkit-info");
const cloudformation_1 = require("./util/cloudformation");
/**
 * Replace the {ACCOUNT} and {REGION} placeholders in all strings found in a complex object.
 */
async function replaceEnvPlaceholders(object, env, sdkProvider) {
    return cxapi.EnvironmentPlaceholders.replaceAsync(object, {
        accountId: () => Promise.resolve(env.account),
        region: () => Promise.resolve(env.region),
        partition: async () => {
            var _a;
            // There's no good way to get the partition!
            // We should have had it already, except we don't.
            //
            // Best we can do is ask the "base credentials" for this environment for their partition. Cross-partition
            // AssumeRole'ing will never work anyway, so this answer won't be wrong (it will just be slow!)
            return (_a = (await sdkProvider.baseCredentialsPartition(env, aws_auth_1.Mode.ForReading))) !== null && _a !== void 0 ? _a : 'aws';
        },
    });
}
exports.replaceEnvPlaceholders = replaceEnvPlaceholders;
/**
 * Helper class for CloudFormation deployments
 *
 * Looks us the right SDK and Bootstrap stack to deploy a given
 * stack artifact.
 */
class CloudFormationDeployments {
    constructor(props) {
        this.sdkProvider = props.sdkProvider;
    }
    async readCurrentTemplate(stackArtifact) {
        logging_1.debug(`Reading existing template for stack ${stackArtifact.displayName}.`);
        let stackSdk = undefined;
        // try to assume the lookup role and fallback to the deploy role
        try {
            const result = await this.prepareSdkWithLookupRoleFor(stackArtifact);
            if (result.didAssumeRole) {
                stackSdk = result.sdk;
            }
        }
        catch (_a) { }
        if (!stackSdk) {
            stackSdk = (await this.prepareSdkFor(stackArtifact, undefined, aws_auth_1.Mode.ForReading)).stackSdk;
        }
        const cfn = stackSdk.cloudFormation();
        const stack = await cloudformation_1.CloudFormationStack.lookup(cfn, stackArtifact.stackName);
        return stack.template();
    }
    async deployStack(options) {
        const { stackSdk, resolvedEnvironment, cloudFormationRoleArn } = await this.prepareSdkFor(options.stack, options.roleArn);
        const toolkitInfo = await toolkit_info_1.ToolkitInfo.lookup(resolvedEnvironment, stackSdk, options.toolkitStackName);
        // Publish any assets before doing the actual deploy
        await this.publishStackAssets(options.stack, toolkitInfo);
        // Do a verification of the bootstrap stack version
        await this.validateBootstrapStackVersion(options.stack.stackName, options.stack.requiresBootstrapStackVersion, options.stack.bootstrapStackVersionSsmParameter, toolkitInfo);
        return deploy_stack_1.deployStack({
            stack: options.stack,
            resolvedEnvironment,
            deployName: options.deployName,
            notificationArns: options.notificationArns,
            quiet: options.quiet,
            sdk: stackSdk,
            sdkProvider: this.sdkProvider,
            roleArn: cloudFormationRoleArn,
            reuseAssets: options.reuseAssets,
            toolkitInfo,
            tags: options.tags,
            execute: options.execute,
            changeSetName: options.changeSetName,
            force: options.force,
            parameters: options.parameters,
            usePreviousParameters: options.usePreviousParameters,
            progress: options.progress,
            ci: options.ci,
            rollback: options.rollback,
            hotswap: options.hotswap,
            extraUserAgent: options.extraUserAgent,
        });
    }
    async destroyStack(options) {
        const { stackSdk, cloudFormationRoleArn: roleArn } = await this.prepareSdkFor(options.stack, options.roleArn);
        return deploy_stack_1.destroyStack({
            sdk: stackSdk,
            roleArn,
            stack: options.stack,
            deployName: options.deployName,
            quiet: options.quiet,
        });
    }
    async stackExists(options) {
        var _a;
        const { stackSdk } = await this.prepareSdkFor(options.stack, undefined, aws_auth_1.Mode.ForReading);
        const stack = await cloudformation_1.CloudFormationStack.lookup(stackSdk.cloudFormation(), (_a = options.deployName) !== null && _a !== void 0 ? _a : options.stack.stackName);
        return stack.exists;
    }
    /**
     * Try to use the bootstrap lookupRole. There are two scenarios that are handled here
     *  1. The lookup role may not exist (it was added in bootstrap stack version 7)
     *  2. The lookup role may not have the correct permissions (ReadOnlyAccess was added in
     *      bootstrap stack version 8)
     *
     * In the case of 1 (lookup role doesn't exist) `forEnvironment` will either:
     *   1. Return the default credentials if the default credentials are for the stack account
     *   2. Throw an error if the default credentials are not for the stack account.
     *
     * If we successfully assume the lookup role we then proceed to 2 and check whether the bootstrap
     * stack version is valid. If it is not we throw an error which should be handled in the calling
     * function (and fallback to use a different role, etc)
     *
     * If we do not successfully assume the lookup role, but do get back the default credentials
     * then return those and note that we are returning the default credentials. The calling
     * function can then decide to use them or fallback to another role.
     */
    async prepareSdkWithLookupRoleFor(stack) {
        var _a, _b, _c, _d;
        const resolvedEnvironment = await this.sdkProvider.resolveEnvironment(stack.environment);
        // Substitute any placeholders with information about the current environment
        const arns = await replaceEnvPlaceholders({
            lookupRoleArn: (_a = stack.lookupRole) === null || _a === void 0 ? void 0 : _a.arn,
        }, resolvedEnvironment, this.sdkProvider);
        // try to assume the lookup role
        const warningMessage = `Could not assume ${arns.lookupRoleArn}, proceeding anyway.`;
        const upgradeMessage = `(To get rid of this warning, please upgrade to bootstrap version >= ${(_b = stack.lookupRole) === null || _b === void 0 ? void 0 : _b.requiresBootstrapStackVersion})`;
        try {
            const stackSdk = await this.sdkProvider.forEnvironment(resolvedEnvironment, aws_auth_1.Mode.ForReading, {
                assumeRoleArn: arns.lookupRoleArn,
                assumeRoleExternalId: (_c = stack.lookupRole) === null || _c === void 0 ? void 0 : _c.assumeRoleExternalId,
            });
            // if we succeed in assuming the lookup role, make sure we have the correct bootstrap stack version
            if (stackSdk.didAssumeRole && ((_d = stack.lookupRole) === null || _d === void 0 ? void 0 : _d.bootstrapStackVersionSsmParameter) && stack.lookupRole.requiresBootstrapStackVersion) {
                const version = await toolkit_info_1.ToolkitInfo.versionFromSsmParameter(stackSdk.sdk, stack.lookupRole.bootstrapStackVersionSsmParameter);
                if (version < stack.lookupRole.requiresBootstrapStackVersion) {
                    throw new Error(`Bootstrap stack version '${stack.lookupRole.requiresBootstrapStackVersion}' is required, found version '${version}'.`);
                }
            }
            else if (!stackSdk.didAssumeRole) {
                logging_1.warning(upgradeMessage);
            }
            return { ...stackSdk, resolvedEnvironment };
        }
        catch (e) {
            logging_1.debug(e);
            logging_1.warning(warningMessage);
            logging_1.warning(upgradeMessage);
            throw (e);
        }
    }
    /**
     * Get the environment necessary for touching the given stack
     *
     * Returns the following:
     *
     * - The resolved environment for the stack (no more 'unknown-account/unknown-region')
     * - SDK loaded with the right credentials for calling `CreateChangeSet`.
     * - The Execution Role that should be passed to CloudFormation.
     */
    async prepareSdkFor(stack, roleArn, mode = aws_auth_1.Mode.ForWriting) {
        if (!stack.environment) {
            throw new Error(`The stack ${stack.displayName} does not have an environment`);
        }
        const resolvedEnvironment = await this.sdkProvider.resolveEnvironment(stack.environment);
        // Substitute any placeholders with information about the current environment
        const arns = await replaceEnvPlaceholders({
            assumeRoleArn: stack.assumeRoleArn,
            // Use the override if given, otherwise use the field from the stack
            cloudFormationRoleArn: roleArn !== null && roleArn !== void 0 ? roleArn : stack.cloudFormationExecutionRoleArn,
        }, resolvedEnvironment, this.sdkProvider);
        const stackSdk = await this.sdkProvider.forEnvironment(resolvedEnvironment, mode, {
            assumeRoleArn: arns.assumeRoleArn,
            assumeRoleExternalId: stack.assumeRoleExternalId,
        });
        return {
            stackSdk: stackSdk.sdk,
            resolvedEnvironment,
            cloudFormationRoleArn: arns.cloudFormationRoleArn,
        };
    }
    /**
     * Publish all asset manifests that are referenced by the given stack
     */
    async publishStackAssets(stack, toolkitInfo) {
        const stackEnv = await this.sdkProvider.resolveEnvironment(stack.environment);
        const assetArtifacts = stack.dependencies.filter(isAssetManifestArtifact);
        for (const assetArtifact of assetArtifacts) {
            await this.validateBootstrapStackVersion(stack.stackName, assetArtifact.requiresBootstrapStackVersion, assetArtifact.bootstrapStackVersionSsmParameter, toolkitInfo);
            const manifest = cdk_assets_1.AssetManifest.fromFile(assetArtifact.file);
            await asset_publishing_1.publishAssets(manifest, this.sdkProvider, stackEnv);
        }
    }
    /**
     * Validate that the bootstrap stack has the right version for this stack
     */
    async validateBootstrapStackVersion(stackName, requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter, toolkitInfo) {
        if (requiresBootstrapStackVersion === undefined) {
            return;
        }
        try {
            await toolkitInfo.validateVersion(requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter);
        }
        catch (e) {
            throw new Error(`${stackName}: ${e.message}`);
        }
    }
}
exports.CloudFormationDeployments = CloudFormationDeployments;
function isAssetManifestArtifact(art) {
    return art instanceof cxapi.AssetManifestArtifact;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24tZGVwbG95bWVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi1kZXBsb3ltZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5Q0FBeUM7QUFDekMsMkNBQTJDO0FBRTNDLHdDQUE0QztBQUM1QywrREFBeUQ7QUFDekQseUNBQXFEO0FBQ3JELGlEQUE4RTtBQUM5RSxpREFBNkM7QUFDN0MsMERBQXNFO0FBR3RFOztHQUVHO0FBQ0ksS0FBSyxVQUFVLHNCQUFzQixDQUFnQixNQUFTLEVBQUUsR0FBc0IsRUFBRSxXQUF3QjtJQUNySCxPQUFPLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFO1FBQ3hELFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUM7UUFDN0MsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztRQUN6QyxTQUFTLEVBQUUsS0FBSyxJQUFJLEVBQUU7O1lBQ3BCLDRDQUE0QztZQUM1QyxrREFBa0Q7WUFDbEQsRUFBRTtZQUNGLHlHQUF5RztZQUN6RywrRkFBK0Y7WUFDL0YsYUFBTyxDQUFDLE1BQU0sV0FBVyxDQUFDLHdCQUF3QixDQUFDLEdBQUcsRUFBRSxlQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsbUNBQUksS0FBSyxDQUFDO1FBQ3JGLENBQUM7S0FDRixDQUFDLENBQUM7QUFDTCxDQUFDO0FBYkQsd0RBYUM7QUFrTUQ7Ozs7O0dBS0c7QUFDSCxNQUFhLHlCQUF5QjtJQUdwQyxZQUFZLEtBQXVCO1FBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztJQUN2QyxDQUFDO0lBRU0sS0FBSyxDQUFDLG1CQUFtQixDQUFDLGFBQWdEO1FBQy9FLGVBQUssQ0FBQyx1Q0FBdUMs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QyxDQUFDO1FBQzlFLE1BQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFFMUUsS0FBSyxNQUFNLGFBQWEsSUFBSSxjQUFjLEVBQUU7WUFDMUMsTUFBTSxJQUFJLENBQUMsNkJBQTZCLENBQ3RDLEtBQUssQ0FBQyxTQUFTLEVBQ2YsYUFBYSxDQUFDLDZCQUE2QixFQUMzQyxhQUFhLENBQUMsaUNBQWlDLEVBQy9DLFdBQVcsQ0FBQyxDQUFDO1lBRWYsTUFBTSxRQUFRLEdBQUcsMEJBQWEsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVELE1BQU0sZ0NBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUMzRDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNLLEtBQUssQ0FBQyw2QkFBNkIsQ0FDekMsU0FBaUIsRUFDakIsNkJBQWlELEVBQ2pELGlDQUFxRCxFQUNyRCxXQUF3QjtRQUV4QixJQUFJLDZCQUE2QixLQUFLLFNBQVMsRUFBRTtZQUFFLE9BQU87U0FBRTtRQUU1RCxJQUFJO1lBQ0YsTUFBTSxXQUFXLENBQUMsZUFBZSxDQUFDLDZCQUE2QixFQUFFLGlDQUFpQyxDQUFDLENBQUM7U0FDckc7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxTQUFTLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDL0M7SUFDSCxDQUFDO0NBQ0Y7QUF2TkQsOERBdU5DO0FBRUQsU0FBUyx1QkFBdUIsQ0FBQyxHQUF3QjtJQUN2RCxPQUFPLEdBQUcsWUFBWSxLQUFLLENBQUMscUJBQXFCLENBQUM7QUFDcEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0IH0gZnJvbSAnY2RrLWFzc2V0cyc7XG5pbXBvcnQgeyBUYWcgfSBmcm9tICcuLi9jZGstdG9vbGtpdCc7XG5pbXBvcnQgeyBkZWJ1Zywgd2FybmluZyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgcHVibGlzaEFzc2V0cyB9IGZyb20gJy4uL3V0aWwvYXNzZXQtcHVibGlzaGluZyc7XG5pbXBvcnQgeyBNb2RlLCBTZGtQcm92aWRlciwgSVNESyB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgZGVwbG95U3RhY2ssIERlcGxveVN0YWNrUmVzdWx0LCBkZXN0cm95U3RhY2sgfSBmcm9tICcuL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBUb29sa2l0SW5mbyB9IGZyb20gJy4vdG9vbGtpdC1pbmZvJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2ssIFRlbXBsYXRlIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IFN0YWNrQWN0aXZpdHlQcm9ncmVzcyB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbi9zdGFjay1hY3Rpdml0eS1tb25pdG9yJztcblxuLyoqXG4gKiBSZXBsYWNlIHRoZSB7QUNDT1VOVH0gYW5kIHtSRUdJT059IHBsYWNlaG9sZGVycyBpbiBhbGwgc3RyaW5ncyBmb3VuZCBpbiBhIGNvbXBsZXggb2JqZWN0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVwbGFjZUVudlBsYWNlaG9sZGVyczxBIGV4dGVuZHMgeyB9PihvYmplY3Q6IEEsIGVudjogY3hhcGkuRW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcik6IFByb21pc2U8QT4ge1xuICByZXR1cm4gY3hhcGkuRW52aXJvbm1lbnRQbGFjZWhvbGRlcnMucmVwbGFjZUFzeW5jKG9iamVjdCwge1xuICAgIGFjY291bnRJZDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKGVudi5hY2NvdW50KSxcbiAgICByZWdpb246ICgpID0+IFByb21pc2UucmVzb2x2ZShlbnYucmVnaW9uKSxcbiAgICBwYXJ0aXRpb246IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gZ29vZCB3YXkgdG8gZ2V0IHRoZSBwYXJ0aXRpb24hXG4gICAgICAvLyBXZSBzaG91bGQgaGF2ZSBoYWQgaXQgYWxyZWFkeSwgZXhjZXB0IHdlIGRvbid0LlxuICAgICAgLy9cbiAgICAgIC8vIEJlc3Qgd2UgY2FuIGRvIGlzIGFzayB0aGUgXCJiYXNlIGNyZWRlbnRpYWxzXCIgZm9yIHRoaXMgZW52aXJvbm1lbnQgZm9yIHRoZWlyIHBhcnRpdGlvbi4gQ3Jvc3MtcGFydGl0aW9uXG4gICAgICAvLyBBc3N1bWVSb2xlJ2luZyB3aWxsIG5ldmVyIHdvcmsgYW55d2F5LCBzbyB0aGlzIGFuc3dlciB3b24ndCBiZSB3cm9uZyAoaXQgd2lsbCBqdXN0IGJlIHNsb3chKVxuICAgICAgcmV0dXJuIChhd2FpdCBzZGtQcm92aWRlci5iYXNlQ3JlZGVudGlhbHNQYXJ0aXRpb24oZW52LCBNb2RlLkZvclJlYWRpbmcpKSA/PyAnYXdzJztcbiAgICB9LFxuICB9KTtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveVN0YWNrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTdGFjayB0byBkZXBsb3lcbiAgICovXG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGlvbiByb2xlIGZvciB0aGUgZGVwbG95bWVudCAocGFzcyB0aHJvdWdoIHRvIENsb3VkRm9ybWF0aW9uKVxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEN1cnJlbnQgcm9sZVxuICAgKi9cbiAgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogVG9waWMgQVJOcyB0byBzZW5kIGEgbWVzc2FnZSB3aGVuIGRlcGxveW1lbnQgZmluaXNoZXMgKHBhc3MgdGhyb3VnaCB0byBDbG91ZEZvcm1hdGlvbilcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBub3RpZmljYXRpb25zXG4gICAqL1xuICBub3RpZmljYXRpb25Bcm5zPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG5hbWUgdW5kZXIgd2hpY2ggc3RhY2sgd2lsbCBiZSBkZXBsb3llZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFVzZSBhcnRpZmFjdCBkZWZhdWx0XG4gICAqL1xuICBkZXBsb3lOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEb24ndCBzaG93IHN0YWNrIGRlcGxveW1lbnQgZXZlbnRzLCBqdXN0IHdhaXRcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHF1aWV0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgdG9vbGtpdCBzdGFjaywgaWYgbm90IHRoZSBkZWZhdWx0IG5hbWVcbiAgICpcbiAgICogQGRlZmF1bHQgJ0NES1Rvb2xraXQnXG4gICAqL1xuICB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IElEcyB3aGljaCBzaG91bGQgTk9UIGJlIGJ1aWx0IG9yIHVwbG9hZGVkXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQnVpbGQgYWxsIGFzc2V0c1xuICAgKi9cbiAgcmV1c2VBc3NldHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogU3RhY2sgdGFncyAocGFzcyB0aHJvdWdoIHRvIENsb3VkRm9ybWF0aW9uKVxuICAgKi9cbiAgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBTdGFnZSB0aGUgY2hhbmdlIHNldCBidXQgZG9uJ3QgZXhlY3V0ZSBpdFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGZhbHNlXG4gICAqL1xuICBleGVjdXRlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgbmFtZSB0byB1c2UgZm9yIHRoZSBDbG91ZEZvcm1hdGlvbiBjaGFuZ2Ugc2V0LlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGEgbmFtZSB3aWxsIGJlIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgKi9cbiAgY2hhbmdlU2V0TmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogRm9yY2UgZGVwbG95bWVudCwgZXZlbiBpZiB0aGUgZGVwbG95ZWQgdGVtcGxhdGUgaXMgaWRlbnRpY2FsIHRvIHRoZSBvbmUgd2UgYXJlIGFib3V0IHRvIGRlcGxveS5cbiAgICogQGRlZmF1bHQgZmFsc2UgZGVwbG95bWVudCB3aWxsIGJlIHNraXBwZWQgaWYgdGhlIHRlbXBsYXRlIGlzIGlkZW50aWNhbFxuICAgKi9cbiAgZm9yY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFeHRyYSBwYXJhbWV0ZXJzIGZvciBDbG91ZEZvcm1hdGlvblxuICAgKiBAZGVmYXVsdCAtIG5vIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGVtcGxhdGVcbiAgICovXG4gIHBhcmFtZXRlcnM/OiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcblxuICAvKipcbiAgICogVXNlIHByZXZpb3VzIHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBJZiBub3Qgc2V0LCBhbGwgcGFyYW1ldGVycyBtdXN0IGJlIHNwZWNpZmllZCBmb3IgZXZlcnkgZGVwbG95bWVudC5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGlzcGxheSBtb2RlIGZvciBzdGFjayBkZXBsb3ltZW50IHByb2dyZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CYXIgLSBzdGFjayBldmVudHMgd2lsbCBiZSBkaXNwbGF5ZWQgZm9yXG4gICAqICAgdGhlIHJlc291cmNlIGN1cnJlbnRseSBiZWluZyBkZXBsb3llZC5cbiAgICovXG4gIHByb2dyZXNzPzogU3RhY2tBY3Rpdml0eVByb2dyZXNzO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBvbiBhIENJIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgY2k/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBmYWlsZWQgZGVwbG95bWVudHNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sbGJhY2s/OiBib29sZWFuO1xuXG4gIC8qXG4gICAqIFdoZXRoZXIgdG8gcGVyZm9ybSBhICdob3Rzd2FwJyBkZXBsb3ltZW50LlxuICAgKiBBICdob3Rzd2FwJyBkZXBsb3ltZW50IHdpbGwgYXR0ZW1wdCB0byBzaG9ydC1jaXJjdWl0IENsb3VkRm9ybWF0aW9uXG4gICAqIGFuZCB1cGRhdGUgdGhlIGFmZmVjdGVkIHJlc291cmNlcyBsaWtlIExhbWJkYSBmdW5jdGlvbnMgZGlyZWN0bHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZmFsc2UgZm9yIHJlZ3VsYXIgZGVwbG95bWVudHMsIHRydWUgZm9yICd3YXRjaCcgZGVwbG95bWVudHNcbiAgICovXG4gIHJlYWRvbmx5IGhvdHN3YXA/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgZXh0cmEgc3RyaW5nIHRvIGFwcGVuZCB0byB0aGUgVXNlci1BZ2VudCBoZWFkZXIgd2hlbiBwZXJmb3JtaW5nIEFXUyBTREsgY2FsbHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm90aGluZyBleHRyYSBpcyBhcHBlbmRlZCB0byB0aGUgVXNlci1BZ2VudCBoZWFkZXJcbiAgICovXG4gIHJlYWRvbmx5IGV4dHJhVXNlckFnZW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlc3Ryb3lTdGFja09wdGlvbnMge1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuICBkZXBsb3lOYW1lPzogc3RyaW5nO1xuICByb2xlQXJuPzogc3RyaW5nO1xuICBxdWlldD86IGJvb2xlYW47XG4gIGZvcmNlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFja0V4aXN0c09wdGlvbnMge1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuICBkZXBsb3lOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3Zpc2lvbmVyUHJvcHMge1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG59XG5cbi8qKlxuICogU0RLIG9idGFpbmVkIGJ5IGFzc3VtaW5nIHRoZSBsb29rdXAgcm9sZVxuICogZm9yIGEgZ2l2ZW4gZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZFNka1dpdGhMb29rdXBSb2xlRm9yRW52aXJvbm1lbnQge1xuICAvKipcbiAgICogVGhlIFNESyBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50XG4gICAqL1xuICByZWFkb25seSBzZGs6IElTREs7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCBlbnZpcm9ubWVudCBmb3IgdGhlIHN0YWNrXG4gICAqIChubyBtb3JlICd1bmtub3duLWFjY291bnQvdW5rbm93bi1yZWdpb24nKVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb2x2ZWRFbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQ7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBhc3N1bWUgcm9sZSB3YXMgc3VjY2Vzc2Z1bC5cbiAgICogSWYgdGhlIGFzc3VtZSByb2xlIHdhcyBub3Qgc3VjY2Vzc2Z1bCAoZmFsc2UpXG4gICAqIHRoZW4gdGhhdCBtZWFucyB0aGF0IHRoZSAnc2RrJyByZXR1cm5lZCBjb250YWluc1xuICAgKiB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyAobm90IHRoZSBhc3N1bWUgcm9sZSBjcmVkZW50aWFscylcbiAgICovXG4gIHJlYWRvbmx5IGRpZEFzc3VtZVJvbGU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogU0RLIG9idGFpbmVkIGJ5IGFzc3VtaW5nIHRoZSBkZXBsb3kgcm9sZVxuICogZm9yIGEgZ2l2ZW4gZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZFNka0ZvckVudmlyb25tZW50IHtcbiAgLyoqXG4gICAqIFRoZSBTREsgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tTZGs6IElTREs7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCBlbnZpcm9ubWVudCBmb3IgdGhlIHN0YWNrXG4gICAqIChubyBtb3JlICd1bmtub3duLWFjY291bnQvdW5rbm93bi1yZWdpb24nKVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb2x2ZWRFbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQ7XG4gIC8qKlxuICAgKiBUaGUgRXhlY3V0aW9uIFJvbGUgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIENsb3VkRm9ybWF0aW9uLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIGV4ZWN1dGlvbiByb2xlIGlzIHVzZWRcbiAgICovXG4gIHJlYWRvbmx5IGNsb3VkRm9ybWF0aW9uUm9sZUFybj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIENsb3VkRm9ybWF0aW9uIGRlcGxveW1lbnRzXG4gKlxuICogTG9va3MgdXMgdGhlIHJpZ2h0IFNESyBhbmQgQm9vdHN0cmFwIHN0YWNrIHRvIGRlcGxveSBhIGdpdmVuXG4gKiBzdGFjayBhcnRpZmFjdC5cbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkRm9ybWF0aW9uRGVwbG95bWVudHMge1xuICBwcml2YXRlIHJlYWRvbmx5IHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvdmlzaW9uZXJQcm9wcykge1xuICAgIHRoaXMuc2RrUHJvdmlkZXIgPSBwcm9wcy5zZGtQcm92aWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZWFkQ3VycmVudFRlbXBsYXRlKHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCk6IFByb21pc2U8VGVtcGxhdGU+IHtcbiAgICBkZWJ1ZyhgUmVhZGluZyBleGlzdGluZyB0ZW1wbGF0ZSBmb3Igc3RhY2sgJHtzdGFja0FydGlmYWN0LmRpc3BsYXlOYW1lfS5gKTtcbiAgICBsZXQgc3RhY2tTZGs6IElTREsgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLy8gdHJ5IHRvIGFzc3VtZSB0aGUgbG9va3VwIHJvbGUgYW5kIGZhbGxiYWNrIHRvIHRoZSBkZXBsb3kgcm9sZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByZXBhcmVTZGtXaXRoTG9va3VwUm9sZUZvcihzdGFja0FydGlmYWN0KTtcbiAgICAgIGlmIChyZXN1bHQuZGlkQXNzdW1lUm9sZSkge1xuICAgICAgICBzdGFja1NkayA9IHJlc3VsdC5zZGs7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7IH1cblxuICAgIGlmICghc3RhY2tTZGspIHtcbiAgICAgIHN0YWNrU2RrID0gKGF3YWl0IHRoaXMucHJlcGFyZVNka0ZvcihzdGFja0FydGlmYWN0LCB1bmRlZmluZWQsIE1vZGUuRm9yUmVhZGluZykpLnN0YWNrU2RrO1xuICAgIH1cblxuICAgIGNvbnN0IGNmbiA9IHN0YWNrU2RrLmNsb3VkRm9ybWF0aW9uKCk7XG5cbiAgICBjb25zdCBzdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgc3RhY2tBcnRpZmFjdC5zdGFja05hbWUpO1xuICAgIHJldHVybiBzdGFjay50ZW1wbGF0ZSgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlcGxveVN0YWNrKG9wdGlvbnM6IERlcGxveVN0YWNrT3B0aW9ucyk6IFByb21pc2U8RGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBjb25zdCB7IHN0YWNrU2RrLCByZXNvbHZlZEVudmlyb25tZW50LCBjbG91ZEZvcm1hdGlvblJvbGVBcm4gfSA9IGF3YWl0IHRoaXMucHJlcGFyZVNka0ZvcihvcHRpb25zLnN0YWNrLCBvcHRpb25zLnJvbGVBcm4pO1xuXG4gICAgY29uc3QgdG9vbGtpdEluZm8gPSBhd2FpdCBUb29sa2l0SW5mby5sb29rdXAocmVzb2x2ZWRFbnZpcm9ubWVudCwgc3RhY2tTZGssIG9wdGlvbnMudG9vbGtpdFN0YWNrTmFtZSk7XG5cbiAgICAvLyBQdWJsaXNoIGFueSBhc3NldHMgYmVmb3JlIGRvaW5nIHRoZSBhY3R1YWwgZGVwbG95XG4gICAgYXdhaXQgdGhpcy5wdWJsaXNoU3RhY2tBc3NldHMob3B0aW9ucy5zdGFjaywgdG9vbGtpdEluZm8pO1xuXG4gICAgLy8gRG8gYSB2ZXJpZmljYXRpb24gb2YgdGhlIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uXG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICAgIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLFxuICAgICAgb3B0aW9ucy5zdGFjay5yZXF1aXJlc0Jvb3RzdHJhcFN0YWNrVmVyc2lvbixcbiAgICAgIG9wdGlvbnMuc3RhY2suYm9vdHN0cmFwU3RhY2tWZXJzaW9uU3NtUGFyYW1ldGVyLFxuICAgICAgdG9vbGtpdEluZm8pO1xuXG4gICAgcmV0dXJuIGRlcGxveVN0YWNrKHtcbiAgICAgIHN0YWNrOiBvcHRpb25zLnN0YWNrLFxuICAgICAgcmVzb2x2ZWRFbnZpcm9ubWVudCxcbiAgICAgIGRlcGxveU5hbWU6IG9wdGlvbnMuZGVwbG95TmFtZSxcbiAgICAgIG5vdGlmaWNhdGlvbkFybnM6IG9wdGlvbnMubm90aWZpY2F0aW9uQXJucyxcbiAgICAgIHF1aWV0OiBvcHRpb25zLnF1aWV0LFxuICAgICAgc2RrOiBzdGFja1NkayxcbiAgICAgIHNka1Byb3ZpZGVyOiB0aGlzLnNka1Byb3ZpZGVyLFxuICAgICAgcm9sZUFybjogY2xvdWRGb3JtYXRpb25Sb2xlQXJuLFxuICAgICAgcmV1c2VBc3NldHM6IG9wdGlvbnMucmV1c2VBc3NldHMsXG4gICAgICB0b29sa2l0SW5mbyxcbiAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyxcbiAgICAgIGV4ZWN1dGU6IG9wdGlvbnMuZXhlY3V0ZSxcbiAgICAgIGNoYW5nZVNldE5hbWU6IG9wdGlvbnMuY2hhbmdlU2V0TmFtZSxcbiAgICAgIGZvcmNlOiBvcHRpb25zLmZvcmNlLFxuICAgICAgcGFyYW1ldGVyczogb3B0aW9ucy5wYXJhbWV0ZXJzLFxuICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBvcHRpb25zLnVzZVByZXZpb3VzUGFyYW1ldGVycyxcbiAgICAgIHByb2dyZXNzOiBvcHRpb25zLnByb2dyZXNzLFxuICAgICAgY2k6IG9wdGlvbnMuY2ksXG4gICAgICByb2xsYmFjazogb3B0aW9ucy5yb2xsYmFjayxcbiAgICAgIGhvdHN3YXA6IG9wdGlvbnMuaG90c3dhcCxcbiAgICAgIGV4dHJhVXNlckFnZW50OiBvcHRpb25zLmV4dHJhVXNlckFnZW50LFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3lTdGFjayhvcHRpb25zOiBEZXN0cm95U3RhY2tPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBzdGFja1NkaywgY2xvdWRGb3JtYXRpb25Sb2xlQXJuOiByb2xlQXJuIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVTZGtGb3Iob3B0aW9ucy5zdGFjaywgb3B0aW9ucy5yb2xlQXJuKTtcblxuICAgIHJldHVybiBkZXN0cm95U3RhY2soe1xuICAgICAgc2RrOiBzdGFja1NkayxcbiAgICAgIHJvbGVBcm4sXG4gICAgICBzdGFjazogb3B0aW9ucy5zdGFjayxcbiAgICAgIGRlcGxveU5hbWU6IG9wdGlvbnMuZGVwbG95TmFtZSxcbiAgICAgIHF1aWV0OiBvcHRpb25zLnF1aWV0LFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHN0YWNrRXhpc3RzKG9wdGlvbnM6IFN0YWNrRXhpc3RzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHsgc3RhY2tTZGsgfSA9IGF3YWl0IHRoaXMucHJlcGFyZVNka0ZvcihvcHRpb25zLnN0YWNrLCB1bmRlZmluZWQsIE1vZGUuRm9yUmVhZGluZyk7XG4gICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChzdGFja1Nkay5jbG91ZEZvcm1hdGlvbigpLCBvcHRpb25zLmRlcGxveU5hbWUgPz8gb3B0aW9ucy5zdGFjay5zdGFja05hbWUpO1xuICAgIHJldHVybiBzdGFjay5leGlzdHM7XG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIHVzZSB0aGUgYm9vdHN0cmFwIGxvb2t1cFJvbGUuIFRoZXJlIGFyZSB0d28gc2NlbmFyaW9zIHRoYXQgYXJlIGhhbmRsZWQgaGVyZVxuICAgKiAgMS4gVGhlIGxvb2t1cCByb2xlIG1heSBub3QgZXhpc3QgKGl0IHdhcyBhZGRlZCBpbiBib290c3RyYXAgc3RhY2sgdmVyc2lvbiA3KVxuICAgKiAgMi4gVGhlIGxvb2t1cCByb2xlIG1heSBub3QgaGF2ZSB0aGUgY29ycmVjdCBwZXJtaXNzaW9ucyAoUmVhZE9ubHlBY2Nlc3Mgd2FzIGFkZGVkIGluXG4gICAqICAgICAgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gOClcbiAgICpcbiAgICogSW4gdGhlIGNhc2Ugb2YgMSAobG9va3VwIHJvbGUgZG9lc24ndCBleGlzdCkgYGZvckVudmlyb25tZW50YCB3aWxsIGVpdGhlcjpcbiAgICogICAxLiBSZXR1cm4gdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgaWYgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgYXJlIGZvciB0aGUgc3RhY2sgYWNjb3VudFxuICAgKiAgIDIuIFRocm93IGFuIGVycm9yIGlmIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGFyZSBub3QgZm9yIHRoZSBzdGFjayBhY2NvdW50LlxuICAgKlxuICAgKiBJZiB3ZSBzdWNjZXNzZnVsbHkgYXNzdW1lIHRoZSBsb29rdXAgcm9sZSB3ZSB0aGVuIHByb2NlZWQgdG8gMiBhbmQgY2hlY2sgd2hldGhlciB0aGUgYm9vdHN0cmFwXG4gICAqIHN0YWNrIHZlcnNpb24gaXMgdmFsaWQuIElmIGl0IGlzIG5vdCB3ZSB0aHJvdyBhbiBlcnJvciB3aGljaCBzaG91bGQgYmUgaGFuZGxlZCBpbiB0aGUgY2FsbGluZ1xuICAgKiBmdW5jdGlvbiAoYW5kIGZhbGxiYWNrIHRvIHVzZSBhIGRpZmZlcmVudCByb2xlLCBldGMpXG4gICAqXG4gICAqIElmIHdlIGRvIG5vdCBzdWNjZXNzZnVsbHkgYXNzdW1lIHRoZSBsb29rdXAgcm9sZSwgYnV0IGRvIGdldCBiYWNrIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzXG4gICAqIHRoZW4gcmV0dXJuIHRob3NlIGFuZCBub3RlIHRoYXQgd2UgYXJlIHJldHVybmluZyB0aGUgZGVmYXVsdCBjcmVkZW50aWFscy4gVGhlIGNhbGxpbmdcbiAgICogZnVuY3Rpb24gY2FuIHRoZW4gZGVjaWRlIHRvIHVzZSB0aGVtIG9yIGZhbGxiYWNrIHRvIGFub3RoZXIgcm9sZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcHJlcGFyZVNka1dpdGhMb29rdXBSb2xlRm9yKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpOiBQcm9taXNlPFByZXBhcmVkU2RrV2l0aExvb2t1cFJvbGVGb3JFbnZpcm9ubWVudD4ge1xuICAgIGNvbnN0IHJlc29sdmVkRW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChzdGFjay5lbnZpcm9ubWVudCk7XG5cbiAgICAvLyBTdWJzdGl0dXRlIGFueSBwbGFjZWhvbGRlcnMgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuICAgIGNvbnN0IGFybnMgPSBhd2FpdCByZXBsYWNlRW52UGxhY2Vob2xkZXJzKHtcbiAgICAgIGxvb2t1cFJvbGVBcm46IHN0YWNrLmxvb2t1cFJvbGU/LmFybixcbiAgICB9LCByZXNvbHZlZEVudmlyb25tZW50LCB0aGlzLnNka1Byb3ZpZGVyKTtcblxuICAgIC8vIHRyeSB0byBhc3N1bWUgdGhlIGxvb2t1cCByb2xlXG4gICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgQ291bGQgbm90IGFzc3VtZSAke2FybnMubG9va3VwUm9sZUFybn0sIHByb2NlZWRpbmcgYW55d2F5LmA7XG4gICAgY29uc3QgdXBncmFkZU1lc3NhZ2UgPSBgKFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBwbGVhc2UgdXBncmFkZSB0byBib290c3RyYXAgdmVyc2lvbiA+PSAke3N0YWNrLmxvb2t1cFJvbGU/LnJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9ufSlgO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFja1NkayA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQocmVzb2x2ZWRFbnZpcm9ubWVudCwgTW9kZS5Gb3JSZWFkaW5nLCB7XG4gICAgICAgIGFzc3VtZVJvbGVBcm46IGFybnMubG9va3VwUm9sZUFybixcbiAgICAgICAgYXNzdW1lUm9sZUV4dGVybmFsSWQ6IHN0YWNrLmxvb2t1cFJvbGU/LmFzc3VtZVJvbGVFeHRlcm5hbElkLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIHdlIHN1Y2NlZWQgaW4gYXNzdW1pbmcgdGhlIGxvb2t1cCByb2xlLCBtYWtlIHN1cmUgd2UgaGF2ZSB0aGUgY29ycmVjdCBib290c3RyYXAgc3RhY2sgdmVyc2lvblxuICAgICAgaWYgKHN0YWNrU2RrLmRpZEFzc3VtZVJvbGUgJiYgc3RhY2subG9va3VwUm9sZT8uYm9vdHN0cmFwU3RhY2tWZXJzaW9uU3NtUGFyYW1ldGVyICYmIHN0YWNrLmxvb2t1cFJvbGUucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IFRvb2xraXRJbmZvLnZlcnNpb25Gcm9tU3NtUGFyYW1ldGVyKHN0YWNrU2RrLnNkaywgc3RhY2subG9va3VwUm9sZS5ib290c3RyYXBTdGFja1ZlcnNpb25Tc21QYXJhbWV0ZXIpO1xuICAgICAgICBpZiAodmVyc2lvbiA8IHN0YWNrLmxvb2t1cFJvbGUucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uICcke3N0YWNrLmxvb2t1cFJvbGUucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb259JyBpcyByZXF1aXJlZCwgZm91bmQgdmVyc2lvbiAnJHt2ZXJzaW9ufScuYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrU2RrLmRpZEFzc3VtZVJvbGUpIHtcbiAgICAgICAgd2FybmluZyh1cGdyYWRlTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5zdGFja1NkaywgcmVzb2x2ZWRFbnZpcm9ubWVudCB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKGUpO1xuICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB3YXJuaW5nKHVwZ3JhZGVNZXNzYWdlKTtcbiAgICAgIHRocm93IChlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbnZpcm9ubWVudCBuZWNlc3NhcnkgZm9yIHRvdWNoaW5nIHRoZSBnaXZlbiBzdGFja1xuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIC0gVGhlIHJlc29sdmVkIGVudmlyb25tZW50IGZvciB0aGUgc3RhY2sgKG5vIG1vcmUgJ3Vua25vd24tYWNjb3VudC91bmtub3duLXJlZ2lvbicpXG4gICAqIC0gU0RLIGxvYWRlZCB3aXRoIHRoZSByaWdodCBjcmVkZW50aWFscyBmb3IgY2FsbGluZyBgQ3JlYXRlQ2hhbmdlU2V0YC5cbiAgICogLSBUaGUgRXhlY3V0aW9uIFJvbGUgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIENsb3VkRm9ybWF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcmVwYXJlU2RrRm9yKFxuICAgIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gICAgcm9sZUFybj86IHN0cmluZyxcbiAgICBtb2RlID0gTW9kZS5Gb3JXcml0aW5nLFxuICApOiBQcm9taXNlPFByZXBhcmVkU2RrRm9yRW52aXJvbm1lbnQ+IHtcbiAgICBpZiAoIXN0YWNrLmVudmlyb25tZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayAke3N0YWNrLmRpc3BsYXlOYW1lfSBkb2VzIG5vdCBoYXZlIGFuIGVudmlyb25tZW50YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRFbnZpcm9ubWVudCA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrLmVudmlyb25tZW50KTtcblxuICAgIC8vIFN1YnN0aXR1dGUgYW55IHBsYWNlaG9sZGVycyB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAgY29uc3QgYXJucyA9IGF3YWl0IHJlcGxhY2VFbnZQbGFjZWhvbGRlcnMoe1xuICAgICAgYXNzdW1lUm9sZUFybjogc3RhY2suYXNzdW1lUm9sZUFybixcblxuICAgICAgLy8gVXNlIHRoZSBvdmVycmlkZSBpZiBnaXZlbiwgb3RoZXJ3aXNlIHVzZSB0aGUgZmllbGQgZnJvbSB0aGUgc3RhY2tcbiAgICAgIGNsb3VkRm9ybWF0aW9uUm9sZUFybjogcm9sZUFybiA/PyBzdGFjay5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblJvbGVBcm4sXG4gICAgfSwgcmVzb2x2ZWRFbnZpcm9ubWVudCwgdGhpcy5zZGtQcm92aWRlcik7XG5cbiAgICBjb25zdCBzdGFja1NkayA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQocmVzb2x2ZWRFbnZpcm9ubWVudCwgbW9kZSwge1xuICAgICAgYXNzdW1lUm9sZUFybjogYXJucy5hc3N1bWVSb2xlQXJuLFxuICAgICAgYXNzdW1lUm9sZUV4dGVybmFsSWQ6IHN0YWNrLmFzc3VtZVJvbGVFeHRlcm5hbElkLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWNrU2RrOiBzdGFja1Nkay5zZGssXG4gICAgICByZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgY2xvdWRGb3JtYXRpb25Sb2xlQXJuOiBhcm5zLmNsb3VkRm9ybWF0aW9uUm9sZUFybixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYWxsIGFzc2V0IG1hbmlmZXN0cyB0aGF0IGFyZSByZWZlcmVuY2VkIGJ5IHRoZSBnaXZlbiBzdGFja1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwdWJsaXNoU3RhY2tBc3NldHMoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCwgdG9vbGtpdEluZm86IFRvb2xraXRJbmZvKSB7XG4gICAgY29uc3Qgc3RhY2tFbnYgPSBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChzdGFjay5lbnZpcm9ubWVudCk7XG4gICAgY29uc3QgYXNzZXRBcnRpZmFjdHMgPSBzdGFjay5kZXBlbmRlbmNpZXMuZmlsdGVyKGlzQXNzZXRNYW5pZmVzdEFydGlmYWN0KTtcblxuICAgIGZvciAoY29uc3QgYXNzZXRBcnRpZmFjdCBvZiBhc3NldEFydGlmYWN0cykge1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICAgICAgc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICBhc3NldEFydGlmYWN0LnJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uLFxuICAgICAgICBhc3NldEFydGlmYWN0LmJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlcixcbiAgICAgICAgdG9vbGtpdEluZm8pO1xuXG4gICAgICBjb25zdCBtYW5pZmVzdCA9IEFzc2V0TWFuaWZlc3QuZnJvbUZpbGUoYXNzZXRBcnRpZmFjdC5maWxlKTtcbiAgICAgIGF3YWl0IHB1Ymxpc2hBc3NldHMobWFuaWZlc3QsIHRoaXMuc2RrUHJvdmlkZXIsIHN0YWNrRW52KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCB0aGUgYm9vdHN0cmFwIHN0YWNrIGhhcyB0aGUgcmlnaHQgdmVyc2lvbiBmb3IgdGhpcyBzdGFja1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICBzdGFja05hbWU6IHN0cmluZyxcbiAgICByZXF1aXJlc0Jvb3RzdHJhcFN0YWNrVmVyc2lvbjogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIGJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlcjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbykge1xuXG4gICAgaWYgKHJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdG9vbGtpdEluZm8udmFsaWRhdGVWZXJzaW9uKHJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uLCBib290c3RyYXBTdGFja1ZlcnNpb25Tc21QYXJhbWV0ZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdGFja05hbWV9OiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBc3NldE1hbmlmZXN0QXJ0aWZhY3QoYXJ0OiBjeGFwaS5DbG91ZEFydGlmYWN0KTogYXJ0IGlzIGN4YXBpLkFzc2V0TWFuaWZlc3RBcnRpZmFjdCB7XG4gIHJldHVybiBhcnQgaW5zdGFuY2VvZiBjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3Q7XG59XG4iXX0=