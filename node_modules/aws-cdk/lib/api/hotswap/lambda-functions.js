"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const util_1 = require("../../util");
const common_1 = require("./common");
/**
 * Returns `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change cannot be short-circuited,
 * `ChangeHotswapImpact.IRRELEVANT` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    var _a;
    // if the change is for a Lambda Version,
    // ignore it by returning an empty hotswap operation -
    // we will publish a new version when we get to hotswapping the actual Function this Version points to, below
    // (Versions can't be changed in CloudFormation anyway, they're immutable)
    if (change.newValue.Type === 'AWS::Lambda::Version') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    // we handle Aliases specially too
    if (change.newValue.Type === 'AWS::Lambda::Alias') {
        return checkAliasHasVersionOnlyChange(change);
    }
    const lambdaCodeChange = await isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    const functionName = await common_1.establishResourcePhysicalName(logicalId, (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.FunctionName, evaluateCfnTemplate);
    if (!functionName) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const functionArn = await evaluateCfnTemplate.evaluateCfnExpression({
        'Fn::Sub': 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:' + functionName,
    });
    // find all Lambda Versions that reference this Function
    const versionsReferencingFunction = evaluateCfnTemplate.findReferencesTo(logicalId)
        .filter(r => r.Type === 'AWS::Lambda::Version');
    // find all Lambda Aliases that reference the above Versions
    const aliasesReferencingVersions = util_1.flatMap(versionsReferencingFunction, v => evaluateCfnTemplate.findReferencesTo(v.LogicalId));
    const aliasesNames = await Promise.all(aliasesReferencingVersions.map(a => { var _a; return evaluateCfnTemplate.evaluateCfnExpression((_a = a.Properties) === null || _a === void 0 ? void 0 : _a.Name); }));
    return new LambdaFunctionHotswapOperation({
        physicalName: functionName,
        functionArn: functionArn,
        resource: lambdaCodeChange,
        publishVersion: versionsReferencingFunction.length > 0,
        aliasesNames,
    });
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns  is a given Alias change is only in the 'FunctionVersion' property,
 * and `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` is the change is for any other property.
 */
function checkAliasHasVersionOnlyChange(change) {
    for (const updatedPropName in change.propertyUpdates) {
        if (updatedPropName !== 'FunctionVersion') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    return common_1.ChangeHotswapImpact.IRRELEVANT;
}
/**
 * Returns `ChangeHotswapImpact.IRRELEVANT` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
async function isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate) {
    const newResourceType = change.newValue.Type;
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * At first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    const propertyUpdates = change.propertyUpdates;
    let code = undefined;
    let tags = undefined;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        switch (updatedPropName) {
            case 'Code':
                let foundCodeDifference = false;
                let s3Bucket = '', s3Key = '';
                for (const newPropName in updatedProp.newValue) {
                    switch (newPropName) {
                        case 'S3Bucket':
                            foundCodeDifference = true;
                            s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3Key':
                            foundCodeDifference = true;
                            s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        default:
                            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
                    }
                }
                if (foundCodeDifference) {
                    code = {
                        s3Bucket,
                        s3Key,
                    };
                }
                break;
            case 'Tags':
                /*
                 * Tag updates are a bit odd; they manifest as two lists, are flagged only as
                 * `isDifferent`, and we have to reconcile them.
                 */
                const tagUpdates = {};
                if (updatedProp === null || updatedProp === void 0 ? void 0 : updatedProp.isDifferent) {
                    updatedProp.newValue.forEach((tag) => {
                        tagUpdates[tag.Key] = tag.Value;
                    });
                    updatedProp.oldValue.forEach((tag) => {
                        if (tagUpdates[tag.Key] === undefined) {
                            tagUpdates[tag.Key] = TagDeletion.DELETE;
                        }
                    });
                    tags = { tagUpdates };
                }
                break;
            default:
                return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    return code || tags ? { code, tags } : common_1.ChangeHotswapImpact.IRRELEVANT;
}
var TagDeletion;
(function (TagDeletion) {
    TagDeletion[TagDeletion["DELETE"] = -1] = "DELETE";
})(TagDeletion || (TagDeletion = {}));
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
        this.service = 'lambda-function';
        this.resourceNames = [
            `Lambda Function '${lambdaFunctionResource.physicalName}'`,
            // add Version here if we're publishing a new one
            ...(lambdaFunctionResource.publishVersion ? [`Lambda Version for Function '${lambdaFunctionResource.physicalName}'`] : []),
            // add any Aliases that we are hotswapping here
            ...lambdaFunctionResource.aliasesNames.map(alias => `Lambda Alias '${alias}' for Function '${lambdaFunctionResource.physicalName}'`),
        ];
    }
    async apply(sdk) {
        const lambda = sdk.lambda();
        const resource = this.lambdaFunctionResource.resource;
        const operations = [];
        if (resource.code !== undefined) {
            const updateFunctionCodePromise = lambda.updateFunctionCode({
                FunctionName: this.lambdaFunctionResource.physicalName,
                S3Bucket: resource.code.s3Bucket,
                S3Key: resource.code.s3Key,
            }).promise();
            // only if the code changed is there any point in publishing a new Version
            if (this.lambdaFunctionResource.publishVersion) {
                // we need to wait for the code update to be done before publishing a new Version
                await updateFunctionCodePromise;
                // if we don't wait for the Function to finish updating,
                // we can get a "The operation cannot be performed at this time. An update is in progress for resource:"
                // error when publishing a new Version
                await lambda.waitFor('functionUpdated', {
                    FunctionName: this.lambdaFunctionResource.physicalName,
                }).promise();
                const publishVersionPromise = lambda.publishVersion({
                    FunctionName: this.lambdaFunctionResource.physicalName,
                }).promise();
                if (this.lambdaFunctionResource.aliasesNames.length > 0) {
                    // we need to wait for the Version to finish publishing
                    const versionUpdate = await publishVersionPromise;
                    for (const alias of this.lambdaFunctionResource.aliasesNames) {
                        operations.push(lambda.updateAlias({
                            FunctionName: this.lambdaFunctionResource.physicalName,
                            Name: alias,
                            FunctionVersion: versionUpdate.Version,
                        }).promise());
                    }
                }
                else {
                    operations.push(publishVersionPromise);
                }
            }
            else {
                operations.push(updateFunctionCodePromise);
            }
        }
        if (resource.tags !== undefined) {
            const tagsToDelete = Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val === TagDeletion.DELETE)
                .map(([key, _val]) => key);
            const tagsToSet = {};
            Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val !== TagDeletion.DELETE)
                .forEach(([tagName, tagValue]) => {
                tagsToSet[tagName] = tagValue;
            });
            if (tagsToDelete.length > 0) {
                operations.push(lambda.untagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    TagKeys: tagsToDelete,
                }).promise());
            }
            if (Object.keys(tagsToSet).length > 0) {
                operations.push(lambda.tagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    Tags: tagsToSet,
                }).promise());
            }
        }
        // run all of our updates in parallel
        return Promise.all(operations);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQXFDO0FBRXJDLHFDQUFrSjtBQUdsSjs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxrQ0FBa0MsQ0FDdEQsU0FBaUIsRUFBRSxNQUFtQyxFQUFFLG1CQUFtRDs7SUFFM0cseUNBQXlDO0lBQ3pDLHNEQUFzRDtJQUN0RCw2R0FBNkc7SUFDN0csMEVBQTBFO0lBQzFFLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssc0JBQXNCLEVBQUU7UUFDbkQsT0FBTyw0QkFBbUIsQ0FBQyxVQUFVLENBQUM7S0FDdkM7SUFFRCxrQ0FBa0M7SUFDbEMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxvQkFBb0IsRUFBRTtRQUNqRCxPQUFPLDhCQUE4QixDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQy9DO0lBRUQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLDhCQUE4QixDQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQzNGLElBQUksT0FBTyxnQkFBZ0IsS0FBSyxRQUFRLEVBQUU7UUFDeEMsT0FBTyxnQkFBZ0IsQ0FBQztLQUN6QjtJQUVELE1BQU0sWUFBWSxHQUFHLE1BQU0sc0NBQTZCLENBQUMsU0FBUyxRQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSwwQ0FBRSxZQUFZLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUNuSSxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ2pCLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7S0FDckQ7SUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDO1FBQ2xFLFNBQVMsRUFBRSx5RUFBeUUsR0FBRyxZQUFZO0tBQ3BHLENBQUMsQ0FBQztJQUVILHdEQUF3RDtJQUN4RCxNQUFNLDJCQUEy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Jy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IENoYW5nZUhvdHN3YXBJbXBhY3QsIENoYW5nZUhvdHN3YXBSZXN1bHQsIGVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lLCBIb3Rzd2FwT3BlcmF0aW9uLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcblxuLyoqXG4gKiBSZXR1cm5zIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVGAgaWYgdGhlIGNoYW5nZSBjYW5ub3QgYmUgc2hvcnQtY2lyY3VpdGVkLFxuICogYENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVGAgaWYgdGhlIGNoYW5nZSBpcyBpcnJlbGV2YW50IGZyb20gYSBzaG9ydC1jaXJjdWl0IHBlcnNwZWN0aXZlXG4gKiAobGlrZSBhIGNoYW5nZSB0byBDREtNZXRhZGF0YSksXG4gKiBvciBhIExhbWJkYUZ1bmN0aW9uUmVzb3VyY2UgaWYgdGhlIGNoYW5nZSBjYW4gYmUgc2hvcnQtY2lyY3VpdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgLy8gaWYgdGhlIGNoYW5nZSBpcyBmb3IgYSBMYW1iZGEgVmVyc2lvbixcbiAgLy8gaWdub3JlIGl0IGJ5IHJldHVybmluZyBhbiBlbXB0eSBob3Rzd2FwIG9wZXJhdGlvbiAtXG4gIC8vIHdlIHdpbGwgcHVibGlzaCBhIG5ldyB2ZXJzaW9uIHdoZW4gd2UgZ2V0IHRvIGhvdHN3YXBwaW5nIHRoZSBhY3R1YWwgRnVuY3Rpb24gdGhpcyBWZXJzaW9uIHBvaW50cyB0bywgYmVsb3dcbiAgLy8gKFZlcnNpb25zIGNhbid0IGJlIGNoYW5nZWQgaW4gQ2xvdWRGb3JtYXRpb24gYW55d2F5LCB0aGV5J3JlIGltbXV0YWJsZSlcbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlID09PSAnQVdTOjpMYW1iZGE6OlZlcnNpb24nKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbiAgfVxuXG4gIC8vIHdlIGhhbmRsZSBBbGlhc2VzIHNwZWNpYWxseSB0b29cbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlID09PSAnQVdTOjpMYW1iZGE6OkFsaWFzJykge1xuICAgIHJldHVybiBjaGVja0FsaWFzSGFzVmVyc2lvbk9ubHlDaGFuZ2UoY2hhbmdlKTtcbiAgfVxuXG4gIGNvbnN0IGxhbWJkYUNvZGVDaGFuZ2UgPSBhd2FpdCBpc0xhbWJkYUZ1bmN0aW9uQ29kZU9ubHlDaGFuZ2UoY2hhbmdlLCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcbiAgaWYgKHR5cGVvZiBsYW1iZGFDb2RlQ2hhbmdlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBsYW1iZGFDb2RlQ2hhbmdlO1xuICB9XG5cbiAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXdhaXQgZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkLCBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uRnVuY3Rpb25OYW1lLCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcbiAgaWYgKCFmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gIH1cblxuICBjb25zdCBmdW5jdGlvbkFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHtcbiAgICAnRm46OlN1Yic6ICdhcm46JHtBV1M6OlBhcnRpdGlvbn06bGFtYmRhOiR7QVdTOjpSZWdpb259OiR7QVdTOjpBY2NvdW50SWR9OmZ1bmN0aW9uOicgKyBmdW5jdGlvbk5hbWUsXG4gIH0pO1xuXG4gIC8vIGZpbmQgYWxsIExhbWJkYSBWZXJzaW9ucyB0aGF0IHJlZmVyZW5jZSB0aGlzIEZ1bmN0aW9uXG4gIGNvbnN0IHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbiA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhsb2dpY2FsSWQpXG4gICAgLmZpbHRlcihyID0+IHIuVHlwZSA9PT0gJ0FXUzo6TGFtYmRhOjpWZXJzaW9uJyk7XG4gIC8vIGZpbmQgYWxsIExhbWJkYSBBbGlhc2VzIHRoYXQgcmVmZXJlbmNlIHRoZSBhYm92ZSBWZXJzaW9uc1xuICBjb25zdCBhbGlhc2VzUmVmZXJlbmNpbmdWZXJzaW9ucyA9IGZsYXRNYXAodmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uLCB2ID0+XG4gICAgZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKHYuTG9naWNhbElkKSk7XG4gIGNvbnN0IGFsaWFzZXNOYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKGFsaWFzZXNSZWZlcmVuY2luZ1ZlcnNpb25zLm1hcChhID0+XG4gICAgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oYS5Qcm9wZXJ0aWVzPy5OYW1lKSkpO1xuXG4gIHJldHVybiBuZXcgTGFtYmRhRnVuY3Rpb25Ib3Rzd2FwT3BlcmF0aW9uKHtcbiAgICBwaHlzaWNhbE5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICBmdW5jdGlvbkFybjogZnVuY3Rpb25Bcm4sXG4gICAgcmVzb3VyY2U6IGxhbWJkYUNvZGVDaGFuZ2UsXG4gICAgcHVibGlzaFZlcnNpb246IHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbi5sZW5ndGggPiAwLFxuICAgIGFsaWFzZXNOYW1lcyxcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyAgaXMgYSBnaXZlbiBBbGlhcyBjaGFuZ2UgaXMgb25seSBpbiB0aGUgJ0Z1bmN0aW9uVmVyc2lvbicgcHJvcGVydHksXG4gKiBhbmQgYENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UYCBpcyB0aGUgY2hhbmdlIGlzIGZvciBhbnkgb3RoZXIgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQWxpYXNIYXNWZXJzaW9uT25seUNoYW5nZShjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSk6IENoYW5nZUhvdHN3YXBSZXN1bHQge1xuICBmb3IgKGNvbnN0IHVwZGF0ZWRQcm9wTmFtZSBpbiBjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSB7XG4gICAgaWYgKHVwZGF0ZWRQcm9wTmFtZSAhPT0gJ0Z1bmN0aW9uVmVyc2lvbicpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlRgIGlmIHRoZSBjaGFuZ2UgaXMgbm90IGZvciBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGJ1dCBkb2Vzbid0IHByZXZlbnQgc2hvcnQtY2lyY3VpdGluZ1xuICogKGxpa2UgYSBjaGFuZ2UgdG8gQ0RLTWV0YWRhdGEgcmVzb3VyY2UpLFxuICogYENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UYCBpZiB0aGUgY2hhbmdlIGlzIHRvIGEgQVdTOjpMYW1iZGE6OkZ1bmN0aW9uLFxuICogYnV0IG5vdCBvbmx5IHRvIGl0cyBDb2RlIHByb3BlcnR5LFxuICogb3IgYSBMYW1iZGFGdW5jdGlvbkNvZGUgaWYgdGhlIGNoYW5nZSBpcyB0byBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGFuZCBvbmx5IGFmZmVjdHMgaXRzIENvZGUgcHJvcGVydHkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzTGFtYmRhRnVuY3Rpb25Db2RlT25seUNoYW5nZShcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8TGFtYmRhRnVuY3Rpb25DaGFuZ2UgfCBDaGFuZ2VIb3Rzd2FwSW1wYWN0PiB7XG4gIGNvbnN0IG5ld1Jlc291cmNlVHlwZSA9IGNoYW5nZS5uZXdWYWx1ZS5UeXBlO1xuICBpZiAobmV3UmVzb3VyY2VUeXBlICE9PSAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIC8qXG4gICAqIEF0IGZpcnN0IGdsYW5jZSwgd2Ugd291bGQgd2FudCB0byBpbml0aWFsaXplIHRoZXNlIHVzaW5nIHRoZSBcInByZXZpb3VzXCIgdmFsdWVzIChjaGFuZ2Uub2xkVmFsdWUpLFxuICAgKiBpbiBjYXNlIG9ubHkgb25lIG9mIHRoZW0gY2hhbmdlZCwgbGlrZSB0aGUga2V5LCBhbmQgdGhlIEJ1Y2tldCBzdGF5ZWQgdGhlIHNhbWUuXG4gICAqIEhvd2V2ZXIsIHRoYXQgYWN0dWFsbHkgZmFpbHMgZm9yIG9sZC1zdHlsZSBzeW50aGVzaXMsIHdoaWNoIHVzZXMgQ0ZOIFBhcmFtZXRlcnMhXG4gICAqIEJlY2F1c2UgdGhlIG5hbWVzIG9mIHRoZSBQYXJhbWV0ZXJzIGRlcGVuZCBvbiB0aGUgaGFzaCBvZiB0aGUgQXNzZXQsXG4gICAqIHRoZSBQYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBcIm9sZFwiIHZhbHVlcyBubyBsb25nZXIgZXhpc3QgaW4gYGFzc2V0UGFyYW1zYCBhdCB0aGlzIHBvaW50LFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBoYXZlIHRoZSBjb3JyZWN0IHZhbHVlcyBhdmFpbGFibGUgdG8gZXZhbHVhdGUgdGhlIENGTiBleHByZXNzaW9uIHdpdGguXG4gICAqIEZvcnR1bmF0ZWx5LCB0aGUgZGlmZiB3aWxsIGFsd2F5cyBpbmNsdWRlIGJvdGggdGhlIHMzQnVja2V0IGFuZCBzM0tleSBwYXJ0cyBvZiB0aGUgTGFtYmRhJ3MgQ29kZSBwcm9wZXJ0eSxcbiAgICogZXZlbiBpZiBvbmx5IG9uZSBvZiB0aGVtIHdhcyBhY3R1YWxseSBjaGFuZ2VkLFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBuZWVkIHRoZSBcIm9sZFwiIHZhbHVlcyBhdCBhbGwsIGFuZCB3ZSBjYW4gc2FmZWx5IGluaXRpYWxpemUgdGhlc2Ugd2l0aCBqdXN0IGAnJ2AuXG4gICAqL1xuICBjb25zdCBwcm9wZXJ0eVVwZGF0ZXMgPSBjaGFuZ2UucHJvcGVydHlVcGRhdGVzO1xuICBsZXQgY29kZTogTGFtYmRhRnVuY3Rpb25Db2RlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgdGFnczogTGFtYmRhRnVuY3Rpb25UYWdzIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGZvciAoY29uc3QgdXBkYXRlZFByb3BOYW1lIGluIHByb3BlcnR5VXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wID0gcHJvcGVydHlVcGRhdGVzW3VwZGF0ZWRQcm9wTmFtZV07XG5cbiAgICBzd2l0Y2ggKHVwZGF0ZWRQcm9wTmFtZSkge1xuICAgICAgY2FzZSAnQ29kZSc6XG4gICAgICAgIGxldCBmb3VuZENvZGVEaWZmZXJlbmNlID0gZmFsc2U7XG4gICAgICAgIGxldCBzM0J1Y2tldCA9ICcnLCBzM0tleSA9ICcnO1xuXG4gICAgICAgIGZvciAoY29uc3QgbmV3UHJvcE5hbWUgaW4gdXBkYXRlZFByb3AubmV3VmFsdWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld1Byb3BOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdTM0J1Y2tldCc6XG4gICAgICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBzM0J1Y2tldCA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUzNLZXknOlxuICAgICAgICAgICAgICBmb3VuZENvZGVEaWZmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgczNLZXkgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kQ29kZURpZmZlcmVuY2UpIHtcbiAgICAgICAgICBjb2RlID0ge1xuICAgICAgICAgICAgczNCdWNrZXQsXG4gICAgICAgICAgICBzM0tleSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVGFncyc6XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRhZyB1cGRhdGVzIGFyZSBhIGJpdCBvZGQ7IHRoZXkgbWFuaWZlc3QgYXMgdHdvIGxpc3RzLCBhcmUgZmxhZ2dlZCBvbmx5IGFzXG4gICAgICAgICAqIGBpc0RpZmZlcmVudGAsIGFuZCB3ZSBoYXZlIHRvIHJlY29uY2lsZSB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdGFnVXBkYXRlczogeyBbdGFnOiBzdHJpbmddOiBzdHJpbmcgfCBUYWdEZWxldGlvbiB9ID0ge307XG4gICAgICAgIGlmICh1cGRhdGVkUHJvcD8uaXNEaWZmZXJlbnQpIHtcbiAgICAgICAgICB1cGRhdGVkUHJvcC5uZXdWYWx1ZS5mb3JFYWNoKCh0YWc6IENmbkRpZmZUYWdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGFnVXBkYXRlc1t0YWcuS2V5XSA9IHRhZy5WYWx1ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVwZGF0ZWRQcm9wLm9sZFZhbHVlLmZvckVhY2goKHRhZzogQ2ZuRGlmZlRhZ1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnVXBkYXRlc1t0YWcuS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRhZ1VwZGF0ZXNbdGFnLktleV0gPSBUYWdEZWxldGlvbi5ERUxFVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0YWdzID0geyB0YWdVcGRhdGVzIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvZGUgfHwgdGFncyA/IHsgY29kZSwgdGFncyB9IDogQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UO1xufVxuXG5pbnRlcmZhY2UgQ2ZuRGlmZlRhZ1ZhbHVlIHtcbiAgcmVhZG9ubHkgS2V5OiBzdHJpbmc7XG4gIHJlYWRvbmx5IFZhbHVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvbkNvZGUge1xuICByZWFkb25seSBzM0J1Y2tldDogc3RyaW5nO1xuICByZWFkb25seSBzM0tleTogc3RyaW5nO1xufVxuXG5lbnVtIFRhZ0RlbGV0aW9uIHtcbiAgREVMRVRFID0gLTEsXG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvblRhZ3Mge1xuICByZWFkb25seSB0YWdVcGRhdGVzOiB7IFt0YWcgOiBzdHJpbmddIDogc3RyaW5nIHwgVGFnRGVsZXRpb24gfTtcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uQ2hhbmdlIHtcbiAgcmVhZG9ubHkgY29kZT86IExhbWJkYUZ1bmN0aW9uQ29kZTtcbiAgcmVhZG9ubHkgdGFncz86IExhbWJkYUZ1bmN0aW9uVGFncztcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uUmVzb3VyY2Uge1xuICByZWFkb25seSBwaHlzaWNhbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgZnVuY3Rpb25Bcm46IHN0cmluZztcbiAgcmVhZG9ubHkgcmVzb3VyY2U6IExhbWJkYUZ1bmN0aW9uQ2hhbmdlO1xuICByZWFkb25seSBwdWJsaXNoVmVyc2lvbjogYm9vbGVhbjtcbiAgcmVhZG9ubHkgYWxpYXNlc05hbWVzOiBzdHJpbmdbXTtcbn1cblxuY2xhc3MgTGFtYmRhRnVuY3Rpb25Ib3Rzd2FwT3BlcmF0aW9uIGltcGxlbWVudHMgSG90c3dhcE9wZXJhdGlvbiB7XG4gIHB1YmxpYyByZWFkb25seSBzZXJ2aWNlID0gJ2xhbWJkYS1mdW5jdGlvbic7XG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZU5hbWVzOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGxhbWJkYUZ1bmN0aW9uUmVzb3VyY2U6IExhbWJkYUZ1bmN0aW9uUmVzb3VyY2UpIHtcbiAgICB0aGlzLnJlc291cmNlTmFtZXMgPSBbXG4gICAgICBgTGFtYmRhIEZ1bmN0aW9uICcke2xhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lfSdgLFxuICAgICAgLy8gYWRkIFZlcnNpb24gaGVyZSBpZiB3ZSdyZSBwdWJsaXNoaW5nIGEgbmV3IG9uZVxuICAgICAgLi4uKGxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucHVibGlzaFZlcnNpb24gPyBbYExhbWJkYSBWZXJzaW9uIGZvciBGdW5jdGlvbiAnJHtsYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZX0nYF0gOiBbXSksXG4gICAgICAvLyBhZGQgYW55IEFsaWFzZXMgdGhhdCB3ZSBhcmUgaG90c3dhcHBpbmcgaGVyZVxuICAgICAgLi4ubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5hbGlhc2VzTmFtZXMubWFwKGFsaWFzID0+IGBMYW1iZGEgQWxpYXMgJyR7YWxpYXN9JyBmb3IgRnVuY3Rpb24gJyR7bGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWV9J2ApLFxuICAgIF07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYXBwbHkoc2RrOiBJU0RLKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBsYW1iZGEgPSBzZGsubGFtYmRhKCk7XG4gICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucmVzb3VyY2U7XG4gICAgY29uc3Qgb3BlcmF0aW9uczogUHJvbWlzZTxhbnk+W10gPSBbXTtcblxuICAgIGlmIChyZXNvdXJjZS5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZUZ1bmN0aW9uQ29kZVByb21pc2UgPSBsYW1iZGEudXBkYXRlRnVuY3Rpb25Db2RlKHtcbiAgICAgICAgRnVuY3Rpb25OYW1lOiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lLFxuICAgICAgICBTM0J1Y2tldDogcmVzb3VyY2UuY29kZS5zM0J1Y2tldCxcbiAgICAgICAgUzNLZXk6IHJlc291cmNlLmNvZGUuczNLZXksXG4gICAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAgIC8vIG9ubHkgaWYgdGhlIGNvZGUgY2hhbmdlZCBpcyB0aGVyZSBhbnkgcG9pbnQgaW4gcHVibGlzaGluZyBhIG5ldyBWZXJzaW9uXG4gICAgICBpZiAodGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnB1Ymxpc2hWZXJzaW9uKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGNvZGUgdXBkYXRlIHRvIGJlIGRvbmUgYmVmb3JlIHB1Ymxpc2hpbmcgYSBuZXcgVmVyc2lvblxuICAgICAgICBhd2FpdCB1cGRhdGVGdW5jdGlvbkNvZGVQcm9taXNlO1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCB3YWl0IGZvciB0aGUgRnVuY3Rpb24gdG8gZmluaXNoIHVwZGF0aW5nLFxuICAgICAgICAvLyB3ZSBjYW4gZ2V0IGEgXCJUaGUgb3BlcmF0aW9uIGNhbm5vdCBiZSBwZXJmb3JtZWQgYXQgdGhpcyB0aW1lLiBBbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3MgZm9yIHJlc291cmNlOlwiXG4gICAgICAgIC8vIGVycm9yIHdoZW4gcHVibGlzaGluZyBhIG5ldyBWZXJzaW9uXG4gICAgICAgIGF3YWl0IGxhbWJkYS53YWl0Rm9yKCdmdW5jdGlvblVwZGF0ZWQnLCB7XG4gICAgICAgICAgRnVuY3Rpb25OYW1lOiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lLFxuICAgICAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAgICAgY29uc3QgcHVibGlzaFZlcnNpb25Qcm9taXNlID0gbGFtYmRhLnB1Ymxpc2hWZXJzaW9uKHtcbiAgICAgICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgICBpZiAodGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmFsaWFzZXNOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgVmVyc2lvbiB0byBmaW5pc2ggcHVibGlzaGluZ1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25VcGRhdGUgPSBhd2FpdCBwdWJsaXNoVmVyc2lvblByb21pc2U7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5hbGlhc2VzTmFtZXMpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChsYW1iZGEudXBkYXRlQWxpYXMoe1xuICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgICAgICAgICAgIE5hbWU6IGFsaWFzLFxuICAgICAgICAgICAgICBGdW5jdGlvblZlcnNpb246IHZlcnNpb25VcGRhdGUuVmVyc2lvbixcbiAgICAgICAgICAgIH0pLnByb21pc2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChwdWJsaXNoVmVyc2lvblByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVyYXRpb25zLnB1c2godXBkYXRlRnVuY3Rpb25Db2RlUHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc291cmNlLnRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGFnc1RvRGVsZXRlOiBzdHJpbmdbXSA9IE9iamVjdC5lbnRyaWVzKHJlc291cmNlLnRhZ3MudGFnVXBkYXRlcylcbiAgICAgICAgLmZpbHRlcigoW19rZXksIHZhbF0pID0+IHZhbCA9PT0gVGFnRGVsZXRpb24uREVMRVRFKVxuICAgICAgICAubWFwKChba2V5LCBfdmFsXSkgPT4ga2V5KTtcblxuICAgICAgY29uc3QgdGFnc1RvU2V0OiB7IFt0YWc6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICBPYmplY3QuZW50cmllcyhyZXNvdXJjZS50YWdzIS50YWdVcGRhdGVzKVxuICAgICAgICAuZmlsdGVyKChbX2tleSwgdmFsXSkgPT4gdmFsICE9PSBUYWdEZWxldGlvbi5ERUxFVEUpXG4gICAgICAgIC5mb3JFYWNoKChbdGFnTmFtZSwgdGFnVmFsdWVdKSA9PiB7XG4gICAgICAgICAgdGFnc1RvU2V0W3RhZ05hbWVdID0gdGFnVmFsdWUgYXMgc3RyaW5nO1xuICAgICAgICB9KTtcblxuICAgICAgaWYgKHRhZ3NUb0RlbGV0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaChsYW1iZGEudW50YWdSZXNvdXJjZSh7XG4gICAgICAgICAgUmVzb3VyY2U6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5mdW5jdGlvbkFybixcbiAgICAgICAgICBUYWdLZXlzOiB0YWdzVG9EZWxldGUsXG4gICAgICAgIH0pLnByb21pc2UoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyh0YWdzVG9TZXQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhbWJkYS50YWdSZXNvdXJjZSh7XG4gICAgICAgICAgUmVzb3VyY2U6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5mdW5jdGlvbkFybixcbiAgICAgICAgICBUYWdzOiB0YWdzVG9TZXQsXG4gICAgICAgIH0pLnByb21pc2UoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcnVuIGFsbCBvZiBvdXIgdXBkYXRlcyBpbiBwYXJhbGxlbFxuICAgIHJldHVybiBQcm9taXNlLmFsbChvcGVyYXRpb25zKTtcbiAgfVxufVxuIl19