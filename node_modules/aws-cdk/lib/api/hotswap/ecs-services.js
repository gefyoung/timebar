"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we should allow is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    for (const updatedPropName in change.propertyUpdates) {
        // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
        // it contains the image and environment variables, so seems like a safe bet for now.
        // We might revisit this decision in the future though!
        if (updatedPropName !== 'ContainerDefinitions') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        const containerDefinitionsDifference = (change.propertyUpdates)[updatedPropName];
        if (containerDefinitionsDifference.newValue === undefined) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    // at this point, we know the TaskDefinition can be hotswapped
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0 ||
        resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if there are either no resources referencing the TaskDefinition,
        // or something besides an ECS Service is referencing it,
        // hotswap is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const taskDefinitionResource = change.newValue.Properties;
    // first, let's get the name of the family
    const familyNameOrArn = await common_1.establishResourcePhysicalName(logicalId, taskDefinitionResource === null || taskDefinitionResource === void 0 ? void 0 : taskDefinitionResource.Family, evaluateCfnTemplate);
    if (!familyNameOrArn) {
        // if the Family property has not bee provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    const evaluatedTaskDef = {
        ...await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource !== null && taskDefinitionResource !== void 0 ? taskDefinitionResource : {}),
            Family: undefined,
        }),
        Family: family,
    };
    return new EcsServiceHotswapOperation(evaluatedTaskDef, ecsServicesReferencingTaskDef);
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
class EcsServiceHotswapOperation {
    constructor(taskDefinitionResource, servicesReferencingTaskDef) {
        this.taskDefinitionResource = taskDefinitionResource;
        this.servicesReferencingTaskDef = servicesReferencingTaskDef;
        this.service = 'ecs-service';
        this.resourceNames = [];
        this.resourceNames = servicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`);
    }
    async apply(sdk) {
        var _a;
        // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
        // we need to lowercase the evaluated TaskDef from CloudFormation,
        // as the AWS SDK uses lowercase property names for these
        const lowercasedTaskDef = common_1.transformObjectKeys(this.taskDefinitionResource, common_1.lowerCaseFirstCharacter);
        const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
        const taskDefRevArn = (_a = registerTaskDefResponse.taskDefinition) === null || _a === void 0 ? void 0 : _a.taskDefinitionArn;
        // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
        const servicePerClusterUpdates = {};
        for (const ecsService of this.servicesReferencingTaskDef) {
            const clusterName = ecsService.serviceArn.split('/')[1];
            const existingClusterPromises = servicePerClusterUpdates[clusterName];
            let clusterPromises;
            if (existingClusterPromises) {
                clusterPromises = existingClusterPromises;
            }
            else {
                clusterPromises = [];
                servicePerClusterUpdates[clusterName] = clusterPromises;
            }
            clusterPromises.push({
                promise: sdk.ecs().updateService({
                    service: ecsService.serviceArn,
                    taskDefinition: taskDefRevArn,
                    cluster: clusterName,
                    forceNewDeployment: true,
                    deploymentConfiguration: {
                        minimumHealthyPercent: 0,
                    },
                }).promise(),
                ecsService: ecsService,
            });
        }
        await Promise.all(Object.values(servicePerClusterUpdates)
            .map(clusterUpdates => {
            return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
        }));
        // Step 3 - wait for the service deployments triggered in Step 2 to finish
        // configure a custom Waiter
        sdk.ecs().api.waiters.deploymentToFinish = {
            name: 'DeploymentToFinish',
            operation: 'describeServices',
            delay: 10,
            maxAttempts: 60,
            acceptors: [
                {
                    matcher: 'pathAny',
                    argument: 'failures[].reason',
                    expected: 'MISSING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'DRAINING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'INACTIVE',
                    state: 'failure',
                },
                {
                    matcher: 'path',
                    argument: "length(services[].deployments[? status == 'PRIMARY' && runningCount < desiredCount][]) == `0`",
                    expected: true,
                    state: 'success',
                },
            ],
        };
        // create a custom Waiter that uses the deploymentToFinish configuration added above
        const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentToFinish');
        // wait for all of the waiters to finish
        return Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
            return deploymentWaiter.wait({
                cluster: clusterName,
                services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
            }).promise();
        }));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUUvQixxQ0FBZ007QUFHekwsS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLG9FQUFvRTtJQUNwRSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFO1FBQ3ZELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7S0FDckQ7SUFFRCxLQUFLLE1BQU0sZUFBZSxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUU7UUFDcEQscUZBQXFGO1FBQ3JGLHFGQUFxRjtRQUNyRix1REFBdUQ7UUFDdkQsSUFBSSxlQUFlLEtBQUssc0JBQXNCLEVBQUU7WUFDOUMsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztTQUNyRDtRQUNELE1BQU0sOEJBQThCLEdBQUcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDakYsSUFBSSw4QkFBOEIsQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQ3pELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7S0FDRjtJQUNELDhEQUE4RDtJQUU5RCx1RUFBdUU7SUFDdkUsTUFBTSwyQkFBMkIsR0FBRyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRixNQUFNLHFDQUFxQyxHQUFHLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLENBQUMsQ0FBQztJQUN0SCxNQUFNLDZCQUE2QixHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7SUFDOUQsS0FBSyxNQUFNLGtCQUFrQixJQUFJLHFDQUFxQyxFQUFFO1FBQ3RFLE1BQU0sVUFBVSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0YsSUFBSSxVQUFVLEVBQUU7WUFDZCw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQ3BEO0tBQ0Y7SUFDRCxJQUFJLDZCQUE2QixDQUFDLE1BQU0sS0FBSyxDQUFDO1FBQzFDLDJCQUEyQixDQUFDLE1BQU0sR0FBRyw2QkFBNkIsQ0FBQyxNQUFNLEVBQUU7UUFDN0UsbUVBQW1FO1FBQ25FLHlEQUF5RDtRQUN6RCwwQkFBMEI7UUFDMUIsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztLQUNyRDtJQUVELE1BQU0sc0JBQXNCLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7SUFDMUQsMENBQTBDO0lBQzFDLE1BQU0sZUFBZSxHQUFHLE1BQU0sc0NBQTZCLENBQUMsU0FBUyxFQUFFLHNCQUFzQixhQUF0QixzQkFBc0IsdUJBQXRCLHNCQUFzQixDQUFFLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQzVILElBQUksQ0FBQyxlQUFlLEVBQUU7UUFDcEIsMEZBQTBGO1FBQzFGLHlDQUF5QztRQUN6QyxPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO0tBQ3JEO0lBQ0QsOEdBQThHO0lBQzlHLHNCQUFzQjtJQUN0QixNQUFNLG9CQUFvQixHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEQsTUFBTSxNQUFNLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxHQUFHLENBQUM7UUFDNUMsNkhBQTZIO1FBQzdILDREQUE0RDtRQUM1RCxDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxnR0FBZ0c7UUFDaEcsQ0FBQyxDQUFDLGVBQWUsQ0FBQztJQUNwQiw4RkFBOEY7SUFDOUYsTUFBTSxnQkFBZ0IsR0FBRztRQUN2QixHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUM7WUFDakQsR0FBRyxDQUFDLHNCQUFzQixhQUF0QixzQkFBc0IsY0FBdEIsc0JBQXNCLEdBQUksRUFBRSxDQUFDO1lBQ2pDLE1BQU0sRUFBRSxTQUFTO1NBQ2xCLENBQUM7UUFDRixNQUFNLEVBQUUsTUFBTTtLQUNmLENBQUM7SUFDRixPQUFPLElBQUksMEJBQTBCLENBQUMsZ0JBQWdCLEVBQUUsNkJBQTZCLENBQUMsQ0FBQztBQUN6RixDQUFDO0FBbEVELHdFQWtFQztBQU1ELE1BQU0sMEJBQTBCO0lBSTlCLFlBQ21CLHNCQUEyQixFQUMzQiwwQkFBd0M7UUFEeEMsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUFLO1FBQzNCLCtCQUEwQixHQUExQiwwQkFBMEIsQ0FBYztRQUwzQyxZQUFPLEdBQUcsYUFBYSxDQUFDO1FBQ3hCLGtCQUFhLEdBQWEsRUFBRSxDQUFDO1FBTTNDLElBQUksQ0FBQyxhQUFhLEdBQUcsMEJBQTBCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQy9ELGdCQUFnQixVQUFVLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVNLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBUzs7UUFDMUIscUZBQXFGO1FBQ3JGLGtFQUFrRTtRQUNsRSx5REFBeUQ7UUFDekQsTUFBTSxpQkFBaUIsR0FBRyw0QkFBbUIsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsZ0NBQXVCLENBQUMsQ0FBQztRQUNwRyxNQUFNLHVCQUF1QixHQUFHLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLHNCQUFzQixDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEcsTUFBTSxhQUFhLFNBQUcsdUJBQXVCLENBQUMsY0FBYywwQ0FBRSxpQkFBaUIsQ0FBQztRQUVoRixxR0FBcUc7UUFDckcsTUFBTSx3QkFBd0IsR0FBb0YsRUFBRSxDQUFDO1FBQ3JILEtBQUssTUFBTSxVQUFVLElBQUksSUFBSSxDQUFDLDBCQUEwQixFQUFFO1lBQ3hELE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXhELE1BQU0sdUJBQXVCLEdBQUcsd0JBQXdCLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDdEUsSUFBSSxlQUF5RSxDQUFDO1lBQzlFLElBQUksdUJBQXVCLEVBQUU7Z0JBQzNCLGVBQWUsR0FBRyx1QkFBdUIsQ0FBQzthQUMzQztpQkFBTTtnQkFDTCxlQUFlLEdBQUcsRUFBRSxDQUFDO2dCQUNyQix3QkFBd0IsQ0FBQyxXQUFXLENBQUMsR0FBRyxlQUFlLENBQUM7YUFDekQ7WUFFRCxlQUFlLENBQUMsSUFBSSxDQUFDO2dCQUNuQixPQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQztvQkFDL0IsT0FBTyxFQUFFLFVBQVUsQ0FBQyxVQUFVO29CQUM5QixjQUFjLEVBQUUsYUFBYTtvQkFDN0IsT0FBTyxFQUFFLFdBQVc7b0JBQ3BCLGtCQUFrQixFQUFFLElBQUk7b0JBQ3hCLHVCQUF1QixFQUFFO3dCQUN2QixxQkFBcUIsRUFBRSxDQUFDO3FCQUN6QjtpQkFDRixDQUFDLENBQUMsT0FBTyxFQUFFO2dCQUNaLFVBQVUsRUFBRSxVQUFVO2FBQ3ZCLENBQUMsQ0FBQztTQUNKO1FBQ0QsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUM7YUFDdEQsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQ3BCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDakYsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLDBFQUEwRTtRQUMxRSw0QkFBNEI7UUFDM0IsR0FBRyxDQUFDLEdBQUcsRUFBVSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLEdBQUc7WUFDbEQsSUFBSSxFQUFFLG9CQUFvQjtZQUMxQixTQUFTLEVBQUUsa0JBQWtCO1lBQzdCLEtBQUssRUFBRSxFQUFFO1lBQ1QsV0FBVyxFQUFFLEVBQUU7WUFDZixTQUFTLEVBQUU7Z0JBQ1Q7b0JBQ0UsT0FBTyxFQUFFLFNBQVM7b0JBQ2xCLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFFBQVEsRUFBRSxTQUFTO29CQUNuQixLQUFLLEVBQUUsU0FBUztpQkFDakI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLFNBQVM7b0JBQ2xCLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFFBQVEsRUFBRSxVQUFVO29CQUNwQixLQUFLLEVBQUUsU0FBUztpQkFDakI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLFNBQVM7b0JBQ2xCLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFFBQVEsRUFBRSxVQUFVO29CQUNwQixLQUFLLEVBQUUsU0FBUztpQkFDakI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLE1BQU07b0JBQ2YsUUFBUSxFQUFFLCtGQUErRjtvQkFDekcsUUFBUSxFQUFFLElBQUk7b0JBQ2QsS0FBSyxFQUFFLFNBQVM7aUJBQ2pCO2FBQ0Y7U0FDRixDQUFDO1FBQ0Ysb0ZBQW9GO1FBQ3BGLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSyxHQUFXLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1FBQzFGLHdDQUF3QztRQUN4QyxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxFQUFFLEVBQUU7WUFDaEcsT0FBTyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7Z0JBQzNCLE9BQU8sRUFBRSxXQUFXO2dCQUNwQixRQUFRLEVBQUUsY0FBYyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO2FBQ25GLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNmLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDTixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUsIEhvdHN3YXBPcGVyYXRpb24sIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIHRyYW5zZm9ybU9iamVjdEtleXMgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgLy8gdGhlIG9ubHkgcmVzb3VyY2UgY2hhbmdlIHdlIHNob3VsZCBhbGxvdyBpcyBhbiBFQ1MgVGFza0RlZmluaXRpb25cbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlICE9PSAnQVdTOjpFQ1M6OlRhc2tEZWZpbml0aW9uJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIGZvciAoY29uc3QgdXBkYXRlZFByb3BOYW1lIGluIGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpIHtcbiAgICAvLyBXZSBvbmx5IGFsbG93IGEgY2hhbmdlIGluIHRoZSBDb250YWluZXJEZWZpbml0aW9ucyBvZiB0aGUgVGFza0RlZmluaXRpb24gZm9yIG5vdyAtXG4gICAgLy8gaXQgY29udGFpbnMgdGhlIGltYWdlIGFuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHNvIHNlZW1zIGxpa2UgYSBzYWZlIGJldCBmb3Igbm93LlxuICAgIC8vIFdlIG1pZ2h0IHJldmlzaXQgdGhpcyBkZWNpc2lvbiBpbiB0aGUgZnV0dXJlIHRob3VnaCFcbiAgICBpZiAodXBkYXRlZFByb3BOYW1lICE9PSAnQ29udGFpbmVyRGVmaW5pdGlvbnMnKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lckRlZmluaXRpb25zRGlmZmVyZW5jZSA9IChjaGFuZ2UucHJvcGVydHlVcGRhdGVzKVt1cGRhdGVkUHJvcE5hbWVdO1xuICAgIGlmIChjb250YWluZXJEZWZpbml0aW9uc0RpZmZlcmVuY2UubmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgIH1cbiAgfVxuICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBrbm93IHRoZSBUYXNrRGVmaW5pdGlvbiBjYW4gYmUgaG90c3dhcHBlZFxuXG4gIC8vIGZpbmQgYWxsIEVDUyBTZXJ2aWNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgVGFza0RlZmluaXRpb24gdGhhdCBjaGFuZ2VkXG4gIGNvbnN0IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhsb2dpY2FsSWQpO1xuICBjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcihyID0+IHIuVHlwZSA9PT0gJ0FXUzo6RUNTOjpTZXJ2aWNlJyk7XG4gIGNvbnN0IGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gbmV3IEFycmF5PEVjc1NlcnZpY2U+KCk7XG4gIGZvciAoY29uc3QgZWNzU2VydmljZVJlc291cmNlIG9mIGVjc1NlcnZpY2VSZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYpIHtcbiAgICBjb25zdCBzZXJ2aWNlQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUGh5c2ljYWxOYW1lRm9yKGVjc1NlcnZpY2VSZXNvdXJjZS5Mb2dpY2FsSWQpO1xuICAgIGlmIChzZXJ2aWNlQXJuKSB7XG4gICAgICBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5wdXNoKHsgc2VydmljZUFybiB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCA+IGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCkge1xuICAgIC8vIGlmIHRoZXJlIGFyZSBlaXRoZXIgbm8gcmVzb3VyY2VzIHJlZmVyZW5jaW5nIHRoZSBUYXNrRGVmaW5pdGlvbixcbiAgICAvLyBvciBzb21ldGhpbmcgYmVzaWRlcyBhbiBFQ1MgU2VydmljZSBpcyByZWZlcmVuY2luZyBpdCxcbiAgICAvLyBob3Rzd2FwIGlzIG5vdCBwb3NzaWJsZVxuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIGNvbnN0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2UgPSBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcztcbiAgLy8gZmlyc3QsIGxldCdzIGdldCB0aGUgbmFtZSBvZiB0aGUgZmFtaWx5XG4gIGNvbnN0IGZhbWlseU5hbWVPckFybiA9IGF3YWl0IGVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lKGxvZ2ljYWxJZCwgdGFza0RlZmluaXRpb25SZXNvdXJjZT8uRmFtaWx5LCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcbiAgaWYgKCFmYW1pbHlOYW1lT3JBcm4pIHtcbiAgICAvLyBpZiB0aGUgRmFtaWx5IHByb3BlcnR5IGhhcyBub3QgYmVlIHByb3ZpZGVkLCBhbmQgd2UgY2FuJ3QgZmluZCBpdCBpbiB0aGUgY3VycmVudCBTdGFjayxcbiAgICAvLyB0aGlzIG1lYW5zIGhvdHN3YXBwaW5nIGlzIG5vdCBwb3NzaWJsZVxuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuICAvLyB0aGUgcGh5c2ljYWwgbmFtZSBvZiB0aGUgVGFzayBEZWZpbml0aW9uIGluIENsb3VkRm9ybWF0aW9uIGluY2x1ZGVzIGl0cyBjdXJyZW50IHJldmlzaW9uIG51bWJlciBhdCB0aGUgZW5kLFxuICAvLyByZW1vdmUgaXQgaWYgbmVlZGVkXG4gIGNvbnN0IGZhbWlseU5hbWVPckFyblBhcnRzID0gZmFtaWx5TmFtZU9yQXJuLnNwbGl0KCc6Jyk7XG4gIGNvbnN0IGZhbWlseSA9IGZhbWlseU5hbWVPckFyblBhcnRzLmxlbmd0aCA+IDFcbiAgICAvLyBmYW1pbHlOYW1lT3JBcm4gaXMgYWN0dWFsbHkgYW4gQVJOLCBvZiB0aGUgZm9ybWF0ICdhcm46YXdzOmVjczpyZWdpb246YWNjb3VudDp0YXNrLWRlZmluaXRpb24vPGZhbWlseS1uYW1lPjo8cmV2aXNpb24tbnI+J1xuICAgIC8vIHNvLCB0YWtlIHRoZSA2dGggZWxlbWVudCwgYXQgaW5kZXggNSwgYW5kIHNwbGl0IGl0IG9uICcvJ1xuICAgID8gZmFtaWx5TmFtZU9yQXJuUGFydHNbNV0uc3BsaXQoJy8nKVsxXVxuICAgIC8vIG90aGVyd2lzZSwgZmFtaWx5TmFtZU9yQXJuIGlzIGp1c3QgdGhlIHNpbXBsZSBuYW1lIGV2YWx1YXRlZCBmcm9tIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZVxuICAgIDogZmFtaWx5TmFtZU9yQXJuO1xuICAvLyB0aGVuLCBsZXQncyBldmFsdWF0ZSB0aGUgYm9keSBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBUYXNrRGVmICh3aXRob3V0IHRoZSBGYW1pbHkgcHJvcGVydHkpXG4gIGNvbnN0IGV2YWx1YXRlZFRhc2tEZWYgPSB7XG4gICAgLi4uYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oe1xuICAgICAgLi4uKHRhc2tEZWZpbml0aW9uUmVzb3VyY2UgPz8ge30pLFxuICAgICAgRmFtaWx5OiB1bmRlZmluZWQsXG4gICAgfSksXG4gICAgRmFtaWx5OiBmYW1pbHksXG4gIH07XG4gIHJldHVybiBuZXcgRWNzU2VydmljZUhvdHN3YXBPcGVyYXRpb24oZXZhbHVhdGVkVGFza0RlZiwgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYpO1xufVxuXG5pbnRlcmZhY2UgRWNzU2VydmljZSB7XG4gIHJlYWRvbmx5IHNlcnZpY2VBcm46IHN0cmluZztcbn1cblxuY2xhc3MgRWNzU2VydmljZUhvdHN3YXBPcGVyYXRpb24gaW1wbGVtZW50cyBIb3Rzd2FwT3BlcmF0aW9uIHtcbiAgcHVibGljIHJlYWRvbmx5IHNlcnZpY2UgPSAnZWNzLXNlcnZpY2UnO1xuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhc2tEZWZpbml0aW9uUmVzb3VyY2U6IGFueSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmOiBFY3NTZXJ2aWNlW10sXG4gICkge1xuICAgIHRoaXMucmVzb3VyY2VOYW1lcyA9IHNlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLm1hcChlY3NTZXJ2aWNlID0+XG4gICAgICBgRUNTIFNlcnZpY2UgJyR7ZWNzU2VydmljZS5zZXJ2aWNlQXJuLnNwbGl0KCcvJylbMl19J2ApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFwcGx5KHNkazogSVNESyk6IFByb21pc2U8YW55PiB7XG4gICAgLy8gU3RlcCAxIC0gdXBkYXRlIHRoZSBjaGFuZ2VkIFRhc2tEZWZpbml0aW9uLCBjcmVhdGluZyBhIG5ldyBUYXNrRGVmaW5pdGlvbiBSZXZpc2lvblxuICAgIC8vIHdlIG5lZWQgdG8gbG93ZXJjYXNlIHRoZSBldmFsdWF0ZWQgVGFza0RlZiBmcm9tIENsb3VkRm9ybWF0aW9uLFxuICAgIC8vIGFzIHRoZSBBV1MgU0RLIHVzZXMgbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIGZvciB0aGVzZVxuICAgIGNvbnN0IGxvd2VyY2FzZWRUYXNrRGVmID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh0aGlzLnRhc2tEZWZpbml0aW9uUmVzb3VyY2UsIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyKTtcbiAgICBjb25zdCByZWdpc3RlclRhc2tEZWZSZXNwb25zZSA9IGF3YWl0IHNkay5lY3MoKS5yZWdpc3RlclRhc2tEZWZpbml0aW9uKGxvd2VyY2FzZWRUYXNrRGVmKS5wcm9taXNlKCk7XG4gICAgY29uc3QgdGFza0RlZlJldkFybiA9IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlLnRhc2tEZWZpbml0aW9uPy50YXNrRGVmaW5pdGlvbkFybjtcblxuICAgIC8vIFN0ZXAgMiAtIHVwZGF0ZSB0aGUgc2VydmljZXMgdXNpbmcgdGhhdCBUYXNrRGVmaW5pdGlvbiB0byBwb2ludCB0byB0aGUgbmV3IFRhc2tEZWZpbml0aW9uIFJldmlzaW9uXG4gICAgY29uc3Qgc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzOiB7IFtjbHVzdGVyOiBzdHJpbmddOiBBcnJheTx7IHByb21pc2U6IFByb21pc2U8YW55PiwgZWNzU2VydmljZTogRWNzU2VydmljZSB9PiB9ID0ge307XG4gICAgZm9yIChjb25zdCBlY3NTZXJ2aWNlIG9mIHRoaXMuc2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYpIHtcbiAgICAgIGNvbnN0IGNsdXN0ZXJOYW1lID0gZWNzU2VydmljZS5zZXJ2aWNlQXJuLnNwbGl0KCcvJylbMV07XG5cbiAgICAgIGNvbnN0IGV4aXN0aW5nQ2x1c3RlclByb21pc2VzID0gc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzW2NsdXN0ZXJOYW1lXTtcbiAgICAgIGxldCBjbHVzdGVyUHJvbWlzZXM6IEFycmF5PHsgcHJvbWlzZTogUHJvbWlzZTxhbnk+LCBlY3NTZXJ2aWNlOiBFY3NTZXJ2aWNlIH0+O1xuICAgICAgaWYgKGV4aXN0aW5nQ2x1c3RlclByb21pc2VzKSB7XG4gICAgICAgIGNsdXN0ZXJQcm9taXNlcyA9IGV4aXN0aW5nQ2x1c3RlclByb21pc2VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2x1c3RlclByb21pc2VzID0gW107XG4gICAgICAgIHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlc1tjbHVzdGVyTmFtZV0gPSBjbHVzdGVyUHJvbWlzZXM7XG4gICAgICB9XG5cbiAgICAgIGNsdXN0ZXJQcm9taXNlcy5wdXNoKHtcbiAgICAgICAgcHJvbWlzZTogc2RrLmVjcygpLnVwZGF0ZVNlcnZpY2Uoe1xuICAgICAgICAgIHNlcnZpY2U6IGVjc1NlcnZpY2Uuc2VydmljZUFybixcbiAgICAgICAgICB0YXNrRGVmaW5pdGlvbjogdGFza0RlZlJldkFybixcbiAgICAgICAgICBjbHVzdGVyOiBjbHVzdGVyTmFtZSxcbiAgICAgICAgICBmb3JjZU5ld0RlcGxveW1lbnQ6IHRydWUsXG4gICAgICAgICAgZGVwbG95bWVudENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIG1pbmltdW1IZWFsdGh5UGVyY2VudDogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KS5wcm9taXNlKCksXG4gICAgICAgIGVjc1NlcnZpY2U6IGVjc1NlcnZpY2UsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyhzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXMpXG4gICAgICAubWFwKGNsdXN0ZXJVcGRhdGVzID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNsdXN0ZXJVcGRhdGVzLm1hcChzZXJ2aWNlVXBkYXRlID0+IHNlcnZpY2VVcGRhdGUucHJvbWlzZSkpO1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIC8vIFN0ZXAgMyAtIHdhaXQgZm9yIHRoZSBzZXJ2aWNlIGRlcGxveW1lbnRzIHRyaWdnZXJlZCBpbiBTdGVwIDIgdG8gZmluaXNoXG4gICAgLy8gY29uZmlndXJlIGEgY3VzdG9tIFdhaXRlclxuICAgIChzZGsuZWNzKCkgYXMgYW55KS5hcGkud2FpdGVycy5kZXBsb3ltZW50VG9GaW5pc2ggPSB7XG4gICAgICBuYW1lOiAnRGVwbG95bWVudFRvRmluaXNoJyxcbiAgICAgIG9wZXJhdGlvbjogJ2Rlc2NyaWJlU2VydmljZXMnLFxuICAgICAgZGVsYXk6IDEwLFxuICAgICAgbWF4QXR0ZW1wdHM6IDYwLFxuICAgICAgYWNjZXB0b3JzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgYXJndW1lbnQ6ICdmYWlsdXJlc1tdLnJlYXNvbicsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdNSVNTSU5HJyxcbiAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgIGFyZ3VtZW50OiAnc2VydmljZXNbXS5zdGF0dXMnLFxuICAgICAgICAgIGV4cGVjdGVkOiAnRFJBSU5JTkcnLFxuICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgYXJndW1lbnQ6ICdzZXJ2aWNlc1tdLnN0YXR1cycsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdJTkFDVElWRScsXG4gICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgICBhcmd1bWVudDogXCJsZW5ndGgoc2VydmljZXNbXS5kZXBsb3ltZW50c1s/IHN0YXR1cyA9PSAnUFJJTUFSWScgJiYgcnVubmluZ0NvdW50IDwgZGVzaXJlZENvdW50XVtdKSA9PSBgMGBcIixcbiAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgICBzdGF0ZTogJ3N1Y2Nlc3MnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICAgIC8vIGNyZWF0ZSBhIGN1c3RvbSBXYWl0ZXIgdGhhdCB1c2VzIHRoZSBkZXBsb3ltZW50VG9GaW5pc2ggY29uZmlndXJhdGlvbiBhZGRlZCBhYm92ZVxuICAgIGNvbnN0IGRlcGxveW1lbnRXYWl0ZXIgPSBuZXcgKEFXUyBhcyBhbnkpLlJlc291cmNlV2FpdGVyKHNkay5lY3MoKSwgJ2RlcGxveW1lbnRUb0ZpbmlzaCcpO1xuICAgIC8vIHdhaXQgZm9yIGFsbCBvZiB0aGUgd2FpdGVycyB0byBmaW5pc2hcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzKS5tYXAoKFtjbHVzdGVyTmFtZSwgc2VydmljZVVwZGF0ZXNdKSA9PiB7XG4gICAgICByZXR1cm4gZGVwbG95bWVudFdhaXRlci53YWl0KHtcbiAgICAgICAgY2x1c3RlcjogY2x1c3Rlck5hbWUsXG4gICAgICAgIHNlcnZpY2VzOiBzZXJ2aWNlVXBkYXRlcy5tYXAoc2VydmljZVVwZGF0ZSA9PiBzZXJ2aWNlVXBkYXRlLmVjc1NlcnZpY2Uuc2VydmljZUFybiksXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgfSkpO1xuICB9XG59XG4iXX0=