"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const AWS = __importStar(require("aws-sdk"));
AWS.config.logger = console;
const util_1 = require("./util");
const cfnResponse = __importStar(require("./cfn-response"));
const lambda = new AWS.Lambda({ region: "us-east-1" });
const LIVE_ALIAS = "live";
function handler(cfnRequest) {
    return __awaiter(this, void 0, void 0, function* () {
        util_1.log("onEventHandler", cfnRequest);
        // Process request
        let PhysicalResourceId;
        let Data;
        const functionArn = cfnRequest.ResourceProperties.FunctionArn;
        const functionName = functionArn.split(":").pop();
        switch (cfnRequest.RequestType) {
            case "Create": {
                const ret = yield createVersion(functionName);
                const version = ret.Version;
                yield createAlias(functionName, version);
                PhysicalResourceId = `${functionArn}:${version}`;
                Data = { Version: version };
                break;
            }
            case "Update": {
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                Data = { Version: cfnRequest.PhysicalResourceId.split(":").pop() };
                break;
            }
            case "Delete": {
                yield deleteOldVersions(functionName);
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                break;
            }
            default:
                throw new Error("Unsupported request type");
        }
        // Build response
        return cfnResponse.submitResponse("SUCCESS", Object.assign(Object.assign({}, cfnRequest), { PhysicalResourceId,
            Data }));
    });
}
function createVersion(functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        util_1.log(`createVersion() called with functionName`, functionName);
        const resp = yield lambda
            .publishVersion({
            FunctionName: functionName,
        })
            .promise();
        util_1.log(`response`, resp);
        return { Version: resp.Version };
    });
}
function createAlias(functionName, version) {
    return __awaiter(this, void 0, void 0, function* () {
        util_1.log(`createAlias() called with functionName`, functionName, "version", version);
        let resp;
        // Update alias
        try {
            util_1.log("updateAlias");
            resp = yield lambda
                .updateAlias({
                Name: LIVE_ALIAS,
                FunctionName: functionName,
                FunctionVersion: version,
            })
                .promise();
            util_1.log("response", resp);
        }
        catch (e) {
            // If alias has not be created, create the alias
            if (e.code === "ResourceNotFoundException" &&
                e.message.startsWith("Alias not found")) {
                util_1.log("updateAlias");
                resp = yield lambda
                    .createAlias({
                    Name: LIVE_ALIAS,
                    FunctionName: functionName,
                    FunctionVersion: version,
                })
                    .promise();
                util_1.log("response", resp);
                return;
            }
            throw e;
        }
    });
}
function deleteOldVersions(functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        util_1.log(`deleteOldVersions() called with functionName`, functionName);
        let resp;
        try {
            // Get LIVE_ALIAS version
            resp = yield lambda
                .getAlias({
                FunctionName: functionName,
                Name: LIVE_ALIAS,
            })
                .promise();
            util_1.log(`getAlias`, resp);
            const liveVersion = resp.FunctionVersion;
            // Get all versions
            resp = yield lambda
                .listVersionsByFunction({
                FunctionName: functionName,
                MaxItems: 50,
            })
                .promise();
            util_1.log(`listVersionsByFunction`, resp);
            const versionObjs = resp.Versions || [];
            // Remove non LIVE_ALIAS versions
            for (let i = 0, l = versionObjs.length; i < l; i++) {
                const version = versionObjs[i].Version;
                if (version === liveVersion) {
                    util_1.log("deleteVersion", version, "skipped");
                    continue;
                }
                try {
                    util_1.log("deleteVersion", version, "do");
                    resp = yield lambda
                        .deleteFunction({
                        FunctionName: functionName,
                        Qualifier: version,
                    })
                        .promise();
                    util_1.log("response", resp);
                }
                catch (e) {
                    // Supress error because a version can fail to remove if still in use.
                    util_1.log(`deleteVersion error`, e);
                }
            }
        }
        catch (e) {
            // Supress error because it is fine if a specific version fails to remove.
            // All versions will be removed upon removing the function.
            util_1.log(`deleteOldVersions error`, e);
        }
    });
}
module.exports = {
    handler: cfnResponse.safeHandler(handler),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRnZS1sYW1iZGEtdmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9uZXh0anMtc2l0ZS9jdXN0b20tcmVzb3VyY2UvZWRnZS1sYW1iZGEtdmVyc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQixHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFFNUIsaUNBQTZCO0FBQzdCLDREQUE4QztBQUM5QyxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUN2RCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUM7QUFNMUIsU0FBZSxPQUFPLENBQ3BCLFVBQXVEOztRQUV2RCxVQUFHLENBQUMsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFbEMsa0JBQWtCO1FBQ2xCLElBQUksa0JBQWtCLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUM7UUFDVCxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDO1FBQzlELE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDbEQsUUFBUSxVQUFVLENBQUMsV0FBVyxFQUFFO1lBQzlCLEtBQUssUUFBUSxDQUFDLENBQUM7Z0JBQ2IsTUFBTSxHQUFHLEdBQUcsTUFBTSxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQzlDLE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxPQUFpQixDQUFDO2dCQUN0QyxNQUFNLFdBQVcsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ3pDLGtCQUFrQixHQUFHLEdBQUcsV0FBVyxJQUFJLE9BQU8sRUFBRSxDQUFDO2dCQUNqRCxJQUFJLEdB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WUFDViwwRUFBMEU7WUFDMUUsMkRBQTJEO1lBQzNELFVBQUcsQ0FBQyx5QkFBeUIsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNuQztJQUNILENBQUM7Q0FBQTtBQTNKRCxpQkFBUztJQUNQLE9BQU8sRUFBRSxXQUFXLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztDQUMxQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gXCJhd3Mtc2RrXCI7XG5BV1MuY29uZmlnLmxvZ2dlciA9IGNvbnNvbGU7XG5cbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCAqIGFzIGNmblJlc3BvbnNlIGZyb20gXCIuL2Nmbi1yZXNwb25zZVwiO1xuY29uc3QgbGFtYmRhID0gbmV3IEFXUy5MYW1iZGEoeyByZWdpb246IFwidXMtZWFzdC0xXCIgfSk7XG5jb25zdCBMSVZFX0FMSUFTID0gXCJsaXZlXCI7XG5cbmV4cG9ydCA9IHtcbiAgaGFuZGxlcjogY2ZuUmVzcG9uc2Uuc2FmZUhhbmRsZXIoaGFuZGxlciksXG59O1xuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxuICBjZm5SZXF1ZXN0OiBBV1NMYW1iZGEuQ2xvdWRGb3JtYXRpb25DdXN0b21SZXNvdXJjZUV2ZW50XG4pIHtcbiAgbG9nKFwib25FdmVudEhhbmRsZXJcIiwgY2ZuUmVxdWVzdCk7XG5cbiAgLy8gUHJvY2VzcyByZXF1ZXN0XG4gIGxldCBQaHlzaWNhbFJlc291cmNlSWQ7XG4gIGxldCBEYXRhO1xuICBjb25zdCBmdW5jdGlvbkFybiA9IGNmblJlcXVlc3QuUmVzb3VyY2VQcm9wZXJ0aWVzLkZ1bmN0aW9uQXJuO1xuICBjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkFybi5zcGxpdChcIjpcIikucG9wKCk7XG4gIHN3aXRjaCAoY2ZuUmVxdWVzdC5SZXF1ZXN0VHlwZSkge1xuICAgIGNhc2UgXCJDcmVhdGVcIjoge1xuICAgICAgY29uc3QgcmV0ID0gYXdhaXQgY3JlYXRlVmVyc2lvbihmdW5jdGlvbk5hbWUpO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHJldC5WZXJzaW9uIGFzIHN0cmluZztcbiAgICAgIGF3YWl0IGNyZWF0ZUFsaWFzKGZ1bmN0aW9uTmFtZSwgdmVyc2lvbik7XG4gICAgICBQaHlzaWNhbFJlc291cmNlSWQgPSBgJHtmdW5jdGlvbkFybn06JHt2ZXJzaW9ufWA7XG4gICAgICBEYXRhID0geyBWZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIlVwZGF0ZVwiOiB7XG4gICAgICBQaHlzaWNhbFJlc291cmNlSWQgPSBjZm5SZXF1ZXN0LlBoeXNpY2FsUmVzb3VyY2VJZDtcbiAgICAgIERhdGEgPSB7IFZlcnNpb246IGNmblJlcXVlc3QuUGh5c2ljYWxSZXNvdXJjZUlkLnNwbGl0KFwiOlwiKS5wb3AoKSB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJEZWxldGVcIjoge1xuICAgICAgYXdhaXQgZGVsZXRlT2xkVmVyc2lvbnMoZnVuY3Rpb25OYW1lKTtcbiAgICAgIFBoeXNpY2FsUmVzb3VyY2VJZCA9IGNmblJlcXVlc3QuUGh5c2ljYWxSZXNvdXJjZUlkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCByZXF1ZXN0IHR5cGVcIik7XG4gIH1cblxuICAvLyBCdWlsZCByZXNwb25zZVxuICByZXR1cm4gY2ZuUmVzcG9uc2Uuc3VibWl0UmVzcG9uc2UoXCJTVUNDRVNTXCIsIHtcbiAgICAuLi5jZm5SZXF1ZXN0LFxuICAgIFBoeXNpY2FsUmVzb3VyY2VJZCxcbiAgICBEYXRhLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmVyc2lvbihmdW5jdGlvbk5hbWU6IHN0cmluZykge1xuICBsb2coYGNyZWF0ZVZlcnNpb24oKSBjYWxsZWQgd2l0aCBmdW5jdGlvbk5hbWVgLCBmdW5jdGlvbk5hbWUpO1xuXG4gIGNvbnN0IHJlc3AgPSBhd2FpdCBsYW1iZGFcbiAgICAucHVibGlzaFZlcnNpb24oe1xuICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgfSlcbiAgICAucHJvbWlzZSgpO1xuXG4gIGxvZyhgcmVzcG9uc2VgLCByZXNwKTtcblxuICByZXR1cm4geyBWZXJzaW9uOiByZXNwLlZlcnNpb24gfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWxpYXMoZnVuY3Rpb25OYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICBsb2coXG4gICAgYGNyZWF0ZUFsaWFzKCkgY2FsbGVkIHdpdGggZnVuY3Rpb25OYW1lYCxcbiAgICBmdW5jdGlvbk5hbWUsXG4gICAgXCJ2ZXJzaW9uXCIsXG4gICAgdmVyc2lvblxuICApO1xuXG4gIGxldCByZXNwO1xuXG4gIC8vIFVwZGF0ZSBhbGlhc1xuICB0cnkge1xuICAgIGxvZyhcInVwZGF0ZUFsaWFzXCIpO1xuICAgIHJlc3AgPSBhd2FpdCBsYW1iZGFcbiAgICAgIC51cGRhdGVBbGlhcyh7XG4gICAgICAgIE5hbWU6IExJVkVfQUxJQVMsXG4gICAgICAgIEZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICBGdW5jdGlvblZlcnNpb246IHZlcnNpb24sXG4gICAgICB9KVxuICAgICAgLnByb21pc2UoKTtcblxuICAgIGxvZyhcInJlc3BvbnNlXCIsIHJlc3ApO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAvLyBJZiBhbGlhcyBoYXMgbm90IGJlIGNyZWF0ZWQsIGNyZWF0ZSB0aGUgYWxpYXNcbiAgICBpZiAoXG4gICAgICBlLmNvZGUgPT09IFwiUmVzb3VyY2VOb3RGb3VuZEV4Y2VwdGlvblwiICYmXG4gICAgICBlLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFsaWFzIG5vdCBmb3VuZFwiKVxuICAgICkge1xuICAgICAgbG9nKFwidXBkYXRlQWxpYXNcIik7XG4gICAgICByZXNwID0gYXdhaXQgbGFtYmRhXG4gICAgICAgIC5jcmVhdGVBbGlhcyh7XG4gICAgICAgICAgTmFtZTogTElWRV9BTElBUyxcbiAgICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICBGdW5jdGlvblZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIH0pXG4gICAgICAgIC5wcm9taXNlKCk7XG5cbiAgICAgIGxvZyhcInJlc3BvbnNlXCIsIHJlc3ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU9sZFZlcnNpb25zKGZ1bmN0aW9uTmFtZTogc3RyaW5nKSB7XG4gIGxvZyhgZGVsZXRlT2xkVmVyc2lvbnMoKSBjYWxsZWQgd2l0aCBmdW5jdGlvbk5hbWVgLCBmdW5jdGlvbk5hbWUpO1xuXG4gIGxldCByZXNwO1xuICB0cnkge1xuICAgIC8vIEdldCBMSVZFX0FMSUFTIHZlcnNpb25cbiAgICByZXNwID0gYXdhaXQgbGFtYmRhXG4gICAgICAuZ2V0QWxpYXMoe1xuICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgTmFtZTogTElWRV9BTElBUyxcbiAgICAgIH0pXG4gICAgICAucHJvbWlzZSgpO1xuICAgIGxvZyhgZ2V0QWxpYXNgLCByZXNwKTtcbiAgICBjb25zdCBsaXZlVmVyc2lvbiA9IHJlc3AuRnVuY3Rpb25WZXJzaW9uO1xuXG4gICAgLy8gR2V0IGFsbCB2ZXJzaW9uc1xuICAgIHJlc3AgPSBhd2FpdCBsYW1iZGFcbiAgICAgIC5saXN0VmVyc2lvbnNCeUZ1bmN0aW9uKHtcbiAgICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgIE1heEl0ZW1zOiA1MCxcbiAgICAgIH0pXG4gICAgICAucHJvbWlzZSgpO1xuICAgIGxvZyhgbGlzdFZlcnNpb25zQnlGdW5jdGlvbmAsIHJlc3ApO1xuICAgIGNvbnN0IHZlcnNpb25PYmpzID0gcmVzcC5WZXJzaW9ucyB8fCBbXTtcblxuICAgIC8vIFJlbW92ZSBub24gTElWRV9BTElBUyB2ZXJzaW9uc1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmVyc2lvbk9ianMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbk9ianNbaV0uVmVyc2lvbjtcbiAgICAgIGlmICh2ZXJzaW9uID09PSBsaXZlVmVyc2lvbikge1xuICAgICAgICBsb2coXCJkZWxldGVWZXJzaW9uXCIsIHZlcnNpb24sIFwic2tpcHBlZFwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZyhcImRlbGV0ZVZlcnNpb25cIiwgdmVyc2lvbiwgXCJkb1wiKTtcbiAgICAgICAgcmVzcCA9IGF3YWl0IGxhbWJkYVxuICAgICAgICAgIC5kZWxldGVGdW5jdGlvbih7XG4gICAgICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIFF1YWxpZmllcjogdmVyc2lvbixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5wcm9taXNlKCk7XG4gICAgICAgIGxvZyhcInJlc3BvbnNlXCIsIHJlc3ApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTdXByZXNzIGVycm9yIGJlY2F1c2UgYSB2ZXJzaW9uIGNhbiBmYWlsIHRvIHJlbW92ZSBpZiBzdGlsbCBpbiB1c2UuXG4gICAgICAgIGxvZyhgZGVsZXRlVmVyc2lvbiBlcnJvcmAsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFN1cHJlc3MgZXJyb3IgYmVjYXVzZSBpdCBpcyBmaW5lIGlmIGEgc3BlY2lmaWMgdmVyc2lvbiBmYWlscyB0byByZW1vdmUuXG4gICAgLy8gQWxsIHZlcnNpb25zIHdpbGwgYmUgcmVtb3ZlZCB1cG9uIHJlbW92aW5nIHRoZSBmdW5jdGlvbi5cbiAgICBsb2coYGRlbGV0ZU9sZFZlcnNpb25zIGVycm9yYCwgZSk7XG4gIH1cbn1cbiJdfQ==