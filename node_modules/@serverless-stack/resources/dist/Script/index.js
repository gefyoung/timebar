"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const cfnResponse = __importStar(require("./cfn-response"));
const outbound_1 = require("./outbound");
const util_1 = require("./util");
function handler(cfnRequest) {
    return __awaiter(this, void 0, void 0, function* () {
        util_1.log("onEventHandler", cfnRequest);
        // Invoke user function on Create and on Update
        const fnCreate = cfnRequest.ResourceProperties.UserCreateFunction;
        const fnUpdate = cfnRequest.ResourceProperties.UserUpdateFunction;
        const fnDelete = cfnRequest.ResourceProperties.UserDeleteFunction;
        const fnParams = JSON.parse(cfnRequest.ResourceProperties.UserParams);
        if (cfnRequest.RequestType === "Create" && fnCreate) {
            yield invokeUserFunction(fnCreate, { params: fnParams });
        }
        else if (cfnRequest.RequestType === "Update" && fnUpdate) {
            yield invokeUserFunction(fnUpdate, { params: fnParams });
        }
        else if (cfnRequest.RequestType === "Delete" && fnDelete) {
            yield invokeUserFunction(fnDelete, { params: fnParams });
        }
        // Build response
        return cfnResponse.submitResponse("SUCCESS", Object.assign(Object.assign({}, cfnRequest), { PhysicalResourceId: defaultPhysicalResourceId(cfnRequest) }));
    });
}
function invokeUserFunction(functionName, payload) {
    return __awaiter(this, void 0, void 0, function* () {
        util_1.log(`executing user function ${functionName} with payload`, payload);
        const resp = yield outbound_1.invokeFunction({
            FunctionName: functionName,
            Payload: JSON.stringify(payload),
        });
        util_1.log("user function response:", resp, typeof resp);
        if (resp.FunctionError) {
            util_1.log("user function threw an error:", resp.FunctionError);
            const jsonPayload = parseJsonPayload(resp.Payload);
            // Note: custom resources have a response limit of 4k. Limit the
            //       error message to 1000 characters.
            const errorMessage = (jsonPayload.errorMessage || "error").substring(0, 1000);
            // append a reference to the log group.
            const message = [
                errorMessage,
                "",
                `Logs: /aws/lambda/${functionName}`,
                "",
            ].join("\n");
            const e = new Error(message);
            // the output that goes to CFN is what's in `stack`, not the error message.
            // if we have a remote trace, construct a nice message with log group information
            if (jsonPayload.trace) {
                // skip first trace line because it's the message
                e.stack = [message, ...jsonPayload.trace.slice(1)].join("\n");
            }
            throw e;
        }
    });
}
function parseJsonPayload(payload) {
    if (!payload) {
        return {};
    }
    const text = payload.toString();
    try {
        return JSON.parse(text);
    }
    catch (e) {
        throw new Error(`return values from user-handlers must be JSON objects. got: "${text}"`);
    }
}
function defaultPhysicalResourceId(req) {
    switch (req.RequestType) {
        case "Create":
            return req.RequestId;
        case "Update":
        case "Delete":
            return req.PhysicalResourceId;
        default:
            throw new Error(`Invalid "RequestType" in request "${JSON.stringify(req)}"`);
    }
}
module.exports = {
    handler: cfnResponse.safeHandler(handler),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvU2NyaXB0L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNERBQThDO0FBQzlDLHlDQUE0QztBQUM1QyxpQ0FBNkI7QUFNN0IsU0FBZSxPQUFPLENBQ3BCLFVBQXVEOztRQUV2RCxVQUFHLENBQUMsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFbEMsK0NBQStDO1FBQy9DLE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBa0IsQ0FBQztRQUNsRSxNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLENBQUM7UUFDbEUsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDO1FBQ2xFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3RFLElBQUksVUFBVSxDQUFDLFdBQVcsS0FBSyxRQUFRLElBQUksUUFBUSxFQUFFO1lBQ25ELE1BQU0sa0JBQWtCLENBQUMsUUFBUSxFQUFFLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDMUQ7YUFBTSxJQUFJLFVBQVUsQ0FBQyxXQUFXLEtBQUssUUFBUSxJQUFJLFFBQVEsRUFBRTtZQUMxRCxNQUFNLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQzFEO2FBQU0sSUFBSSxVQUFVLENBQUMsV0FBVyxLQUFLLFFBQVEsSUFBSSxRQUFRLEVBQUU7WUFDMUQsTUFBTSxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztTQUMxRDtRQUVELGlCQUFpQjtRQUNqQixPQUFPLFdBQVcsQ0FBQyxjQUFjLENBQUMsU0FBUyxrQ0FDdEMsVUFBVSxLQUNiLGtCQUFrQixFQUFFLHlCQUF5QixDQUFDLFVBQVUsQ0FBQyxJQUN6RCxDQUFDO0lBQ0wsQ0FBQztDQUFBO0FBRUQsU0FBZSxrQkFBa0IsQ0FBQyxZQUFvQixFQUFFLE9BQVk7O1FBQ2xFLFVBQUcsQ0FBQywyQkFBMkIsWUFBWSxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFckUsTUFBTSxJQUFJLEdBQUcsTUFBTSx5QkFBYyxDQUFDO1lBQ2hDLFlBQVksRUFBRSxZQUFZO1lBQzFCLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQztTQUNqQyxDQUFDLENBQUM7UUFFSCxVQUFHLENBQUMseUJBQXlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7UUFFbEQsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RCLFVBQUcsQ0FBQywrQkFBK0IsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFekQsTUFBTSxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRW5ELGdFQUFnRTtZQUNoRSwwQ0FBMEM7WUFDMUMsTUFBTSxZQUFZLEdBQUcsQ0FBQyxXQUFXLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FDbEUsQ0FBQyxFQUNELElBQUksQ0FDTCxDQUFDO1lBRUYsdUNBQXVDO1lBQ3ZDLE1BQU0sT0FBTyxHQUFHO2dCQUNkLFlBQVk7Z0JBQ1osRUFBRTtnQkFDRixxQkFBcUIsWUFBWSxFQUFFO2dCQUNuQyxFQUFFO2FBQ0gsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixNQUFNLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUU3QiwyRUFBMkU7WUFDM0UsaUZBQWlGO1lBQ2pGLElBQUksV0FBVyxDQUFDLEtBQUssRUFBRTtnQkFDckIsaURBQWlEO2dCQUNqRCxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsT0FBTyxFQUFFLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDL0Q7WUFFRCxNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztDQUFBO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxPQUFZO0lBQ3BDLElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDWixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBQ0QsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ2hDLElBQUk7UUFDRixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDekI7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQ2IsZ0VBQWdFLElBQUksR0FBRyxDQUN4RSxDQUFDO0tBQ0g7QUFDSCxDQUFDO0FBRUQsU0FBUyx5QkFBeUIsQ0FDaEMsR0FBZ0Q7SUFFaEQsUUFBUSxHQUFHLENBQUMsV0FBVyxFQUFFO1FBQ3ZCLEtBQUssUUFBUTtZQUNYLE9BQU8sR0FBRyxDQUFDLFNBQVMsQ0FBQztRQUV2QixLQUFLLFFBQVEsQ0FBQztRQUNkLEtBQUssUUFBUTtZQUNYLE9BQU8sR0FBRyxDQUFDLGtCQUFrQixDQUFDO1FBRWhDO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FDYixxQ0FBcUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUM1RCxDQUFDO0tBQ0w7QUFDSCxDQUFDO0FBdEdELGlCQUFTO0lBQ1AsT0FBTyxFQUFFLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDO0NBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5SZXNwb25zZSBmcm9tIFwiLi9jZm4tcmVzcG9uc2VcIjtcbmltcG9ydCB7IGludm9rZUZ1bmN0aW9uIH0gZnJvbSBcIi4vb3V0Ym91bmRcIjtcbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0ID0ge1xuICBoYW5kbGVyOiBjZm5SZXNwb25zZS5zYWZlSGFuZGxlcihoYW5kbGVyKSxcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXG4gIGNmblJlcXVlc3Q6IEFXU0xhbWJkYS5DbG91ZEZvcm1hdGlvbkN1c3RvbVJlc291cmNlRXZlbnRcbikge1xuICBsb2coXCJvbkV2ZW50SGFuZGxlclwiLCBjZm5SZXF1ZXN0KTtcblxuICAvLyBJbnZva2UgdXNlciBmdW5jdGlvbiBvbiBDcmVhdGUgYW5kIG9uIFVwZGF0ZVxuICBjb25zdCBmbkNyZWF0ZSA9IGNmblJlcXVlc3QuUmVzb3VyY2VQcm9wZXJ0aWVzLlVzZXJDcmVhdGVGdW5jdGlvbjtcbiAgY29uc3QgZm5VcGRhdGUgPSBjZm5SZXF1ZXN0LlJlc291cmNlUHJvcGVydGllcy5Vc2VyVXBkYXRlRnVuY3Rpb247XG4gIGNvbnN0IGZuRGVsZXRlID0gY2ZuUmVxdWVzdC5SZXNvdXJjZVByb3BlcnRpZXMuVXNlckRlbGV0ZUZ1bmN0aW9uO1xuICBjb25zdCBmblBhcmFtcyA9IEpTT04ucGFyc2UoY2ZuUmVxdWVzdC5SZXNvdXJjZVByb3BlcnRpZXMuVXNlclBhcmFtcyk7XG4gIGlmIChjZm5SZXF1ZXN0LlJlcXVlc3RUeXBlID09PSBcIkNyZWF0ZVwiICYmIGZuQ3JlYXRlKSB7XG4gICAgYXdhaXQgaW52b2tlVXNlckZ1bmN0aW9uKGZuQ3JlYXRlLCB7IHBhcmFtczogZm5QYXJhbXMgfSk7XG4gIH0gZWxzZSBpZiAoY2ZuUmVxdWVzdC5SZXF1ZXN0VHlwZSA9PT0gXCJVcGRhdGVcIiAmJiBmblVwZGF0ZSkge1xuICAgIGF3YWl0IGludm9rZVVzZXJGdW5jdGlvbihmblVwZGF0ZSwgeyBwYXJhbXM6IGZuUGFyYW1zIH0pO1xuICB9IGVsc2UgaWYgKGNmblJlcXVlc3QuUmVxdWVzdFR5cGUgPT09IFwiRGVsZXRlXCIgJiYgZm5EZWxldGUpIHtcbiAgICBhd2FpdCBpbnZva2VVc2VyRnVuY3Rpb24oZm5EZWxldGUsIHsgcGFyYW1zOiBmblBhcmFtcyB9KTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHJlc3BvbnNlXG4gIHJldHVybiBjZm5SZXNwb25zZS5zdWJtaXRSZXNwb25zZShcIlNVQ0NFU1NcIiwge1xuICAgIC4uLmNmblJlcXVlc3QsXG4gICAgUGh5c2ljYWxSZXNvdXJjZUlkOiBkZWZhdWx0UGh5c2ljYWxSZXNvdXJjZUlkKGNmblJlcXVlc3QpLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW52b2tlVXNlckZ1bmN0aW9uKGZ1bmN0aW9uTmFtZTogc3RyaW5nLCBwYXlsb2FkOiBhbnkpIHtcbiAgbG9nKGBleGVjdXRpbmcgdXNlciBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gd2l0aCBwYXlsb2FkYCwgcGF5bG9hZCk7XG5cbiAgY29uc3QgcmVzcCA9IGF3YWl0IGludm9rZUZ1bmN0aW9uKHtcbiAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICBQYXlsb2FkOiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgfSk7XG5cbiAgbG9nKFwidXNlciBmdW5jdGlvbiByZXNwb25zZTpcIiwgcmVzcCwgdHlwZW9mIHJlc3ApO1xuXG4gIGlmIChyZXNwLkZ1bmN0aW9uRXJyb3IpIHtcbiAgICBsb2coXCJ1c2VyIGZ1bmN0aW9uIHRocmV3IGFuIGVycm9yOlwiLCByZXNwLkZ1bmN0aW9uRXJyb3IpO1xuXG4gICAgY29uc3QganNvblBheWxvYWQgPSBwYXJzZUpzb25QYXlsb2FkKHJlc3AuUGF5bG9hZCk7XG5cbiAgICAvLyBOb3RlOiBjdXN0b20gcmVzb3VyY2VzIGhhdmUgYSByZXNwb25zZSBsaW1pdCBvZiA0ay4gTGltaXQgdGhlXG4gICAgLy8gICAgICAgZXJyb3IgbWVzc2FnZSB0byAxMDAwIGNoYXJhY3RlcnMuXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKGpzb25QYXlsb2FkLmVycm9yTWVzc2FnZSB8fCBcImVycm9yXCIpLnN1YnN0cmluZyhcbiAgICAgIDAsXG4gICAgICAxMDAwXG4gICAgKTtcblxuICAgIC8vIGFwcGVuZCBhIHJlZmVyZW5jZSB0byB0aGUgbG9nIGdyb3VwLlxuICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICBcIlwiLFxuICAgICAgYExvZ3M6IC9hd3MvbGFtYmRhLyR7ZnVuY3Rpb25OYW1lfWAsIC8vIGNsb3Vkd2F0Y2ggbG9nIGdyb3VwXG4gICAgICBcIlwiLFxuICAgIF0uam9pbihcIlxcblwiKTtcblxuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cbiAgICAvLyB0aGUgb3V0cHV0IHRoYXQgZ29lcyB0byBDRk4gaXMgd2hhdCdzIGluIGBzdGFja2AsIG5vdCB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgcmVtb3RlIHRyYWNlLCBjb25zdHJ1Y3QgYSBuaWNlIG1lc3NhZ2Ugd2l0aCBsb2cgZ3JvdXAgaW5mb3JtYXRpb25cbiAgICBpZiAoanNvblBheWxvYWQudHJhY2UpIHtcbiAgICAgIC8vIHNraXAgZmlyc3QgdHJhY2UgbGluZSBiZWNhdXNlIGl0J3MgdGhlIG1lc3NhZ2VcbiAgICAgIGUuc3RhY2sgPSBbbWVzc2FnZSwgLi4uanNvblBheWxvYWQudHJhY2Uuc2xpY2UoMSldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUpzb25QYXlsb2FkKHBheWxvYWQ6IGFueSk6IGFueSB7XG4gIGlmICghcGF5bG9hZCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCB0ZXh0ID0gcGF5bG9hZC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHJldHVybiB2YWx1ZXMgZnJvbSB1c2VyLWhhbmRsZXJzIG11c3QgYmUgSlNPTiBvYmplY3RzLiBnb3Q6IFwiJHt0ZXh0fVwiYFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBoeXNpY2FsUmVzb3VyY2VJZChcbiAgcmVxOiBBV1NMYW1iZGEuQ2xvdWRGb3JtYXRpb25DdXN0b21SZXNvdXJjZUV2ZW50XG4pOiBzdHJpbmcge1xuICBzd2l0Y2ggKHJlcS5SZXF1ZXN0VHlwZSkge1xuICAgIGNhc2UgXCJDcmVhdGVcIjpcbiAgICAgIHJldHVybiByZXEuUmVxdWVzdElkO1xuXG4gICAgY2FzZSBcIlVwZGF0ZVwiOlxuICAgIGNhc2UgXCJEZWxldGVcIjpcbiAgICAgIHJldHVybiByZXEuUGh5c2ljYWxSZXNvdXJjZUlkO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgXCJSZXF1ZXN0VHlwZVwiIGluIHJlcXVlc3QgXCIke0pTT04uc3RyaW5naWZ5KHJlcSl9XCJgXG4gICAgICApO1xuICB9XG59XG4iXX0=