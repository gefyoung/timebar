"use strict";
/* eslint-disable @typescript-eslint/ban-types */
// Note: disabling ban-type rule so we don't get an error referencing the class Function
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Function = void 0;
const path_1 = __importDefault(require("path"));
const fs = __importStar(require("fs-extra"));
const cdk = __importStar(require("aws-cdk-lib"));
const iam = __importStar(require("aws-cdk-lib/aws-iam"));
const lambda = __importStar(require("aws-cdk-lib/aws-lambda"));
const ssm = __importStar(require("aws-cdk-lib/aws-ssm"));
const crypto_1 = __importDefault(require("crypto"));
const Stack_1 = require("./Stack");
const permission_1 = require("./util/permission");
const core_1 = require("@serverless-stack/core");
const core_2 = require("@serverless-stack/core");
const supportedRuntimes = [
    lambda.Runtime.NODEJS,
    lambda.Runtime.NODEJS_4_3,
    lambda.Runtime.NODEJS_6_10,
    lambda.Runtime.NODEJS_8_10,
    lambda.Runtime.NODEJS_10_X,
    lambda.Runtime.NODEJS_12_X,
    lambda.Runtime.NODEJS_14_X,
    lambda.Runtime.PYTHON_2_7,
    lambda.Runtime.PYTHON_3_6,
    lambda.Runtime.PYTHON_3_7,
    lambda.Runtime.PYTHON_3_8,
    lambda.Runtime.PYTHON_3_9,
    lambda.Runtime.DOTNET_CORE_1,
    lambda.Runtime.DOTNET_CORE_2,
    lambda.Runtime.DOTNET_CORE_2_1,
    lambda.Runtime.DOTNET_CORE_3_1,
    lambda.Runtime.GO_1_X,
];
class Function extends lambda.Function {
    constructor(scope, id, props) {
        const root = scope.node.root;
        const stack = Stack_1.Stack.of(scope);
        // Merge with app defaultFunctionProps
        // note: reverse order so later prop override earlier ones
        stack.defaultFunctionProps
            .slice()
            .reverse()
            .forEach((per) => {
            props = Function.mergeProps(per, props);
        });
        // Set defaults
        const functionName = props.functionName &&
            (typeof props.functionName === "string"
                ? props.functionName
                : props.functionName({ stack, functionProps: props }));
        const handler = props.handler;
        let timeout = props.timeout || 10;
        const srcPath = Function.normalizeSrcPath(props.srcPath || ".");
        const memorySize = props.memorySize || 1024;
        const tracing = props.tracing || lambda.Tracing.ACTIVE;
        let runtime = props.runtime || lambda.Runtime.NODEJS_12_X;
        let bundle = props.bundle;
        const permissions = props.permissions;
        const isLiveDevEnabled = props.enableLiveDev === false ? false : true;
        // Validate handler
        if (!handler) {
            throw new Error(`No handler defined for the "${id}" Lambda function`);
        }
        // Normalize runtime
        const runtimeStr = typeof runtime === "string" ? runtime : runtime.toString();
        const runtimeClass = supportedRuntimes.find((per) => per.toString() === runtimeStr);
        if (!runtimeClass) {
            throw new Error(`The specified runtime is not supported for sst.Function. Only NodeJS, Python, Go, and .NET runtimes are currently supported.`);
        }
        runtime = runtimeClass;
        // Normalize timeout
        if (typeof timeout === "number") {
            timeout = cdk.Duration.seconds(timeout);
        }
        // Validate input
        const isNodeRuntime = runtimeStr.startsWith("nodejs");
        const isPythonRuntime = runtimeStr.startsWith("python");
        if (isNodeRuntime) {
            bundle = bundle === undefined ? true : props.bundle;
            if (!bundle && srcPath === ".") {
                throw new Error(`Bundle cannot be disabled for the "${id}" function since the "srcPath" is set to the project root. Read more here â€” https://github.com/serverless-stack/serverless-stack/issues/78`);
            }
        }
        else if (isPythonRuntime) {
            bundle = bundle === undefined ? {} : props.bundle;
            if (srcPath === ".") {
                throw new Error(`Cannot set the "srcPath" to the project root for the "${id}" function.`);
            }
        }
        const localId = crypto_1.default
            .createHash("sha1")
            .update(scope.node.id + id)
            .digest("hex")
            .substring(0, 8);
        // Handle local development (ie. sst start)
        // - set runtime to nodejs12.x for non-Node runtimes (b/c the stub is in Node)
        // - set retry to 0. When the debugger is disconnected, the Cron construct
        //   will still try to periodically invoke the Lambda, and the requests would
        //   fail and retry. So when launching `sst start`, a couple of retry requests
        //   from recent failed request will be received. And this behavior is confusing.
        if (isLiveDevEnabled &&
            root.local &&
            root.debugEndpoint &&
            root.debugBucketName &&
            root.debugBucketArn) {
            // If debugIncreaseTimeout is enabled:
            //   set timeout to 900. This will give people more time to debug the function
            //   without timing out the request. Note API Gateway requests have a maximum
            //   timeout of 29s. In this case, the API will timeout, but the Lambda function
            //   will continue to run.
            let debugOverrideProps;
            if (root.debugIncreaseTimeout) {
                debugOverrideProps = {
                    timeout: cdk.Duration.seconds(900),
                };
            }
            if (root.debugBridge) {
                super(scope, id, Object.assign(Object.assign(Object.assign({}, props), { functionName, runtime: lambda.Runtime.GO_1_X, tracing,
                    timeout,
                    memorySize, handler: "handler", code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../dist/bridge_client/")), environment: Object.assign(Object.assign({}, (props.environment || {})), { SST_DEBUG_BRIDGE: root.debugBridge, SST_DEBUG_SRC_PATH: srcPath, SST_DEBUG_SRC_HANDLER: handler, SST_DEBUG_ENDPOINT: root.debugEndpoint }), layers: Function.handleImportedLayers(scope, props.layers || []) }), (debugOverrideProps || {})));
            }
            else {
                super(scope, id, Object.assign(Object.assign(Object.assign({}, props), { functionName, runtime: isNodeRuntime ? runtime : lambda.Runtime.NODEJS_12_X, tracing,
                    timeout,
                    memorySize, handler: "index.main", retryAttempts: 0, code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../dist/stub.zip")), environment: Object.assign(Object.assign({}, (props.environment || {})), { SST_DEBUG_SRC_PATH: srcPath, SST_DEBUG_SRC_HANDLER: handler, SST_DEBUG_ENDPOINT: root.debugEndpoint, SST_DEBUG_BUCKET_NAME: root.debugBucketName }), layers: Function.handleImportedLayers(scope, props.layers || []) }), (debugOverrideProps || {})));
            }
            core_1.State.Function.append(root.appPath, {
                id: localId,
                handler: handler,
                runtime: runtime.toString(),
                srcPath: srcPath,
                bundle: props.bundle,
            });
            this.addEnvironment("SST_FUNCTION_ID", localId);
            this.attachPermissions([
                new iam.PolicyStatement({
                    actions: ["s3:*"],
                    effect: iam.Effect.ALLOW,
                    resources: [root.debugBucketArn, `${root.debugBucketArn}/*`],
                }),
            ]);
        }
        // Handle remove (ie. sst remove)
        else if (root.skipBuild) {
            // Note: need to override runtime as CDK does not support inline code
            //       for some runtimes.
            super(scope, id, Object.assign(Object.assign({}, props), { functionName, runtime: lambda.Runtime.NODEJS_12_X, handler: "placeholder", code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../assets/Function/placeholder-stub")), timeout, layers: Function.handleImportedLayers(scope, props.layers || []) }));
        }
        // Handle build
        else {
            console.log("Building function", handler);
            const bundled = core_2.Runtime.Handler.bundle({
                id: localId,
                root: root.appPath,
                handler: handler,
                runtime: runtime.toString(),
                srcPath: srcPath,
                bundle: props.bundle,
            });
            // Python builder returns AssetCode instead of directory
            const code = (() => {
                if ("directory" in bundled) {
                    Function.copyFiles(bundle, srcPath, bundled.directory);
                    return lambda.AssetCode.fromAsset(bundled.directory);
                }
                return bundled.asset;
            })();
            super(scope, id, Object.assign(Object.assign({}, props), { functionName,
                runtime,
                tracing,
                memorySize, handler: bundled.handler, code: code, timeout, layers: Function.handleImportedLayers(scope, props.layers || []) }));
        }
        // Enable reusing connections with Keep-Alive for NodeJs Lambda function
        if (isNodeRuntime) {
            this.addEnvironment("AWS_NODEJS_CONNECTION_REUSE_ENABLED", "1", {
                removeInEdge: true,
            });
        }
        // Attach permissions
        if (permissions) {
            this.attachPermissions(permissions);
        }
        root.registerLambdaHandler({
            bundle: props.bundle,
            handler: handler,
            runtime: runtime.toString(),
            srcPath,
        });
        this._isLiveDevEnabled = isLiveDevEnabled;
        this.localId = localId;
    }
    attachPermissions(permissions) {
        if (this.role) {
            permission_1.attachPermissionsToRole(this.role, permissions);
        }
    }
    getConstructMetadata() {
        return {
            type: "Function",
            data: {
                localId: this.localId,
                arn: this.functionArn,
            },
        };
    }
    static normalizeSrcPath(srcPath) {
        return srcPath.replace(/\/+$/, "");
    }
    static copyFiles(bundle, srcPath, buildPath) {
        if (!bundle)
            return;
        if (typeof bundle === "boolean")
            return;
        if (!bundle.copyFiles)
            return;
        bundle.copyFiles.forEach((entry) => {
            const fromPath = path_1.default.join(srcPath, entry.from);
            if (!fs.existsSync(fromPath))
                throw new Error(`Tried to copy nonexistent file from "${path_1.default.resolve(fromPath)}" - check copyFiles entry "${entry.from}"`);
            const to = entry.to || entry.from;
            if (path_1.default.isAbsolute(to))
                throw new Error(`Copy destination path "${to}" must be relative`);
            const toPath = path_1.default.join(buildPath, to);
            fs.copySync(fromPath, toPath);
        });
    }
    static handleImportedLayers(scope, layers) {
        return layers.map((layer) => {
            const layerStack = Stack_1.Stack.of(layer);
            const currentStack = Stack_1.Stack.of(scope);
            // Use layer directly if:
            // - layer is created in the current stack; OR
            // - layer is imported (ie. layerArn is a string)
            if (layerStack === currentStack ||
                !cdk.Token.isUnresolved(layer.layerVersionArn)) {
                return layer;
            }
            // layer is created from another stack
            else {
                // set stack dependency b/c layerStack need to create the SSM first
                currentStack.addDependency(layerStack);
                // store layer ARN in SSM in layer's stack
                const parameterId = `${layer.node.id}Arn-${layer.node.addr}`;
                const parameterName = `/layers/${layerStack.node.id}/${parameterId}`;
                const existingSsmParam = layerStack.node.tryFindChild(parameterId);
                if (!existingSsmParam) {
                    new ssm.StringParameter(layerStack, parameterId, {
                        parameterName,
                        stringValue: layer.layerVersionArn,
                    });
                }
                // import layer from SSM value
                const layerId = `I${layer.node.id}-${layer.node.addr}`;
                const existingLayer = scope.node.tryFindChild(layerId);
                if (existingLayer) {
                    return existingLayer;
                }
                else {
                    return lambda.LayerVersion.fromLayerVersionArn(scope, layerId, ssm.StringParameter.valueForStringParameter(scope, parameterName));
                }
            }
        });
    }
    static fromDefinition(scope, id, definition, inheritedProps, inheritErrorMessage) {
        if (typeof definition === "string") {
            return new Function(scope, id, Object.assign(Object.assign({}, (inheritedProps || {})), { handler: definition }));
        }
        else if (definition instanceof Function) {
            if (inheritedProps && Object.keys(inheritedProps).length > 0) {
                throw new Error(inheritErrorMessage ||
                    `Cannot inherit default props when a Function is provided`);
            }
            return definition;
        }
        else if (definition instanceof lambda.Function) {
            throw new Error(`Please use sst.Function instead of lambda.Function for the "${id}" Function.`);
        }
        else if (definition.handler !== undefined) {
            return new Function(scope, id, Function.mergeProps(inheritedProps, definition));
        }
        throw new Error(`Invalid function definition for the "${id}" Function`);
    }
    static mergeProps(baseProps, props) {
        // Merge environment
        const environment = Object.assign(Object.assign({}, ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.environment) || {})), ((props === null || props === void 0 ? void 0 : props.environment) || {}));
        const environmentProp = Object.keys(environment).length === 0 ? {} : { environment };
        // Merge layers
        const layers = [...((baseProps === null || baseProps === void 0 ? void 0 : baseProps.layers) || []), ...((props === null || props === void 0 ? void 0 : props.layers) || [])];
        const layersProp = layers.length === 0 ? {} : { layers };
        // Merge permissions
        let permissionsProp;
        if ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.permissions) === permission_1.PermissionType.ALL ||
            (props === null || props === void 0 ? void 0 : props.permissions) === permission_1.PermissionType.ALL) {
            permissionsProp = { permissions: permission_1.PermissionType.ALL };
        }
        else {
            const permissions = ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.permissions) || []).concat((props === null || props === void 0 ? void 0 : props.permissions) || []);
            permissionsProp = permissions.length === 0 ? {} : { permissions };
        }
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (baseProps || {})), (props || {})), layersProp), environmentProp), permissionsProp);
    }
}
exports.Function = Function;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVuY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvRnVuY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGlEQUFpRDtBQUNqRCx3RkFBd0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFeEYsZ0RBQXdCO0FBRXhCLDZDQUErQjtBQUUvQixpREFBbUM7QUFDbkMseURBQTJDO0FBQzNDLCtEQUFpRDtBQUVqRCx5REFBMkM7QUFDM0Msb0RBQTRCO0FBRzVCLG1DQUFnQztBQUVoQyxrREFJMkI7QUFDM0IsaURBQStDO0FBQy9DLGlEQUFpRDtBQUVqRCxNQUFNLGlCQUFpQixHQUFHO0lBQ3hCLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTTtJQUNyQixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7SUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXO0lBQzFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztJQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7SUFDMUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXO0lBQzFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztJQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7SUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVTtJQUN6QixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7SUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsYUFBYTtJQUM1QixNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWE7SUFDNUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlO0lBQzlCLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZTtJQUM5QixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU07Q0FDdEIsQ0FBQztBQW9JRixNQUFhLFFBQVMsU0FBUSxNQUFNLENBQUMsUUFBUTtJQUkz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QUMsR0FBRyxFQUN6QztZQUNBLGVBQWUsR0FBRyxFQUFFLFdBQVcsRUFBRSwyQkFBYyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ3ZEO2FBQU07WUFDTCxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUEsU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLFdBQVcsS0FBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQ3ZELENBQUEsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLFdBQVcsS0FBSSxFQUFFLENBQ3pCLENBQUM7WUFDRixlQUFlLEdBQUcsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsQ0FBQztTQUNuRTtRQUVELGlGQUNLLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxHQUNqQixDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsR0FDYixVQUFVLEdBQ1YsZUFBZSxHQUNmLGVBQWUsRUFDbEI7SUFDSixDQUFDO0NBQ0Y7QUFuWkQsNEJBbVpDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlcyAqL1xuLy8gTm90ZTogZGlzYWJsaW5nIGJhbi10eXBlIHJ1bGUgc28gd2UgZG9uJ3QgZ2V0IGFuIGVycm9yIHJlZmVyZW5jaW5nIHRoZSBjbGFzcyBGdW5jdGlvblxuXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgZXNidWlsZCBmcm9tIFwiZXNidWlsZFwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0ICogYXMgY2RrIGZyb20gXCJhd3MtY2RrLWxpYlwiO1xuaW1wb3J0ICogYXMgaWFtIGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtaWFtXCI7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSBcImF3cy1jZGstbGliL2F3cy1sYW1iZGFcIjtcbmltcG9ydCAqIGFzIGxhbWJkYU5vZGUgZnJvbSBcImF3cy1jZGstbGliL2F3cy1sYW1iZGEtbm9kZWpzXCI7XG5pbXBvcnQgKiBhcyBzc20gZnJvbSBcImF3cy1jZGstbGliL2F3cy1zc21cIjtcbmltcG9ydCBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xuXG5pbXBvcnQgeyBBcHAgfSBmcm9tIFwiLi9BcHBcIjtcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSBcIi4vU3RhY2tcIjtcbmltcG9ydCB7IFNTVENvbnN0cnVjdCB9IGZyb20gXCIuL0NvbnN0cnVjdFwiO1xuaW1wb3J0IHtcbiAgUGVybWlzc2lvblR5cGUsXG4gIFBlcm1pc3Npb25zLFxuICBhdHRhY2hQZXJtaXNzaW9uc1RvUm9sZSxcbn0gZnJvbSBcIi4vdXRpbC9wZXJtaXNzaW9uXCI7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gXCJAc2VydmVybGVzcy1zdGFjay9jb3JlXCI7XG5pbXBvcnQgeyBSdW50aW1lIH0gZnJvbSBcIkBzZXJ2ZXJsZXNzLXN0YWNrL2NvcmVcIjtcblxuY29uc3Qgc3VwcG9ydGVkUnVudGltZXMgPSBbXG4gIGxhbWJkYS5SdW50aW1lLk5PREVKUyxcbiAgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzRfMyxcbiAgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzZfMTAsXG4gIGxhbWJkYS5SdW50aW1lLk5PREVKU184XzEwLFxuICBsYW1iZGEuUnVudGltZS5OT0RFSlNfMTBfWCxcbiAgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzEyX1gsXG4gIGxhbWJkYS5SdW50aW1lLk5PREVKU18xNF9YLFxuICBsYW1iZGEuUnVudGltZS5QWVRIT05fMl83LFxuICBsYW1iZGEuUnVudGltZS5QWVRIT05fM182LFxuICBsYW1iZGEuUnVudGltZS5QWVRIT05fM183LFxuICBsYW1iZGEuUnVudGltZS5QWVRIT05fM184LFxuICBsYW1iZGEuUnVudGltZS5QWVRIT05fM185LFxuICBsYW1iZGEuUnVudGltZS5ET1RORVRfQ09SRV8xLFxuICBsYW1iZGEuUnVudGltZS5ET1RORVRfQ09SRV8yLFxuICBsYW1iZGEuUnVudGltZS5ET1RORVRfQ09SRV8yXzEsXG4gIGxhbWJkYS5SdW50aW1lLkRPVE5FVF9DT1JFXzNfMSxcbiAgbGFtYmRhLlJ1bnRpbWUuR09fMV9YLFxuXTtcblxuZXhwb3J0IHR5cGUgSGFuZGxlclByb3BzID0gRnVuY3Rpb25IYW5kbGVyUHJvcHM7XG5leHBvcnQgdHlwZSBGdW5jdGlvbkRlZmluaXRpb24gPSBzdHJpbmcgfCBGdW5jdGlvbiB8IEZ1bmN0aW9uUHJvcHM7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25Qcm9wc1xuICBleHRlbmRzIE9taXQ8bGFtYmRhLkZ1bmN0aW9uT3B0aW9ucywgXCJmdW5jdGlvbk5hbWVcIiB8IFwidGltZW91dFwiIHwgXCJydW50aW1lXCI+IHtcbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgZGlyZWN0b3J5IHdoZXJlIHRoZSBlbnRyeSBwb2ludCBpcyBsb2NhdGVkLiBUaGUgbm9kZV9tb2R1bGVzIGluIHRoaXNcbiAgICogZGlyZWN0b3J5IGlzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGJ1bmRsZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBBIG5hbWUgZm9yIHRoZSBmdW5jdGlvbiBvciBhIGNhbGxiYWNrIHRoYXQgcmV0dXJucyB0aGUgbmFtZS5cbiAgICovXG4gIGZ1bmN0aW9uTmFtZT86IHN0cmluZyB8ICgocHJvcHM6IEZ1bmN0aW9uTmFtZVByb3BzKSA9PiBzdHJpbmcpO1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZW50cnkgcG9pbnQgYW5kIGhhbmRsZXIgZnVuY3Rpb24uIE9mIHRoZSBmb3JtYXQ6XG4gICAqIGAvcGF0aC90by9maWxlLmZ1bmN0aW9uYC5cbiAgICovXG4gIGhhbmRsZXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgc291cmNlIGRpcmVjdG9yeSB3aGVyZSB0aGUgZW50cnkgcG9pbnQgaXMgbG9jYXRlZC4gVGhlIG5vZGVfbW9kdWxlcyBpbiB0aGlzXG4gICAqIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBidW5kbGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gdGhlIGFwcCBkaXJlY3RvcnkuXG4gICAqL1xuICBzcmNQYXRoPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gTk9ERUpTXzEyX1hcbiAgICovXG4gIHJ1bnRpbWU/OlxuICAgIHwgXCJub2RlanNcIlxuICAgIHwgXCJub2RlanM0LjNcIlxuICAgIHwgXCJub2RlanM2LjEwXCJcbiAgICB8IFwibm9kZWpzOC4xMFwiXG4gICAgfCBcIm5vZGVqczEwLnhcIlxuICAgIHwgXCJub2RlanMxMi54XCJcbiAgICB8IFwibm9kZWpzMTQueFwiXG4gICAgfCBcInB5dGhvbjIuN1wiXG4gICAgfCBcInB5dGhvbjMuNlwiXG4gICAgfCBcInB5dGhvbjMuN1wiXG4gICAgfCBcInB5dGhvbjMuOFwiXG4gICAgfCBcInB5dGhvbjMuOVwiXG4gICAgfCBcImRvdG5ldGNvcmUxLjBcIlxuICAgIHwgXCJkb3RuZXRjb3JlMi4wXCJcbiAgICB8IFwiZG90bmV0Y29yZTIuMVwiXG4gICAgfCBcImRvdG5ldGNvcmUzLjFcIlxuICAgIHwgXCJnbzEueFwiXG4gICAgfCBsYW1iZGEuUnVudGltZTtcbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgbWVtb3J5IGluIE1CIGFsbG9jYXRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byAxMDI0XG4gICAqL1xuICBtZW1vcnlTaXplPzogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIGV4ZWN1dGlvbiB0aW1lb3V0IGluIHNlY29uZHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbnVtYmVyXG4gICAqL1xuICB0aW1lb3V0PzogbnVtYmVyIHwgY2RrLkR1cmF0aW9uO1xuICAvKipcbiAgICogRW5hYmxlIEFXUyBYLVJheSBUcmFjaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIEFDVElWRVxuICAgKi9cbiAgdHJhY2luZz86IGxhbWJkYS5UcmFjaW5nO1xuXG4gIC8qKlxuICAgKiBFbmFibGUgbG9jYWwgZGV2ZWxvcG1lbnRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuICBlbmFibGVMaXZlRGV2PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGlzYWJsZSBidW5kbGluZyB3aXRoIGVzYnVpbGQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cbiAgYnVuZGxlPzogRnVuY3Rpb25CdW5kbGVQcm9wO1xuICBwZXJtaXNzaW9ucz86IFBlcm1pc3Npb25zO1xuICBsYXllcnM/OiBsYW1iZGEuSUxheWVyVmVyc2lvbltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uTmFtZVByb3BzIHtcbiAgc3RhY2s6IFN0YWNrO1xuICBmdW5jdGlvblByb3BzOiBGdW5jdGlvblByb3BzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uSGFuZGxlclByb3BzIHtcbiAgc3JjUGF0aDogc3RyaW5nO1xuICBoYW5kbGVyOiBzdHJpbmc7XG4gIGJ1bmRsZTogRnVuY3Rpb25CdW5kbGVQcm9wO1xuICBydW50aW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uQnVuZGxlUHJvcCA9IEZ1bmN0aW9uQnVuZGxlT2JqZWN0IHwgYm9vbGVhbjtcblxuZXhwb3J0IHR5cGUgRnVuY3Rpb25CdW5kbGVPYmplY3QgPSBGdW5jdGlvbkJ1bmRsZUJhc2UgJlxuICAoRnVuY3Rpb25CdW5kbGVOb2RlanNQcm9wcyB8IEZ1bmN0aW9uQnVuZGxlUHl0aG9uUHJvcHMpO1xuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkJ1bmRsZUJhc2UgPSB7XG4gIHJlYWRvbmx5IGNvcHlGaWxlcz86IEZ1bmN0aW9uQnVuZGxlQ29weUZpbGVzUHJvcHNbXTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25CdW5kbGVOb2RlanNQcm9wcyB7XG4gIGxvYWRlcj86IHsgW2V4dDogc3RyaW5nXTogZXNidWlsZC5Mb2FkZXIgfTtcbiAgZXh0ZXJuYWxNb2R1bGVzPzogc3RyaW5nW107XG4gIG5vZGVNb2R1bGVzPzogc3RyaW5nW107XG4gIGNvbW1hbmRIb29rcz86IGxhbWJkYU5vZGUuSUNvbW1hbmRIb29rcztcbiAgZXNidWlsZENvbmZpZz86IEZ1bmN0aW9uQnVuZGxlRXNidWlsZENvbmZpZztcbiAgbWluaWZ5PzogYm9vbGVhbjtcbiAgZm9ybWF0PzogXCJjanNcIiB8IFwiZXNtXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25CdW5kbGVQeXRob25Qcm9wcyB7XG4gIGluc3RhbGxDb21tYW5kcz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQnVuZGxlQ29weUZpbGVzUHJvcHMge1xuICBmcm9tOiBzdHJpbmc7XG4gIHRvPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQnVuZGxlRXNidWlsZENvbmZpZyB7XG4gIGRlZmluZT86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIGtlZXBOYW1lcz86IGJvb2xlYW47XG4gIHBsdWdpbnM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbiBleHRlbmRzIGxhbWJkYS5GdW5jdGlvbiBpbXBsZW1lbnRzIFNTVENvbnN0cnVjdCB7XG4gIHB1YmxpYyByZWFkb25seSBfaXNMaXZlRGV2RW5hYmxlZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2NhbElkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEZ1bmN0aW9uUHJvcHMpIHtcbiAgICBjb25zdCByb290ID0gc2NvcGUubm9kZS5yb290IGFzIEFwcDtcbiAgICBjb25zdCBzdGFjayA9IFN0YWNrLm9mKHNjb3BlKSBhcyBTdGFjaztcblxuICAgIC8vIE1lcmdlIHdpdGggYXBwIGRlZmF1bHRGdW5jdGlvblByb3BzXG4gICAgLy8gbm90ZTogcmV2ZXJzZSBvcmRlciBzbyBsYXRlciBwcm9wIG92ZXJyaWRlIGVhcmxpZXIgb25lc1xuICAgIHN0YWNrLmRlZmF1bHRGdW5jdGlvblByb3BzXG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZvckVhY2goKHBlcikgPT4ge1xuICAgICAgICBwcm9wcyA9IEZ1bmN0aW9uLm1lcmdlUHJvcHMocGVyLCBwcm9wcyk7XG4gICAgICB9KTtcblxuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9XG4gICAgICBwcm9wcy5mdW5jdGlvbk5hbWUgJiZcbiAgICAgICh0eXBlb2YgcHJvcHMuZnVuY3Rpb25OYW1lID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gcHJvcHMuZnVuY3Rpb25OYW1lXG4gICAgICAgIDogcHJvcHMuZnVuY3Rpb25OYW1lKHsgc3RhY2ssIGZ1bmN0aW9uUHJvcHM6IHByb3BzIH0pKTtcbiAgICBjb25zdCBoYW5kbGVyID0gcHJvcHMuaGFuZGxlcjtcbiAgICBsZXQgdGltZW91dCA9IHByb3BzLnRpbWVvdXQgfHwgMTA7XG4gICAgY29uc3Qgc3JjUGF0aCA9IEZ1bmN0aW9uLm5vcm1hbGl6ZVNyY1BhdGgocHJvcHMuc3JjUGF0aCB8fCBcIi5cIik7XG4gICAgY29uc3QgbWVtb3J5U2l6ZSA9IHByb3BzLm1lbW9yeVNpemUgfHwgMTAyNDtcbiAgICBjb25zdCB0cmFjaW5nID0gcHJvcHMudHJhY2luZyB8fCBsYW1iZGEuVHJhY2luZy5BQ1RJVkU7XG4gICAgbGV0IHJ1bnRpbWUgPSBwcm9wcy5ydW50aW1lIHx8IGxhbWJkYS5SdW50aW1lLk5PREVKU18xMl9YO1xuICAgIGxldCBidW5kbGUgPSBwcm9wcy5idW5kbGU7XG4gICAgY29uc3QgcGVybWlzc2lvbnMgPSBwcm9wcy5wZXJtaXNzaW9ucztcbiAgICBjb25zdCBpc0xpdmVEZXZFbmFibGVkID0gcHJvcHMuZW5hYmxlTGl2ZURldiA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG5cbiAgICAvLyBWYWxpZGF0ZSBoYW5kbGVyXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGhhbmRsZXIgZGVmaW5lZCBmb3IgdGhlIFwiJHtpZH1cIiBMYW1iZGEgZnVuY3Rpb25gKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgcnVudGltZVxuICAgIGNvbnN0IHJ1bnRpbWVTdHIgPVxuICAgICAgdHlwZW9mIHJ1bnRpbWUgPT09IFwic3RyaW5nXCIgPyBydW50aW1lIDogcnVudGltZS50b1N0cmluZygpO1xuICAgIGNvbnN0IHJ1bnRpbWVDbGFzcyA9IHN1cHBvcnRlZFJ1bnRpbWVzLmZpbmQoXG4gICAgICAocGVyKSA9PiBwZXIudG9TdHJpbmcoKSA9PT0gcnVudGltZVN0clxuICAgICk7XG4gICAgaWYgKCFydW50aW1lQ2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBzcGVjaWZpZWQgcnVudGltZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzc3QuRnVuY3Rpb24uIE9ubHkgTm9kZUpTLCBQeXRob24sIEdvLCBhbmQgLk5FVCBydW50aW1lcyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBydW50aW1lID0gcnVudGltZUNsYXNzO1xuXG4gICAgLy8gTm9ybWFsaXplIHRpbWVvdXRcbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRpbWVvdXQgPSBjZGsuRHVyYXRpb24uc2Vjb25kcyh0aW1lb3V0KTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBpbnB1dFxuICAgIGNvbnN0IGlzTm9kZVJ1bnRpbWUgPSBydW50aW1lU3RyLnN0YXJ0c1dpdGgoXCJub2RlanNcIik7XG4gICAgY29uc3QgaXNQeXRob25SdW50aW1lID0gcnVudGltZVN0ci5zdGFydHNXaXRoKFwicHl0aG9uXCIpO1xuICAgIGlmIChpc05vZGVSdW50aW1lKSB7XG4gICAgICBidW5kbGUgPSBidW5kbGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwcm9wcy5idW5kbGU7XG4gICAgICBpZiAoIWJ1bmRsZSAmJiBzcmNQYXRoID09PSBcIi5cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEJ1bmRsZSBjYW5ub3QgYmUgZGlzYWJsZWQgZm9yIHRoZSBcIiR7aWR9XCIgZnVuY3Rpb24gc2luY2UgdGhlIFwic3JjUGF0aFwiIGlzIHNldCB0byB0aGUgcHJvamVjdCByb290LiBSZWFkIG1vcmUgaGVyZSDigJQgaHR0cHM6Ly9naXRodWIuY29tL3NlcnZlcmxlc3Mtc3RhY2svc2VydmVybGVzcy1zdGFjay9pc3N1ZXMvNzhgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1B5dGhvblJ1bnRpbWUpIHtcbiAgICAgIGJ1bmRsZSA9IGJ1bmRsZSA9PT0gdW5kZWZpbmVkID8ge30gOiBwcm9wcy5idW5kbGU7XG4gICAgICBpZiAoc3JjUGF0aCA9PT0gXCIuXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3Qgc2V0IHRoZSBcInNyY1BhdGhcIiB0byB0aGUgcHJvamVjdCByb290IGZvciB0aGUgXCIke2lkfVwiIGZ1bmN0aW9uLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbElkID0gY3J5cHRvXG4gICAgICAuY3JlYXRlSGFzaChcInNoYTFcIilcbiAgICAgIC51cGRhdGUoc2NvcGUubm9kZS5pZCArIGlkKVxuICAgICAgLmRpZ2VzdChcImhleFwiKVxuICAgICAgLnN1YnN0cmluZygwLCA4KTtcblxuICAgIC8vIEhhbmRsZSBsb2NhbCBkZXZlbG9wbWVudCAoaWUuIHNzdCBzdGFydClcbiAgICAvLyAtIHNldCBydW50aW1lIHRvIG5vZGVqczEyLnggZm9yIG5vbi1Ob2RlIHJ1bnRpbWVzIChiL2MgdGhlIHN0dWIgaXMgaW4gTm9kZSlcbiAgICAvLyAtIHNldCByZXRyeSB0byAwLiBXaGVuIHRoZSBkZWJ1Z2dlciBpcyBkaXNjb25uZWN0ZWQsIHRoZSBDcm9uIGNvbnN0cnVjdFxuICAgIC8vICAgd2lsbCBzdGlsbCB0cnkgdG8gcGVyaW9kaWNhbGx5IGludm9rZSB0aGUgTGFtYmRhLCBhbmQgdGhlIHJlcXVlc3RzIHdvdWxkXG4gICAgLy8gICBmYWlsIGFuZCByZXRyeS4gU28gd2hlbiBsYXVuY2hpbmcgYHNzdCBzdGFydGAsIGEgY291cGxlIG9mIHJldHJ5IHJlcXVlc3RzXG4gICAgLy8gICBmcm9tIHJlY2VudCBmYWlsZWQgcmVxdWVzdCB3aWxsIGJlIHJlY2VpdmVkLiBBbmQgdGhpcyBiZWhhdmlvciBpcyBjb25mdXNpbmcuXG4gICAgaWYgKFxuICAgICAgaXNMaXZlRGV2RW5hYmxlZCAmJlxuICAgICAgcm9vdC5sb2NhbCAmJlxuICAgICAgcm9vdC5kZWJ1Z0VuZHBvaW50ICYmXG4gICAgICByb290LmRlYnVnQnVja2V0TmFtZSAmJlxuICAgICAgcm9vdC5kZWJ1Z0J1Y2tldEFyblxuICAgICkge1xuICAgICAgLy8gSWYgZGVidWdJbmNyZWFzZVRpbWVvdXQgaXMgZW5hYmxlZDpcbiAgICAgIC8vICAgc2V0IHRpbWVvdXQgdG8gOTAwLiBUaGlzIHdpbGwgZ2l2ZSBwZW9wbGUgbW9yZSB0aW1lIHRvIGRlYnVnIHRoZSBmdW5jdGlvblxuICAgICAgLy8gICB3aXRob3V0IHRpbWluZyBvdXQgdGhlIHJlcXVlc3QuIE5vdGUgQVBJIEdhdGV3YXkgcmVxdWVzdHMgaGF2ZSBhIG1heGltdW1cbiAgICAgIC8vICAgdGltZW91dCBvZiAyOXMuIEluIHRoaXMgY2FzZSwgdGhlIEFQSSB3aWxsIHRpbWVvdXQsIGJ1dCB0aGUgTGFtYmRhIGZ1bmN0aW9uXG4gICAgICAvLyAgIHdpbGwgY29udGludWUgdG8gcnVuLlxuICAgICAgbGV0IGRlYnVnT3ZlcnJpZGVQcm9wcztcbiAgICAgIGlmIChyb290LmRlYnVnSW5jcmVhc2VUaW1lb3V0KSB7XG4gICAgICAgIGRlYnVnT3ZlcnJpZGVQcm9wcyA9IHtcbiAgICAgICAgICB0aW1lb3V0OiBjZGsuRHVyYXRpb24uc2Vjb25kcyg5MDApLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAocm9vdC5kZWJ1Z0JyaWRnZSkge1xuICAgICAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgcnVudGltZTogbGFtYmRhLlJ1bnRpbWUuR09fMV9YLFxuICAgICAgICAgIHRyYWNpbmcsXG4gICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICBtZW1vcnlTaXplLFxuICAgICAgICAgIGhhbmRsZXI6IFwiaGFuZGxlclwiLFxuICAgICAgICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21Bc3NldChcbiAgICAgICAgICAgIHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIFwiLi4vZGlzdC9icmlkZ2VfY2xpZW50L1wiKVxuICAgICAgICAgICksXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHtcbiAgICAgICAgICAgIC4uLihwcm9wcy5lbnZpcm9ubWVudCB8fCB7fSksXG4gICAgICAgICAgICBTU1RfREVCVUdfQlJJREdFOiByb290LmRlYnVnQnJpZGdlLFxuICAgICAgICAgICAgU1NUX0RFQlVHX1NSQ19QQVRIOiBzcmNQYXRoLFxuICAgICAgICAgICAgU1NUX0RFQlVHX1NSQ19IQU5ETEVSOiBoYW5kbGVyLFxuICAgICAgICAgICAgU1NUX0RFQlVHX0VORFBPSU5UOiByb290LmRlYnVnRW5kcG9pbnQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsYXllcnM6IEZ1bmN0aW9uLmhhbmRsZUltcG9ydGVkTGF5ZXJzKHNjb3BlLCBwcm9wcy5sYXllcnMgfHwgW10pLFxuICAgICAgICAgIC4uLihkZWJ1Z092ZXJyaWRlUHJvcHMgfHwge30pLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICBydW50aW1lOiBpc05vZGVSdW50aW1lID8gcnVudGltZSA6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xMl9YLFxuICAgICAgICAgIHRyYWNpbmcsXG4gICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICBtZW1vcnlTaXplLFxuICAgICAgICAgIGhhbmRsZXI6IFwiaW5kZXgubWFpblwiLFxuICAgICAgICAgIHJldHJ5QXR0ZW1wdHM6IDAsXG4gICAgICAgICAgY29kZTogbGFtYmRhLkNvZGUuZnJvbUFzc2V0KFxuICAgICAgICAgICAgcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgXCIuLi9kaXN0L3N0dWIuemlwXCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgLi4uKHByb3BzLmVudmlyb25tZW50IHx8IHt9KSxcbiAgICAgICAgICAgIFNTVF9ERUJVR19TUkNfUEFUSDogc3JjUGF0aCxcbiAgICAgICAgICAgIFNTVF9ERUJVR19TUkNfSEFORExFUjogaGFuZGxlcixcbiAgICAgICAgICAgIFNTVF9ERUJVR19FTkRQT0lOVDogcm9vdC5kZWJ1Z0VuZHBvaW50LFxuICAgICAgICAgICAgU1NUX0RFQlVHX0JVQ0tFVF9OQU1FOiByb290LmRlYnVnQnVja2V0TmFtZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxheWVyczogRnVuY3Rpb24uaGFuZGxlSW1wb3J0ZWRMYXllcnMoc2NvcGUsIHByb3BzLmxheWVycyB8fCBbXSksXG4gICAgICAgICAgLi4uKGRlYnVnT3ZlcnJpZGVQcm9wcyB8fCB7fSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgU3RhdGUuRnVuY3Rpb24uYXBwZW5kKHJvb3QuYXBwUGF0aCwge1xuICAgICAgICBpZDogbG9jYWxJZCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgcnVudGltZTogcnVudGltZS50b1N0cmluZygpLFxuICAgICAgICBzcmNQYXRoOiBzcmNQYXRoLFxuICAgICAgICBidW5kbGU6IHByb3BzLmJ1bmRsZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRFbnZpcm9ubWVudChcIlNTVF9GVU5DVElPTl9JRFwiLCBsb2NhbElkKTtcbiAgICAgIHRoaXMuYXR0YWNoUGVybWlzc2lvbnMoW1xuICAgICAgICBuZXcgaWFtLlBvbGljeVN0YXRlbWVudCh7XG4gICAgICAgICAgYWN0aW9uczogW1wiczM6KlwiXSxcbiAgICAgICAgICBlZmZlY3Q6IGlhbS5FZmZlY3QuQUxMT1csXG4gICAgICAgICAgcmVzb3VyY2VzOiBbcm9vdC5kZWJ1Z0J1Y2tldEFybiwgYCR7cm9vdC5kZWJ1Z0J1Y2tldEFybn0vKmBdLFxuICAgICAgICB9KSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVtb3ZlIChpZS4gc3N0IHJlbW92ZSlcbiAgICBlbHNlIGlmIChyb290LnNraXBCdWlsZCkge1xuICAgICAgLy8gTm90ZTogbmVlZCB0byBvdmVycmlkZSBydW50aW1lIGFzIENESyBkb2VzIG5vdCBzdXBwb3J0IGlubGluZSBjb2RlXG4gICAgICAvLyAgICAgICBmb3Igc29tZSBydW50aW1lcy5cbiAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICBydW50aW1lOiBsYW1iZGEuUnVudGltZS5OT0RFSlNfMTJfWCxcbiAgICAgICAgaGFuZGxlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBjb2RlOiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoXG4gICAgICAgICAgcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgXCIuLi9hc3NldHMvRnVuY3Rpb24vcGxhY2Vob2xkZXItc3R1YlwiKVxuICAgICAgICApLFxuICAgICAgICB0aW1lb3V0LFxuICAgICAgICBsYXllcnM6IEZ1bmN0aW9uLmhhbmRsZUltcG9ydGVkTGF5ZXJzKHNjb3BlLCBwcm9wcy5sYXllcnMgfHwgW10pLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBidWlsZFxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJCdWlsZGluZyBmdW5jdGlvblwiLCBoYW5kbGVyKTtcbiAgICAgIGNvbnN0IGJ1bmRsZWQgPSBSdW50aW1lLkhhbmRsZXIuYnVuZGxlKHtcbiAgICAgICAgaWQ6IGxvY2FsSWQsXG4gICAgICAgIHJvb3Q6IHJvb3QuYXBwUGF0aCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgcnVudGltZTogcnVudGltZS50b1N0cmluZygpLFxuICAgICAgICBzcmNQYXRoOiBzcmNQYXRoLFxuICAgICAgICBidW5kbGU6IHByb3BzLmJ1bmRsZSxcbiAgICAgIH0pITtcblxuICAgICAgLy8gUHl0aG9uIGJ1aWxkZXIgcmV0dXJucyBBc3NldENvZGUgaW5zdGVhZCBvZiBkaXJlY3RvcnlcbiAgICAgIGNvbnN0IGNvZGUgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoXCJkaXJlY3RvcnlcIiBpbiBidW5kbGVkKSB7XG4gICAgICAgICAgRnVuY3Rpb24uY29weUZpbGVzKGJ1bmRsZSwgc3JjUGF0aCwgYnVuZGxlZC5kaXJlY3RvcnkpO1xuICAgICAgICAgIHJldHVybiBsYW1iZGEuQXNzZXRDb2RlLmZyb21Bc3NldChidW5kbGVkLmRpcmVjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1bmRsZWQuYXNzZXQ7XG4gICAgICB9KSgpO1xuXG4gICAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgdHJhY2luZyxcbiAgICAgICAgbWVtb3J5U2l6ZSxcbiAgICAgICAgaGFuZGxlcjogYnVuZGxlZC5oYW5kbGVyLFxuICAgICAgICBjb2RlOiBjb2RlISxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgbGF5ZXJzOiBGdW5jdGlvbi5oYW5kbGVJbXBvcnRlZExheWVycyhzY29wZSwgcHJvcHMubGF5ZXJzIHx8IFtdKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEVuYWJsZSByZXVzaW5nIGNvbm5lY3Rpb25zIHdpdGggS2VlcC1BbGl2ZSBmb3IgTm9kZUpzIExhbWJkYSBmdW5jdGlvblxuICAgIGlmIChpc05vZGVSdW50aW1lKSB7XG4gICAgICB0aGlzLmFkZEVudmlyb25tZW50KFwiQVdTX05PREVKU19DT05ORUNUSU9OX1JFVVNFX0VOQUJMRURcIiwgXCIxXCIsIHtcbiAgICAgICAgcmVtb3ZlSW5FZGdlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXR0YWNoIHBlcm1pc3Npb25zXG4gICAgaWYgKHBlcm1pc3Npb25zKSB7XG4gICAgICB0aGlzLmF0dGFjaFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgICB9XG5cbiAgICByb290LnJlZ2lzdGVyTGFtYmRhSGFuZGxlcih7XG4gICAgICBidW5kbGU6IHByb3BzLmJ1bmRsZSEsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgcnVudGltZTogcnVudGltZS50b1N0cmluZygpLFxuICAgICAgc3JjUGF0aCxcbiAgICB9KTtcbiAgICB0aGlzLl9pc0xpdmVEZXZFbmFibGVkID0gaXNMaXZlRGV2RW5hYmxlZDtcbiAgICB0aGlzLmxvY2FsSWQgPSBsb2NhbElkO1xuICB9XG5cbiAgcHVibGljIGF0dGFjaFBlcm1pc3Npb25zKHBlcm1pc3Npb25zOiBQZXJtaXNzaW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJvbGUpIHtcbiAgICAgIGF0dGFjaFBlcm1pc3Npb25zVG9Sb2xlKHRoaXMucm9sZSBhcyBpYW0uUm9sZSwgcGVybWlzc2lvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRDb25zdHJ1Y3RNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGdW5jdGlvblwiIGFzIGNvbnN0LFxuICAgICAgZGF0YToge1xuICAgICAgICBsb2NhbElkOiB0aGlzLmxvY2FsSWQsXG4gICAgICAgIGFybjogdGhpcy5mdW5jdGlvbkFybixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBub3JtYWxpemVTcmNQYXRoKHNyY1BhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHNyY1BhdGgucmVwbGFjZSgvXFwvKyQvLCBcIlwiKTtcbiAgfVxuXG4gIHN0YXRpYyBjb3B5RmlsZXMoXG4gICAgYnVuZGxlOiBGdW5jdGlvbkJ1bmRsZVByb3AgfCB1bmRlZmluZWQsXG4gICAgc3JjUGF0aDogc3RyaW5nLFxuICAgIGJ1aWxkUGF0aDogc3RyaW5nXG4gICkge1xuICAgIGlmICghYnVuZGxlKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBidW5kbGUgPT09IFwiYm9vbGVhblwiKSByZXR1cm47XG4gICAgaWYgKCFidW5kbGUuY29weUZpbGVzKSByZXR1cm47XG5cbiAgICBidW5kbGUuY29weUZpbGVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBmcm9tUGF0aCA9IHBhdGguam9pbihzcmNQYXRoLCBlbnRyeS5mcm9tKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhmcm9tUGF0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVHJpZWQgdG8gY29weSBub25leGlzdGVudCBmaWxlIGZyb20gXCIke3BhdGgucmVzb2x2ZShcbiAgICAgICAgICAgIGZyb21QYXRoXG4gICAgICAgICAgKX1cIiAtIGNoZWNrIGNvcHlGaWxlcyBlbnRyeSBcIiR7ZW50cnkuZnJvbX1cImBcbiAgICAgICAgKTtcbiAgICAgIGNvbnN0IHRvID0gZW50cnkudG8gfHwgZW50cnkuZnJvbTtcbiAgICAgIGlmIChwYXRoLmlzQWJzb2x1dGUodG8pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvcHkgZGVzdGluYXRpb24gcGF0aCBcIiR7dG99XCIgbXVzdCBiZSByZWxhdGl2ZWApO1xuICAgICAgY29uc3QgdG9QYXRoID0gcGF0aC5qb2luKGJ1aWxkUGF0aCwgdG8pO1xuICAgICAgZnMuY29weVN5bmMoZnJvbVBhdGgsIHRvUGF0aCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgaGFuZGxlSW1wb3J0ZWRMYXllcnMoXG4gICAgc2NvcGU6IENvbnN0cnVjdCxcbiAgICBsYXllcnM6IGxhbWJkYS5JTGF5ZXJWZXJzaW9uW11cbiAgKTogbGFtYmRhLklMYXllclZlcnNpb25bXSB7XG4gICAgcmV0dXJuIGxheWVycy5tYXAoKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBsYXllclN0YWNrID0gU3RhY2sub2YobGF5ZXIpO1xuICAgICAgY29uc3QgY3VycmVudFN0YWNrID0gU3RhY2sub2Yoc2NvcGUpO1xuICAgICAgLy8gVXNlIGxheWVyIGRpcmVjdGx5IGlmOlxuICAgICAgLy8gLSBsYXllciBpcyBjcmVhdGVkIGluIHRoZSBjdXJyZW50IHN0YWNrOyBPUlxuICAgICAgLy8gLSBsYXllciBpcyBpbXBvcnRlZCAoaWUuIGxheWVyQXJuIGlzIGEgc3RyaW5nKVxuICAgICAgaWYgKFxuICAgICAgICBsYXllclN0YWNrID09PSBjdXJyZW50U3RhY2sgfHxcbiAgICAgICAgIWNkay5Ub2tlbi5pc1VucmVzb2x2ZWQobGF5ZXIubGF5ZXJWZXJzaW9uQXJuKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICAgIC8vIGxheWVyIGlzIGNyZWF0ZWQgZnJvbSBhbm90aGVyIHN0YWNrXG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gc2V0IHN0YWNrIGRlcGVuZGVuY3kgYi9jIGxheWVyU3RhY2sgbmVlZCB0byBjcmVhdGUgdGhlIFNTTSBmaXJzdFxuICAgICAgICBjdXJyZW50U3RhY2suYWRkRGVwZW5kZW5jeShsYXllclN0YWNrKTtcbiAgICAgICAgLy8gc3RvcmUgbGF5ZXIgQVJOIGluIFNTTSBpbiBsYXllcidzIHN0YWNrXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcklkID0gYCR7bGF5ZXIubm9kZS5pZH1Bcm4tJHtsYXllci5ub2RlLmFkZHJ9YDtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyTmFtZSA9IGAvbGF5ZXJzLyR7bGF5ZXJTdGFjay5ub2RlLmlkfS8ke3BhcmFtZXRlcklkfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU3NtUGFyYW0gPSBsYXllclN0YWNrLm5vZGUudHJ5RmluZENoaWxkKHBhcmFtZXRlcklkKTtcbiAgICAgICAgaWYgKCFleGlzdGluZ1NzbVBhcmFtKSB7XG4gICAgICAgICAgbmV3IHNzbS5TdHJpbmdQYXJhbWV0ZXIobGF5ZXJTdGFjaywgcGFyYW1ldGVySWQsIHtcbiAgICAgICAgICAgIHBhcmFtZXRlck5hbWUsXG4gICAgICAgICAgICBzdHJpbmdWYWx1ZTogbGF5ZXIubGF5ZXJWZXJzaW9uQXJuLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGltcG9ydCBsYXllciBmcm9tIFNTTSB2YWx1ZVxuICAgICAgICBjb25zdCBsYXllcklkID0gYEkke2xheWVyLm5vZGUuaWR9LSR7bGF5ZXIubm9kZS5hZGRyfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTGF5ZXIgPSBzY29wZS5ub2RlLnRyeUZpbmRDaGlsZChsYXllcklkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdMYXllciBhcyBsYW1iZGEuTGF5ZXJWZXJzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsYW1iZGEuTGF5ZXJWZXJzaW9uLmZyb21MYXllclZlcnNpb25Bcm4oXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICBzc20uU3RyaW5nUGFyYW1ldGVyLnZhbHVlRm9yU3RyaW5nUGFyYW1ldGVyKHNjb3BlLCBwYXJhbWV0ZXJOYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRGVmaW5pdGlvbihcbiAgICBzY29wZTogQ29uc3RydWN0LFxuICAgIGlkOiBzdHJpbmcsXG4gICAgZGVmaW5pdGlvbjogRnVuY3Rpb25EZWZpbml0aW9uLFxuICAgIGluaGVyaXRlZFByb3BzPzogRnVuY3Rpb25Qcm9wcyxcbiAgICBpbmhlcml0RXJyb3JNZXNzYWdlPzogc3RyaW5nXG4gICk6IEZ1bmN0aW9uIHtcbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oc2NvcGUsIGlkLCB7XG4gICAgICAgIC4uLihpbmhlcml0ZWRQcm9wcyB8fCB7fSksXG4gICAgICAgIGhhbmRsZXI6IGRlZmluaXRpb24sXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgaWYgKGluaGVyaXRlZFByb3BzICYmIE9iamVjdC5rZXlzKGluaGVyaXRlZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBpbmhlcml0RXJyb3JNZXNzYWdlIHx8XG4gICAgICAgICAgICBgQ2Fubm90IGluaGVyaXQgZGVmYXVsdCBwcm9wcyB3aGVuIGEgRnVuY3Rpb24gaXMgcHJvdmlkZWRgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBsYW1iZGEuRnVuY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBsZWFzZSB1c2Ugc3N0LkZ1bmN0aW9uIGluc3RlYWQgb2YgbGFtYmRhLkZ1bmN0aW9uIGZvciB0aGUgXCIke2lkfVwiIEZ1bmN0aW9uLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoZGVmaW5pdGlvbiBhcyBGdW5jdGlvblByb3BzKS5oYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBpZCxcbiAgICAgICAgRnVuY3Rpb24ubWVyZ2VQcm9wcyhpbmhlcml0ZWRQcm9wcywgZGVmaW5pdGlvbilcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmdW5jdGlvbiBkZWZpbml0aW9uIGZvciB0aGUgXCIke2lkfVwiIEZ1bmN0aW9uYCk7XG4gIH1cblxuICBzdGF0aWMgbWVyZ2VQcm9wcyhcbiAgICBiYXNlUHJvcHM/OiBGdW5jdGlvblByb3BzLFxuICAgIHByb3BzPzogRnVuY3Rpb25Qcm9wc1xuICApOiBGdW5jdGlvblByb3BzIHtcbiAgICAvLyBNZXJnZSBlbnZpcm9ubWVudFxuICAgIGNvbnN0IGVudmlyb25tZW50ID0ge1xuICAgICAgLi4uKGJhc2VQcm9wcz8uZW52aXJvbm1lbnQgfHwge30pLFxuICAgICAgLi4uKHByb3BzPy5lbnZpcm9ubWVudCB8fCB7fSksXG4gICAgfTtcbiAgICBjb25zdCBlbnZpcm9ubWVudFByb3AgPVxuICAgICAgT2JqZWN0LmtleXMoZW52aXJvbm1lbnQpLmxlbmd0aCA9PT0gMCA/IHt9IDogeyBlbnZpcm9ubWVudCB9O1xuXG4gICAgLy8gTWVyZ2UgbGF5ZXJzXG4gICAgY29uc3QgbGF5ZXJzID0gWy4uLihiYXNlUHJvcHM/LmxheWVycyB8fCBbXSksIC4uLihwcm9wcz8ubGF5ZXJzIHx8IFtdKV07XG4gICAgY29uc3QgbGF5ZXJzUHJvcCA9IGxheWVycy5sZW5ndGggPT09IDAgPyB7fSA6IHsgbGF5ZXJzIH07XG5cbiAgICAvLyBNZXJnZSBwZXJtaXNzaW9uc1xuICAgIGxldCBwZXJtaXNzaW9uc1Byb3A7XG4gICAgaWYgKFxuICAgICAgYmFzZVByb3BzPy5wZXJtaXNzaW9ucyA9PT0gUGVybWlzc2lvblR5cGUuQUxMIHx8XG4gICAgICBwcm9wcz8ucGVybWlzc2lvbnMgPT09IFBlcm1pc3Npb25UeXBlLkFMTFxuICAgICkge1xuICAgICAgcGVybWlzc2lvbnNQcm9wID0geyBwZXJtaXNzaW9uczogUGVybWlzc2lvblR5cGUuQUxMIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gKGJhc2VQcm9wcz8ucGVybWlzc2lvbnMgfHwgW10pLmNvbmNhdChcbiAgICAgICAgcHJvcHM/LnBlcm1pc3Npb25zIHx8IFtdXG4gICAgICApO1xuICAgICAgcGVybWlzc2lvbnNQcm9wID0gcGVybWlzc2lvbnMubGVuZ3RoID09PSAwID8ge30gOiB7IHBlcm1pc3Npb25zIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLihiYXNlUHJvcHMgfHwge30pLFxuICAgICAgLi4uKHByb3BzIHx8IHt9KSxcbiAgICAgIC4uLmxheWVyc1Byb3AsXG4gICAgICAuLi5lbnZpcm9ubWVudFByb3AsXG4gICAgICAuLi5wZXJtaXNzaW9uc1Byb3AsXG4gICAgfTtcbiAgfVxufVxuIl19