"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const lambda = __importStar(require("@aws-cdk/aws-lambda"));
const builder_1 = require("./builder");
// Do not re-bundle dependencies for the same srcPath
// Note: if functions from different stacks have the same srcPath, we need to
//       generate the asset for each srcPath, because an asset is tied to a
//       stack. Otherwise, you will get this error:
//
//       Error: Asset is already associated with another stack 'xxxx'.
//              Create a new Code instance for every stack.
const existingBundlesByStackSrcPath = {};
function builder(builderProps) {
    const { stack, srcPath, handler, buildDir } = builderProps;
    const handlerPosixPath = (0, builder_1.getHandlerFullPosixPath)(srcPath, handler);
    console.log(chalk_1.default.grey(`Building Lambda function ${handler} in ${srcPath}`));
    // Check entry path exists
    // Case: invalid srcPath
    if (!fs.existsSync(srcPath)) {
        throw new Error(`Cannot find the srcPath "${srcPath}".`);
    }
    // On Windows, you cannot have ":" in a folder name
    const appPath = process.cwd();
    const handlerHash = (0, builder_1.getHandlerHash)(handlerPosixPath).replace(/::/g, "-");
    const outputPath = path.join(appPath, buildDir, handlerHash);
    // Compile
    let outCode;
    const stackSrcPath = `${stack}/${srcPath}`;
    if (existingBundlesByStackSrcPath[stackSrcPath]) {
        outCode = existingBundlesByStackSrcPath[stackSrcPath];
    }
    else {
        compile();
        outCode = lambda.Code.fromAsset(outputPath);
        existingBundlesByStackSrcPath[stackSrcPath] = outCode;
    }
    return {
        outCode,
        outHandler: handler,
    };
    function compile() {
        const response = cross_spawn_1.default.sync("dotnet", [
            "publish",
            "--output",
            outputPath,
            "--configuration",
            "Release",
            "--framework",
            "netcoreapp3.1",
            "/p:GenerateRuntimeConfigurationFiles=true",
            // warnings are not reported for repeated builds by default and this flag
            // does a clean before build. It takes a little longer to run, but the
            // warnings are consistently printed on each build.
            //"/target:Rebuild",
            "--self-contained",
            "false",
            // do not print "Build Engine version"
            "-nologo",
            // only print errors
            "--verbosity",
            process.env.DEBUG ? "minimal" : "quiet",
        ], {
            stdio: "inherit",
            cwd: path.join(appPath, srcPath),
        });
        if (response.status !== 0) {
            throw new Error(`There was an problem compiling the handler "${handler}" in "${srcPath}".`);
        }
    }
}
exports.builder = builder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG90bmV0QnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2RvdG5ldEJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUEwQjtBQUMxQiwyQ0FBNkI7QUFDN0IsNkNBQStCO0FBQy9CLDhEQUFnQztBQUNoQyw0REFBOEM7QUFDOUMsdUNBQW9FO0FBY3BFLHFEQUFxRDtBQUNyRCw2RUFBNkU7QUFDN0UsMkVBQTJFO0FBQzNFLG1EQUFtRDtBQUNuRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLDJEQUEyRDtBQUMzRCxNQUFNLDZCQUE2QixHQUUvQixFQUFFLENBQUM7QUFFUCxTQUFnQixPQUFPLENBQUMsWUFBMEI7SUFDaEQsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxHQUFHLFlBQVksQ0FBQztJQUMzRCxNQUFNLGdCQUFnQixHQUFHLElBQUEsaUNBQXVCLEVBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRW5FLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBSyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsT0FBTyxPQUFPLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUU3RSwwQkFBMEI7SUFDMUIsd0JBQXdCO0lBQ3hCLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLE9BQU8sSUFBSSxDQUFDLENBQUM7S0FDMUQ7SUFFRCxtREFBbUQ7SUFDbkQsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQzlCLE1BQU0sV0FBVyxHQUFHLElBQUEsd0JBQWMsRUFBQyxnQkFBZ0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDekUsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBRTdELFVBQVU7SUFDVixJQUFJLE9BQXlCLENBQUM7SUFDOUIsTUFBTSxZQUFZLEdBQUcsR0FBRyxLQUFLLElBQUksT0FBTyxFQUFFLENBQUM7SUFDM0MsSUFBSSw2QkFBNkIsQ0FBQyxZQUFZLENBQUMsRUFBRTtRQUMvQyxPQUFPLEdBQUcsNkJBQTZCLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDdkQ7U0FBTTtRQUNMLE9BQU8sRUFBRSxDQUFDO1FBQ1YsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzVDLDZCQUE2QixDQUFDLFlBQVksQ0FBQyxHQUFHLE9BQU8sQ0FBQztLQUN2RDtJQUVELE9BQU87UUFDTCxPQUFPO1FBQ1AsVUFBVSxFQUFFLE9BQU87S0FDcEIsQ0FBQztJQUVGLFNBQVMsT0FBTztRQUNkLE1BQU0sUUFBUSxHQUFHLHFCQUFLLENBQUMsSUFBSSxDQUN6QixRQUFRLEVBQ1I7WUFDRSxTQUFTO1lBQ1QsVUFBVTtZQUNWLFVBQVU7WUFDVixpQkFBaUI7WUFDakIsU0FBUztZQUNULGFBQWE7WUFDYixlQUFlO1lBQ2YsMkNBQTJDO1lBQzNDLHlFQUF5RTtZQUN6RSxzRUFBc0U7WUFDdEUsbURBQW1EO1lBQ25ELG9CQUFvQjtZQUNwQixrQkFBa0I7WUFDbEIsT0FBTztZQUNQLHNDQUFzQztZQUN0QyxTQUFTO1lBQ1Qsb0JBQW9CO1lBQ3BCLGFBQWE7WUFDYixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPO1NBQ3hDLEVBQ0Q7WUFDRSxLQUFLLEVBQUUsU0FBUztZQUNoQixHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDO1NBQ2pDLENBQ0YsQ0FBQztRQUVGLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDekIsTUFBTSxJQUFJLEtBQUssQ0FDYiwrQ0FBK0MsT0FBTyxTQUFTLE9BQU8sSUFBSSxDQUMzRSxDQUFDO1NBQ0g7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQXJFRCwwQkFxRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCBzcGF3biBmcm9tIFwiY3Jvc3Mtc3Bhd25cIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiQGF3cy1jZGsvYXdzLWxhbWJkYVwiO1xuaW1wb3J0IHsgZ2V0SGFuZGxlckZ1bGxQb3NpeFBhdGgsIGdldEhhbmRsZXJIYXNoIH0gZnJvbSBcIi4vYnVpbGRlclwiO1xuXG5pbnRlcmZhY2UgQnVpbGRlclByb3BzIHtcbiAgcmVhZG9ubHkgc3RhY2s6IHN0cmluZztcbiAgcmVhZG9ubHkgc3JjUGF0aDogc3RyaW5nO1xuICByZWFkb25seSBoYW5kbGVyOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGJ1aWxkRGlyOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBCdWlsZGVyT3V0cHV0IHtcbiAgcmVhZG9ubHkgb3V0Q29kZTogbGFtYmRhLkFzc2V0Q29kZTtcbiAgcmVhZG9ubHkgb3V0SGFuZGxlcjogc3RyaW5nO1xufVxuXG4vLyBEbyBub3QgcmUtYnVuZGxlIGRlcGVuZGVuY2llcyBmb3IgdGhlIHNhbWUgc3JjUGF0aFxuLy8gTm90ZTogaWYgZnVuY3Rpb25zIGZyb20gZGlmZmVyZW50IHN0YWNrcyBoYXZlIHRoZSBzYW1lIHNyY1BhdGgsIHdlIG5lZWQgdG9cbi8vICAgICAgIGdlbmVyYXRlIHRoZSBhc3NldCBmb3IgZWFjaCBzcmNQYXRoLCBiZWNhdXNlIGFuIGFzc2V0IGlzIHRpZWQgdG8gYVxuLy8gICAgICAgc3RhY2suIE90aGVyd2lzZSwgeW91IHdpbGwgZ2V0IHRoaXMgZXJyb3I6XG4vL1xuLy8gICAgICAgRXJyb3I6IEFzc2V0IGlzIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGFub3RoZXIgc3RhY2sgJ3h4eHgnLlxuLy8gICAgICAgICAgICAgIENyZWF0ZSBhIG5ldyBDb2RlIGluc3RhbmNlIGZvciBldmVyeSBzdGFjay5cbmNvbnN0IGV4aXN0aW5nQnVuZGxlc0J5U3RhY2tTcmNQYXRoOiB7XG4gIFtzdGFja1NyY1BhdGg6IHN0cmluZ106IGxhbWJkYS5Bc3NldENvZGU7XG59ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZGVyKGJ1aWxkZXJQcm9wczogQnVpbGRlclByb3BzKTogQnVpbGRlck91dHB1dCB7XG4gIGNvbnN0IHsgc3RhY2ssIHNyY1BhdGgsIGhhbmRsZXIsIGJ1aWxkRGlyIH0gPSBidWlsZGVyUHJvcHM7XG4gIGNvbnN0IGhhbmRsZXJQb3NpeFBhdGggPSBnZXRIYW5kbGVyRnVsbFBvc2l4UGF0aChzcmNQYXRoLCBoYW5kbGVyKTtcblxuICBjb25zb2xlLmxvZyhjaGFsay5ncmV5KGBCdWlsZGluZyBMYW1iZGEgZnVuY3Rpb24gJHtoYW5kbGVyfSBpbiAke3NyY1BhdGh9YCkpO1xuXG4gIC8vIENoZWNrIGVudHJ5IHBhdGggZXhpc3RzXG4gIC8vIENhc2U6IGludmFsaWQgc3JjUGF0aFxuICBpZiAoIWZzLmV4aXN0c1N5bmMoc3JjUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIHRoZSBzcmNQYXRoIFwiJHtzcmNQYXRofVwiLmApO1xuICB9XG5cbiAgLy8gT24gV2luZG93cywgeW91IGNhbm5vdCBoYXZlIFwiOlwiIGluIGEgZm9sZGVyIG5hbWVcbiAgY29uc3QgYXBwUGF0aCA9IHByb2Nlc3MuY3dkKCk7XG4gIGNvbnN0IGhhbmRsZXJIYXNoID0gZ2V0SGFuZGxlckhhc2goaGFuZGxlclBvc2l4UGF0aCkucmVwbGFjZSgvOjovZywgXCItXCIpO1xuICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKGFwcFBhdGgsIGJ1aWxkRGlyLCBoYW5kbGVySGFzaCk7XG5cbiAgLy8gQ29tcGlsZVxuICBsZXQgb3V0Q29kZTogbGFtYmRhLkFzc2V0Q29kZTtcbiAgY29uc3Qgc3RhY2tTcmNQYXRoID0gYCR7c3RhY2t9LyR7c3JjUGF0aH1gO1xuICBpZiAoZXhpc3RpbmdCdW5kbGVzQnlTdGFja1NyY1BhdGhbc3RhY2tTcmNQYXRoXSkge1xuICAgIG91dENvZGUgPSBleGlzdGluZ0J1bmRsZXNCeVN0YWNrU3JjUGF0aFtzdGFja1NyY1BhdGhdO1xuICB9IGVsc2Uge1xuICAgIGNvbXBpbGUoKTtcbiAgICBvdXRDb2RlID0gbGFtYmRhLkNvZGUuZnJvbUFzc2V0KG91dHB1dFBhdGgpO1xuICAgIGV4aXN0aW5nQnVuZGxlc0J5U3RhY2tTcmNQYXRoW3N0YWNrU3JjUGF0aF0gPSBvdXRDb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRDb2RlLFxuICAgIG91dEhhbmRsZXI6IGhhbmRsZXIsXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHNwYXduLnN5bmMoXG4gICAgICBcImRvdG5ldFwiLFxuICAgICAgW1xuICAgICAgICBcInB1Ymxpc2hcIixcbiAgICAgICAgXCItLW91dHB1dFwiLFxuICAgICAgICBvdXRwdXRQYXRoLFxuICAgICAgICBcIi0tY29uZmlndXJhdGlvblwiLFxuICAgICAgICBcIlJlbGVhc2VcIixcbiAgICAgICAgXCItLWZyYW1ld29ya1wiLFxuICAgICAgICBcIm5ldGNvcmVhcHAzLjFcIixcbiAgICAgICAgXCIvcDpHZW5lcmF0ZVJ1bnRpbWVDb25maWd1cmF0aW9uRmlsZXM9dHJ1ZVwiLFxuICAgICAgICAvLyB3YXJuaW5ncyBhcmUgbm90IHJlcG9ydGVkIGZvciByZXBlYXRlZCBidWlsZHMgYnkgZGVmYXVsdCBhbmQgdGhpcyBmbGFnXG4gICAgICAgIC8vIGRvZXMgYSBjbGVhbiBiZWZvcmUgYnVpbGQuIEl0IHRha2VzIGEgbGl0dGxlIGxvbmdlciB0byBydW4sIGJ1dCB0aGVcbiAgICAgICAgLy8gd2FybmluZ3MgYXJlIGNvbnNpc3RlbnRseSBwcmludGVkIG9uIGVhY2ggYnVpbGQuXG4gICAgICAgIC8vXCIvdGFyZ2V0OlJlYnVpbGRcIixcbiAgICAgICAgXCItLXNlbGYtY29udGFpbmVkXCIsXG4gICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgLy8gZG8gbm90IHByaW50IFwiQnVpbGQgRW5naW5lIHZlcnNpb25cIlxuICAgICAgICBcIi1ub2xvZ29cIixcbiAgICAgICAgLy8gb25seSBwcmludCBlcnJvcnNcbiAgICAgICAgXCItLXZlcmJvc2l0eVwiLFxuICAgICAgICBwcm9jZXNzLmVudi5ERUJVRyA/IFwibWluaW1hbFwiIDogXCJxdWlldFwiLFxuICAgICAgXSxcbiAgICAgIHtcbiAgICAgICAgc3RkaW86IFwiaW5oZXJpdFwiLFxuICAgICAgICBjd2Q6IHBhdGguam9pbihhcHBQYXRoLCBzcmNQYXRoKSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlcmUgd2FzIGFuIHByb2JsZW0gY29tcGlsaW5nIHRoZSBoYW5kbGVyIFwiJHtoYW5kbGVyfVwiIGluIFwiJHtzcmNQYXRofVwiLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=