"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = exports.getEsbuildMetafileName = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const zip_local_1 = __importDefault(require("zip-local"));
const child_process_1 = require("child_process");
const lambda = __importStar(require("@aws-cdk/aws-lambda"));
const builder_1 = require("./builder");
// Do not re-install nodeModules for the same srcPath and nodeModules settings
const existingNodeModulesBySrcPathModules = {};
// A map of supported runtimes and esbuild targets
const esbuildTargetMap = {
    [lambda.Runtime.NODEJS.toString()]: "node12",
    [lambda.Runtime.NODEJS_4_3.toString()]: "node4",
    [lambda.Runtime.NODEJS_6_10.toString()]: "node6",
    [lambda.Runtime.NODEJS_8_10.toString()]: "node8",
    [lambda.Runtime.NODEJS_10_X.toString()]: "node10",
    [lambda.Runtime.NODEJS_12_X.toString()]: "node12",
    [lambda.Runtime.NODEJS_14_X.toString()]: "node14",
};
function getEsbuildMetafileName(handler) {
    const key = handler.replace(/[/.]/g, "-");
    return `.esbuild.${key}.json`;
}
exports.getEsbuildMetafileName = getEsbuildMetafileName;
function getEsbuildExternal(srcPath, bundle) {
    let externals = ["aws-sdk"];
    if (bundle) {
        return [
            ...externals,
            ...(bundle.externalModules || []),
            ...(bundle.nodeModules || []),
        ];
    }
    try {
        const packageJson = fs.readJsonSync(path.join(srcPath, "package.json"));
        externals = Object.keys(Object.assign(Object.assign(Object.assign({}, (packageJson.dependencies || {})), (packageJson.devDependencies || {})), (packageJson.peerDependencies || {})));
    }
    catch (e) {
        console.log(chalk_1.default.grey(`No package.json found in ${srcPath}`));
    }
    return externals;
}
function getEsbuildLoader(bundle) {
    if (bundle) {
        return bundle.loader || {};
    }
    return undefined;
}
/**
 * Extract versions for a list of modules.
 *
 * First lookup the version in the package.json and then fallback to requiring
 * the module's package.json. The fallback is needed for transitive dependencies.
 */
function extractDependencies(pkgPath, modules) {
    var _a, _b, _c, _d;
    const dependencies = {};
    const pkgJson = fs.readJsonSync(pkgPath);
    const pkgDependencies = Object.assign(Object.assign(Object.assign({}, ((_a = pkgJson.dependencies) !== null && _a !== void 0 ? _a : {})), ((_b = pkgJson.devDependencies) !== null && _b !== void 0 ? _b : {})), ((_c = pkgJson.peerDependencies) !== null && _c !== void 0 ? _c : {}));
    for (const mod of modules) {
        try {
            const version = (_d = pkgDependencies[mod]) !== null && _d !== void 0 ? _d : require(`${mod}/package.json`).version; // eslint-disable-line @typescript-eslint/no-var-requires
            dependencies[mod] = version;
        }
        catch (err) {
            throw new Error(`Cannot extract version for module '${mod}'. Check that it's referenced in your package.json or installed.`);
        }
    }
    return dependencies;
}
function builder(builderProps) {
    const { runtime, bundle, srcPath, handler, buildDir, esbuildConfig } = builderProps;
    const handlerPosixPath = (0, builder_1.getHandlerFullPosixPath)(srcPath, handler);
    console.log(chalk_1.default.grey(`Building Lambda function ${handlerPosixPath}`));
    // Check has tsconfig
    const tsconfig = path.join(srcPath, "tsconfig.json");
    const hasTsconfig = fs.existsSync(tsconfig);
    // Check entry path exists
    let entryPath = "";
    const entryPathExists = [".ts", ".tsx", ".js", ".jsx"].some((ext) => {
        entryPath = path.join(srcPath, (0, builder_1.addExtensionToHandler)(handler, ext));
        return fs.existsSync(entryPath);
    });
    if (!entryPathExists) {
        throw new Error(`Cannot find a handler file for "${handlerPosixPath}".`);
    }
    // Four cases:
    //  1. BUNDLE + srcPath ROOT
    //      src       : path/to/file.method
    //      buildPath : .build/hash-$ts
    //      outCode   : .build/hash-$ts
    //      outHandler: file.method
    //
    //  2. BUNDLE + srcPath NON-ROOT
    //      src       : srcPath/path/to/file.method
    //      buildPath : srcPath/.build/hash-$ts
    //      outCode   : srcPath/.build/hash-$ts
    //      outHandler: file.method
    //
    //  3. non-BUNDLE + srcPath ROOT
    //      src       : path/to/file.method
    //      buildPath : .build/handlerDir
    //      outCode   : .
    //
    //     Note: This case is NOT SUPPORTED because we need to zip the app root for each
    //           handler. So after a Lambda's zip is generated, the next Lambda's zip will
    //           contain the previous Lambda's zip inside .build, and the previous Lambda's
    //           zip inside cdk.out.
    //
    //           One solution would be to cherry pick what to zip. For example, zip should
    //           only include the esbuid's output (ie. .js and .js.map files) from the
    //           .build folder.
    //
    //           Also need to clear all .build folders generated from Lambda functions that
    //           has srcPath.
    //
    //  4. non-BUNDLE + srcPath NON-ROOT
    //      src       : srcPath/path/to/file.method
    //      buildPath : srcPath/.build/hash-$ts
    //      zipInput  : srcPath
    //      zipOutput : .build/hash-$ts.zip
    //      outCode   : .build/hash-$ts.zip
    //      outHandler: .build/hash-$ts/file.method
    //
    //     Note:
    //       If `bundle` is disabled, we need to zip manually. Because the same
    //       `srcPath` is zipped for each handler, and CDK asset would only zip
    //       it once. So the rest of Lambda zips do not contain the output handler file.
    //
    //       Place outZip at the app root's .build because entire srcPath is zipped up.
    //       If outZip is srcPath's .build, a Lambda's zip would include zip files from
    //       all the previous Lambdas.
    const appPath = process.cwd();
    const handlerHash = (0, builder_1.getHandlerHash)(handlerPosixPath);
    const buildPath = path.join(srcPath, buildDir, handlerHash);
    const metafile = path.join(srcPath, buildDir, getEsbuildMetafileName(handler));
    // Command hook: before bundling
    runBeforeBundling(bundle);
    // Transpile
    transpile(entryPath, bundle, esbuildConfig);
    // Command hook: before install
    runBeforeInstall(bundle);
    // Package nodeModules
    installNodeModules(srcPath, bundle);
    // Command hook: after bundling
    runAfterBundling(bundle);
    // Format response
    let outCode, outHandler;
    if (bundle) {
        outCode = lambda.Code.fromAsset(buildPath);
        outHandler = path
            // Preserve file structure of source file
            .join(path.dirname(entryPath), path.basename(handler))
            .split(path.sep)
            .join(path.posix.sep);
    }
    else {
        const zipFile = path.join(appPath, buildDir, `${handlerHash}.zip`);
        zip(srcPath, zipFile);
        outCode = lambda.Code.fromAsset(zipFile);
        outHandler = `${buildDir}/${handlerHash}/${path.basename(handler)}`;
    }
    return { outCode, outHandler };
    ///////////////
    // Functions //
    ///////////////
    function transpile(entryPath, bundle, appEsbuildConfig) {
        // Build default esbuild config
        const defaultConfig = {
            external: getEsbuildExternal(srcPath, bundle),
            loader: getEsbuildLoader(bundle),
            metafile: true,
            bundle: true,
            minify: typeof bundle === "boolean" || bundle.minify !== false,
            format: "cjs",
            sourcemap: true,
            platform: "node",
            target: [esbuildTargetMap[runtime.toString()] || "node12"],
            outdir: path.join(buildPath, path.dirname(entryPath)),
            entryPoints: [entryPath],
            color: process.env.NO_COLOR !== "true",
            tsconfig: hasTsconfig ? tsconfig : undefined,
            logLevel: process.env.DEBUG ? "warning" : "error",
        };
        // Get custom esbuild config
        bundle = bundle;
        // We need to deep clone so we don't run into mutation issues
        let customConfig = JSON.parse(JSON.stringify(appEsbuildConfig || bundle.esbuildConfig || {}));
        // note: "esbuildConfig" used to take a string, a path to the user
        //       provided config file. With the new format, esbuildConfig is
        //       configured inline, and the external file can only be used
        //       to return "plugins" field.
        if (typeof customConfig === "string") {
            customConfig = { plugins: customConfig };
        }
        // Validate fields
        const disallowedKey = Object.keys(customConfig).find((key) => !["define", "keepNames", "plugins"].includes(key));
        if (disallowedKey) {
            throw new Error(`Cannot configure the "${disallowedKey}" option in "bundle.esbuildConfig". Only "define", "keepNames", and "plugins" options are currently supported.`);
        }
        // Validate custom esbuild plugins path
        if (customConfig && customConfig.plugins) {
            customConfig.plugins = path.join(appPath, customConfig.plugins);
            if (!fs.existsSync(customConfig.plugins)) {
                throw new Error(`Cannot find the esbuild config file at "${customConfig.plugins}"`);
            }
        }
        // Build esbuild command
        // Note: probably could pass JSON string also, but this felt safer.
        const esbuildScript = path.join(__dirname, "../../assets/nodejs/esbuild.js");
        const cmd = [
            "node",
            esbuildScript,
            "--config",
            Buffer.from(JSON.stringify(defaultConfig)).toString("base64"),
            "--metafile",
            metafile,
            "--overrides",
            Buffer.from(JSON.stringify(customConfig)).toString("base64"),
        ].join(" ");
        // Run esbuild
        try {
            (0, child_process_1.execSync)(cmd, {
                cwd: appPath,
                stdio: "inherit",
            });
        }
        catch (e) {
            throw chalk_1.default.red(`There was a problem transpiling the Lambda handler.`);
        }
    }
    function installNodeModules(srcPath, bundle) {
        // Validate 'nodeModules' is defined in bundle options
        bundle = bundle;
        if (!bundle || !bundle.nodeModules || bundle.nodeModules.length === 0) {
            return;
        }
        // If nodeModules have been installed for the same srcPath, copy the
        // "node_modules" folder over. Do not re-install.
        const modulesStr = JSON.stringify(bundle.nodeModules.slice().sort());
        const srcPathModules = `${srcPath}/${modulesStr}`;
        const existingPath = existingNodeModulesBySrcPathModules[srcPathModules];
        if (existingPath) {
            fs.copySync(path.join(existingPath, "node_modules"), path.join(buildPath, "node_modules"));
            return;
        }
        // Find 'package.json' at handler's srcPath.
        const pkgPath = path.join(srcPath, "package.json");
        if (!fs.existsSync(pkgPath)) {
            throw new Error(`Cannot find a "package.json" in the function's srcPath: ${path.resolve(srcPath)}`);
        }
        // Determine dependencies versions, lock file and installer
        const dependencies = extractDependencies(pkgPath, bundle.nodeModules);
        let installer = "npm";
        let lockFile;
        if (fs.existsSync(path.join(srcPath, "package-lock.json"))) {
            installer = "npm";
            lockFile = "package-lock.json";
        }
        else if (fs.existsSync(path.join(srcPath, "yarn.lock"))) {
            installer = "yarn";
            lockFile = "yarn.lock";
        }
        // Create dummy package.json, copy lock file if any and then install
        const outputPath = path.join(buildPath, "package.json");
        fs.ensureFileSync(outputPath);
        fs.writeJsonSync(outputPath, { dependencies });
        if (lockFile) {
            fs.copySync(path.join(srcPath, lockFile), path.join(buildPath, lockFile));
        }
        // Install dependencies
        try {
            (0, child_process_1.execSync)(`${installer} install`, {
                cwd: buildPath,
                stdio: "pipe",
            });
        }
        catch (e) {
            console.log(chalk_1.default.red(`There was a problem installing nodeModules.`));
            throw e;
        }
        // Store the path to the installed "node_modules"
        if (fs.existsSync(path.join(buildPath, "node_modules"))) {
            existingNodeModulesBySrcPathModules[srcPathModules] =
                path.resolve(buildPath);
        }
    }
    function runBeforeBundling(bundle) {
        var _a, _b;
        // Build command
        bundle = bundle;
        const cmds = (_b = (_a = bundle.commandHooks) === null || _a === void 0 ? void 0 : _a.beforeBundling(srcPath, buildPath)) !== null && _b !== void 0 ? _b : [];
        if (cmds.length === 0) {
            return;
        }
        try {
            (0, child_process_1.execSync)(cmds.join(" && "), {
                cwd: srcPath,
                stdio: "pipe",
            });
        }
        catch (e) {
            console.log(chalk_1.default.red(`There was a problem running "beforeBundling" command.`));
            throw e;
        }
    }
    function runBeforeInstall(bundle) {
        var _a, _b;
        // Build command
        bundle = bundle;
        const cmds = (_b = (_a = bundle.commandHooks) === null || _a === void 0 ? void 0 : _a.beforeInstall(srcPath, buildPath)) !== null && _b !== void 0 ? _b : [];
        if (cmds.length === 0) {
            return;
        }
        try {
            (0, child_process_1.execSync)(cmds.join(" && "), {
                cwd: srcPath,
                stdio: "pipe",
            });
        }
        catch (e) {
            console.log(chalk_1.default.red(`There was a problem running "beforeInstall" command.`));
            throw e;
        }
    }
    function runAfterBundling(bundle) {
        var _a, _b;
        // Build command
        bundle = bundle;
        const cmds = (_b = (_a = bundle.commandHooks) === null || _a === void 0 ? void 0 : _a.afterBundling(srcPath, buildPath)) !== null && _b !== void 0 ? _b : [];
        if (cmds.length === 0) {
            return;
        }
        try {
            (0, child_process_1.execSync)(cmds.join(" && "), {
                cwd: srcPath,
                stdio: "pipe",
            });
        }
        catch (e) {
            console.log(chalk_1.default.red(`There was a problem running "afterBundling" command.`));
            throw e;
        }
    }
    function zip(dir, zipFile) {
        try {
            zip_local_1.default.sync.zip(dir).compress().save(zipFile);
        }
        catch (e) {
            console.log(e);
            throw new Error("There was a problem generating Lambda package.");
        }
        return zipFile;
    }
}
exports.builder = builder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZUJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbC9ub2RlQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0RBQTBCO0FBQzFCLDJDQUE2QjtBQUM3Qiw2Q0FBK0I7QUFDL0IsMERBQWlDO0FBRWpDLGlEQUF5QztBQUN6Qyw0REFBOEM7QUFFOUMsdUNBSW1CO0FBRW5CLDhFQUE4RTtBQUM5RSxNQUFNLG1DQUFtQyxHQUVyQyxFQUFFLENBQUM7QUFFUCxrREFBa0Q7QUFDbEQsTUFBTSxnQkFBZ0IsR0FBRztJQUN2QixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtJQUM1QyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsT0FBTztJQUMvQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsT0FBTztJQUNoRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsT0FBTztJQUNoRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtJQUNqRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtJQUNqRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtDQUNsRCxDQUFDO0FBZ0JGLFNBQWdCLHNCQUFzQixDQUFDLE9BQWU7SUFDcEQsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDMUMsT0FBTyxZQUFZ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QUM7WUFDRixNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztJQUVELFNBQVMsZ0JBQWdCLENBQUMsTUFBMkM7O1FBQ25FLGdCQUFnQjtRQUNoQixNQUFNLEdBQUcsTUFBbUMsQ0FBQztRQUM3QyxNQUFNLElBQUksR0FBRyxNQUFBLE1BQUEsTUFBTSxDQUFDLFlBQVksMENBQUUsYUFBYSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsbUNBQUksRUFBRSxDQUFDO1FBQzFFLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTztTQUNSO1FBRUQsSUFBSTtZQUNGLElBQUEsd0JBQVEsRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUMxQixHQUFHLEVBQUUsT0FBTztnQkFDWixLQUFLLEVBQUUsTUFBTTthQUNkLENBQUMsQ0FBQztTQUNKO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLENBQUMsR0FBRyxDQUNULGVBQUssQ0FBQyxHQUFHLENBQUMsc0RBQXNELENBQUMsQ0FDbEUsQ0FBQztZQUNGLE1BQU0sQ0FBQyxDQUFDO1NBQ1Q7SUFDSCxDQUFDO0lBRUQsU0FBUyxHQUFHLENBQUMsR0FBVyxFQUFFLE9BQWU7UUFDdkMsSUFBSTtZQUNGLG1CQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDakQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDZixNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7U0FDbkU7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0FBQ0gsQ0FBQztBQXpWRCwwQkF5VkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCB6aXBMb2NhbCBmcm9tIFwiemlwLWxvY2FsXCI7XG5pbXBvcnQgKiBhcyBlc2J1aWxkIGZyb20gXCJlc2J1aWxkXCI7XG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSBcIkBhd3MtY2RrL2F3cy1sYW1iZGFcIjtcbmltcG9ydCB7IEZ1bmN0aW9uQnVuZGxlTm9kZWpzUHJvcHMgfSBmcm9tIFwiLi4vRnVuY3Rpb25cIjtcbmltcG9ydCB7XG4gIGFkZEV4dGVuc2lvblRvSGFuZGxlcixcbiAgZ2V0SGFuZGxlckZ1bGxQb3NpeFBhdGgsXG4gIGdldEhhbmRsZXJIYXNoLFxufSBmcm9tIFwiLi9idWlsZGVyXCI7XG5cbi8vIERvIG5vdCByZS1pbnN0YWxsIG5vZGVNb2R1bGVzIGZvciB0aGUgc2FtZSBzcmNQYXRoIGFuZCBub2RlTW9kdWxlcyBzZXR0aW5nc1xuY29uc3QgZXhpc3RpbmdOb2RlTW9kdWxlc0J5U3JjUGF0aE1vZHVsZXM6IHtcbiAgW3NyY1BhdGhNb2R1bGVzOiBzdHJpbmddOiBzdHJpbmc7XG59ID0ge307XG5cbi8vIEEgbWFwIG9mIHN1cHBvcnRlZCBydW50aW1lcyBhbmQgZXNidWlsZCB0YXJnZXRzXG5jb25zdCBlc2J1aWxkVGFyZ2V0TWFwID0ge1xuICBbbGFtYmRhLlJ1bnRpbWUuTk9ERUpTLnRvU3RyaW5nKCldOiBcIm5vZGUxMlwiLFxuICBbbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzRfMy50b1N0cmluZygpXTogXCJub2RlNFwiLFxuICBbbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzZfMTAudG9TdHJpbmcoKV06IFwibm9kZTZcIixcbiAgW2xhbWJkYS5SdW50aW1lLk5PREVKU184XzEwLnRvU3RyaW5nKCldOiBcIm5vZGU4XCIsXG4gIFtsYW1iZGEuUnVudGltZS5OT0RFSlNfMTBfWC50b1N0cmluZygpXTogXCJub2RlMTBcIixcbiAgW2xhbWJkYS5SdW50aW1lLk5PREVKU18xMl9YLnRvU3RyaW5nKCldOiBcIm5vZGUxMlwiLFxuICBbbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzE0X1gudG9TdHJpbmcoKV06IFwibm9kZTE0XCIsXG59O1xuXG5pbnRlcmZhY2UgQnVpbGRlclByb3BzIHtcbiAgcmVhZG9ubHkgc3JjUGF0aDogc3RyaW5nO1xuICByZWFkb25seSBoYW5kbGVyOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGJ1aWxkRGlyOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lO1xuICByZWFkb25seSBlc2J1aWxkQ29uZmlnPzogc3RyaW5nO1xuICByZWFkb25seSBidW5kbGU6IGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzO1xufVxuXG5pbnRlcmZhY2UgQnVpbGRlck91dHB1dCB7XG4gIHJlYWRvbmx5IG91dENvZGU6IGxhbWJkYS5Bc3NldENvZGU7XG4gIHJlYWRvbmx5IG91dEhhbmRsZXI6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVzYnVpbGRNZXRhZmlsZU5hbWUoaGFuZGxlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qga2V5ID0gaGFuZGxlci5yZXBsYWNlKC9bLy5dL2csIFwiLVwiKTtcbiAgcmV0dXJuIGAuZXNidWlsZC4ke2tleX0uanNvbmA7XG59XG5cbmZ1bmN0aW9uIGdldEVzYnVpbGRFeHRlcm5hbChcbiAgc3JjUGF0aDogc3RyaW5nLFxuICBidW5kbGU6IGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzXG4pOiBBcnJheTxzdHJpbmc+IHtcbiAgbGV0IGV4dGVybmFscyA9IFtcImF3cy1zZGtcIl07XG5cbiAgaWYgKGJ1bmRsZSkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5leHRlcm5hbHMsXG4gICAgICAuLi4oKGJ1bmRsZSBhcyBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzKS5leHRlcm5hbE1vZHVsZXMgfHwgW10pLFxuICAgICAgLi4uKChidW5kbGUgYXMgRnVuY3Rpb25CdW5kbGVOb2RlanNQcm9wcykubm9kZU1vZHVsZXMgfHwgW10pLFxuICAgIF07XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHBhY2thZ2VKc29uID0gZnMucmVhZEpzb25TeW5jKHBhdGguam9pbihzcmNQYXRoLCBcInBhY2thZ2UuanNvblwiKSk7XG4gICAgZXh0ZXJuYWxzID0gT2JqZWN0LmtleXMoe1xuICAgICAgLi4uKHBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyB8fCB7fSksXG4gICAgICAuLi4ocGFja2FnZUpzb24uZGV2RGVwZW5kZW5jaWVzIHx8IHt9KSxcbiAgICAgIC4uLihwYWNrYWdlSnNvbi5wZWVyRGVwZW5kZW5jaWVzIHx8IHt9KSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKGNoYWxrLmdyZXkoYE5vIHBhY2thZ2UuanNvbiBmb3VuZCBpbiAke3NyY1BhdGh9YCkpO1xuICB9XG5cbiAgcmV0dXJuIGV4dGVybmFscztcbn1cblxuZnVuY3Rpb24gZ2V0RXNidWlsZExvYWRlcihcbiAgYnVuZGxlOiBib29sZWFuIHwgRnVuY3Rpb25CdW5kbGVOb2RlanNQcm9wc1xuKTogeyBbZXh0OiBzdHJpbmddOiBlc2J1aWxkLkxvYWRlciB9IHwgdW5kZWZpbmVkIHtcbiAgaWYgKGJ1bmRsZSkge1xuICAgIHJldHVybiAoYnVuZGxlIGFzIEZ1bmN0aW9uQnVuZGxlTm9kZWpzUHJvcHMpLmxvYWRlciB8fCB7fTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdmVyc2lvbnMgZm9yIGEgbGlzdCBvZiBtb2R1bGVzLlxuICpcbiAqIEZpcnN0IGxvb2t1cCB0aGUgdmVyc2lvbiBpbiB0aGUgcGFja2FnZS5qc29uIGFuZCB0aGVuIGZhbGxiYWNrIHRvIHJlcXVpcmluZ1xuICogdGhlIG1vZHVsZSdzIHBhY2thZ2UuanNvbi4gVGhlIGZhbGxiYWNrIGlzIG5lZWRlZCBmb3IgdHJhbnNpdGl2ZSBkZXBlbmRlbmNpZXMuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3REZXBlbmRlbmNpZXMoXG4gIHBrZ1BhdGg6IHN0cmluZyxcbiAgbW9kdWxlczogc3RyaW5nW11cbik6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICBjb25zdCBkZXBlbmRlbmNpZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcblxuICBjb25zdCBwa2dKc29uID0gZnMucmVhZEpzb25TeW5jKHBrZ1BhdGgpO1xuXG4gIGNvbnN0IHBrZ0RlcGVuZGVuY2llcyA9IHtcbiAgICAuLi4ocGtnSnNvbi5kZXBlbmRlbmNpZXMgPz8ge30pLFxuICAgIC4uLihwa2dKc29uLmRldkRlcGVuZGVuY2llcyA/PyB7fSksXG4gICAgLi4uKHBrZ0pzb24ucGVlckRlcGVuZGVuY2llcyA/PyB7fSksXG4gIH07XG5cbiAgZm9yIChjb25zdCBtb2Qgb2YgbW9kdWxlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID1cbiAgICAgICAgcGtnRGVwZW5kZW5jaWVzW21vZF0gPz8gcmVxdWlyZShgJHttb2R9L3BhY2thZ2UuanNvbmApLnZlcnNpb247IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgZGVwZW5kZW5jaWVzW21vZF0gPSB2ZXJzaW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGV4dHJhY3QgdmVyc2lvbiBmb3IgbW9kdWxlICcke21vZH0nLiBDaGVjayB0aGF0IGl0J3MgcmVmZXJlbmNlZCBpbiB5b3VyIHBhY2thZ2UuanNvbiBvciBpbnN0YWxsZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRlcihidWlsZGVyUHJvcHM6IEJ1aWxkZXJQcm9wcyk6IEJ1aWxkZXJPdXRwdXQge1xuICBjb25zdCB7IHJ1bnRpbWUsIGJ1bmRsZSwgc3JjUGF0aCwgaGFuZGxlciwgYnVpbGREaXIsIGVzYnVpbGRDb25maWcgfSA9XG4gICAgYnVpbGRlclByb3BzO1xuICBjb25zdCBoYW5kbGVyUG9zaXhQYXRoID0gZ2V0SGFuZGxlckZ1bGxQb3NpeFBhdGgoc3JjUGF0aCwgaGFuZGxlcik7XG5cbiAgY29uc29sZS5sb2coY2hhbGsuZ3JleShgQnVpbGRpbmcgTGFtYmRhIGZ1bmN0aW9uICR7aGFuZGxlclBvc2l4UGF0aH1gKSk7XG5cbiAgLy8gQ2hlY2sgaGFzIHRzY29uZmlnXG4gIGNvbnN0IHRzY29uZmlnID0gcGF0aC5qb2luKHNyY1BhdGgsIFwidHNjb25maWcuanNvblwiKTtcbiAgY29uc3QgaGFzVHNjb25maWcgPSBmcy5leGlzdHNTeW5jKHRzY29uZmlnKTtcblxuICAvLyBDaGVjayBlbnRyeSBwYXRoIGV4aXN0c1xuICBsZXQgZW50cnlQYXRoID0gXCJcIjtcbiAgY29uc3QgZW50cnlQYXRoRXhpc3RzID0gW1wiLnRzXCIsIFwiLnRzeFwiLCBcIi5qc1wiLCBcIi5qc3hcIl0uc29tZSgoZXh0KSA9PiB7XG4gICAgZW50cnlQYXRoID0gcGF0aC5qb2luKHNyY1BhdGgsIGFkZEV4dGVuc2lvblRvSGFuZGxlcihoYW5kbGVyLCBleHQpKTtcbiAgICByZXR1cm4gZnMuZXhpc3RzU3luYyhlbnRyeVBhdGgpO1xuICB9KTtcblxuICBpZiAoIWVudHJ5UGF0aEV4aXN0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYSBoYW5kbGVyIGZpbGUgZm9yIFwiJHtoYW5kbGVyUG9zaXhQYXRofVwiLmApO1xuICB9XG5cbiAgLy8gRm91ciBjYXNlczpcbiAgLy8gIDEuIEJVTkRMRSArIHNyY1BhdGggUk9PVFxuICAvLyAgICAgIHNyYyAgICAgICA6IHBhdGgvdG8vZmlsZS5tZXRob2RcbiAgLy8gICAgICBidWlsZFBhdGggOiAuYnVpbGQvaGFzaC0kdHNcbiAgLy8gICAgICBvdXRDb2RlICAgOiAuYnVpbGQvaGFzaC0kdHNcbiAgLy8gICAgICBvdXRIYW5kbGVyOiBmaWxlLm1ldGhvZFxuICAvL1xuICAvLyAgMi4gQlVORExFICsgc3JjUGF0aCBOT04tUk9PVFxuICAvLyAgICAgIHNyYyAgICAgICA6IHNyY1BhdGgvcGF0aC90by9maWxlLm1ldGhvZFxuICAvLyAgICAgIGJ1aWxkUGF0aCA6IHNyY1BhdGgvLmJ1aWxkL2hhc2gtJHRzXG4gIC8vICAgICAgb3V0Q29kZSAgIDogc3JjUGF0aC8uYnVpbGQvaGFzaC0kdHNcbiAgLy8gICAgICBvdXRIYW5kbGVyOiBmaWxlLm1ldGhvZFxuICAvL1xuICAvLyAgMy4gbm9uLUJVTkRMRSArIHNyY1BhdGggUk9PVFxuICAvLyAgICAgIHNyYyAgICAgICA6IHBhdGgvdG8vZmlsZS5tZXRob2RcbiAgLy8gICAgICBidWlsZFBhdGggOiAuYnVpbGQvaGFuZGxlckRpclxuICAvLyAgICAgIG91dENvZGUgICA6IC5cbiAgLy9cbiAgLy8gICAgIE5vdGU6IFRoaXMgY2FzZSBpcyBOT1QgU1VQUE9SVEVEIGJlY2F1c2Ugd2UgbmVlZCB0byB6aXAgdGhlIGFwcCByb290IGZvciBlYWNoXG4gIC8vICAgICAgICAgICBoYW5kbGVyLiBTbyBhZnRlciBhIExhbWJkYSdzIHppcCBpcyBnZW5lcmF0ZWQsIHRoZSBuZXh0IExhbWJkYSdzIHppcCB3aWxsXG4gIC8vICAgICAgICAgICBjb250YWluIHRoZSBwcmV2aW91cyBMYW1iZGEncyB6aXAgaW5zaWRlIC5idWlsZCwgYW5kIHRoZSBwcmV2aW91cyBMYW1iZGEnc1xuICAvLyAgICAgICAgICAgemlwIGluc2lkZSBjZGsub3V0LlxuICAvL1xuICAvLyAgICAgICAgICAgT25lIHNvbHV0aW9uIHdvdWxkIGJlIHRvIGNoZXJyeSBwaWNrIHdoYXQgdG8gemlwLiBGb3IgZXhhbXBsZSwgemlwIHNob3VsZFxuICAvLyAgICAgICAgICAgb25seSBpbmNsdWRlIHRoZSBlc2J1aWQncyBvdXRwdXQgKGllLiAuanMgYW5kIC5qcy5tYXAgZmlsZXMpIGZyb20gdGhlXG4gIC8vICAgICAgICAgICAuYnVpbGQgZm9sZGVyLlxuICAvL1xuICAvLyAgICAgICAgICAgQWxzbyBuZWVkIHRvIGNsZWFyIGFsbCAuYnVpbGQgZm9sZGVycyBnZW5lcmF0ZWQgZnJvbSBMYW1iZGEgZnVuY3Rpb25zIHRoYXRcbiAgLy8gICAgICAgICAgIGhhcyBzcmNQYXRoLlxuICAvL1xuICAvLyAgNC4gbm9uLUJVTkRMRSArIHNyY1BhdGggTk9OLVJPT1RcbiAgLy8gICAgICBzcmMgICAgICAgOiBzcmNQYXRoL3BhdGgvdG8vZmlsZS5tZXRob2RcbiAgLy8gICAgICBidWlsZFBhdGggOiBzcmNQYXRoLy5idWlsZC9oYXNoLSR0c1xuICAvLyAgICAgIHppcElucHV0ICA6IHNyY1BhdGhcbiAgLy8gICAgICB6aXBPdXRwdXQgOiAuYnVpbGQvaGFzaC0kdHMuemlwXG4gIC8vICAgICAgb3V0Q29kZSAgIDogLmJ1aWxkL2hhc2gtJHRzLnppcFxuICAvLyAgICAgIG91dEhhbmRsZXI6IC5idWlsZC9oYXNoLSR0cy9maWxlLm1ldGhvZFxuICAvL1xuICAvLyAgICAgTm90ZTpcbiAgLy8gICAgICAgSWYgYGJ1bmRsZWAgaXMgZGlzYWJsZWQsIHdlIG5lZWQgdG8gemlwIG1hbnVhbGx5LiBCZWNhdXNlIHRoZSBzYW1lXG4gIC8vICAgICAgIGBzcmNQYXRoYCBpcyB6aXBwZWQgZm9yIGVhY2ggaGFuZGxlciwgYW5kIENESyBhc3NldCB3b3VsZCBvbmx5IHppcFxuICAvLyAgICAgICBpdCBvbmNlLiBTbyB0aGUgcmVzdCBvZiBMYW1iZGEgemlwcyBkbyBub3QgY29udGFpbiB0aGUgb3V0cHV0IGhhbmRsZXIgZmlsZS5cbiAgLy9cbiAgLy8gICAgICAgUGxhY2Ugb3V0WmlwIGF0IHRoZSBhcHAgcm9vdCdzIC5idWlsZCBiZWNhdXNlIGVudGlyZSBzcmNQYXRoIGlzIHppcHBlZCB1cC5cbiAgLy8gICAgICAgSWYgb3V0WmlwIGlzIHNyY1BhdGgncyAuYnVpbGQsIGEgTGFtYmRhJ3MgemlwIHdvdWxkIGluY2x1ZGUgemlwIGZpbGVzIGZyb21cbiAgLy8gICAgICAgYWxsIHRoZSBwcmV2aW91cyBMYW1iZGFzLlxuXG4gIGNvbnN0IGFwcFBhdGggPSBwcm9jZXNzLmN3ZCgpO1xuICBjb25zdCBoYW5kbGVySGFzaCA9IGdldEhhbmRsZXJIYXNoKGhhbmRsZXJQb3NpeFBhdGgpO1xuICBjb25zdCBidWlsZFBhdGggPSBwYXRoLmpvaW4oc3JjUGF0aCwgYnVpbGREaXIsIGhhbmRsZXJIYXNoKTtcbiAgY29uc3QgbWV0YWZpbGUgPSBwYXRoLmpvaW4oXG4gICAgc3JjUGF0aCxcbiAgICBidWlsZERpcixcbiAgICBnZXRFc2J1aWxkTWV0YWZpbGVOYW1lKGhhbmRsZXIpXG4gICk7XG5cbiAgLy8gQ29tbWFuZCBob29rOiBiZWZvcmUgYnVuZGxpbmdcbiAgcnVuQmVmb3JlQnVuZGxpbmcoYnVuZGxlKTtcblxuICAvLyBUcmFuc3BpbGVcbiAgdHJhbnNwaWxlKGVudHJ5UGF0aCwgYnVuZGxlLCBlc2J1aWxkQ29uZmlnKTtcblxuICAvLyBDb21tYW5kIGhvb2s6IGJlZm9yZSBpbnN0YWxsXG4gIHJ1bkJlZm9yZUluc3RhbGwoYnVuZGxlKTtcblxuICAvLyBQYWNrYWdlIG5vZGVNb2R1bGVzXG4gIGluc3RhbGxOb2RlTW9kdWxlcyhzcmNQYXRoLCBidW5kbGUpO1xuXG4gIC8vIENvbW1hbmQgaG9vazogYWZ0ZXIgYnVuZGxpbmdcbiAgcnVuQWZ0ZXJCdW5kbGluZyhidW5kbGUpO1xuXG4gIC8vIEZvcm1hdCByZXNwb25zZVxuICBsZXQgb3V0Q29kZSwgb3V0SGFuZGxlcjtcbiAgaWYgKGJ1bmRsZSkge1xuICAgIG91dENvZGUgPSBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoYnVpbGRQYXRoKTtcbiAgICBvdXRIYW5kbGVyID0gcGF0aFxuICAgICAgLy8gUHJlc2VydmUgZmlsZSBzdHJ1Y3R1cmUgb2Ygc291cmNlIGZpbGVcbiAgICAgIC5qb2luKHBhdGguZGlybmFtZShlbnRyeVBhdGgpLCBwYXRoLmJhc2VuYW1lKGhhbmRsZXIpKVxuICAgICAgLnNwbGl0KHBhdGguc2VwKVxuICAgICAgLmpvaW4ocGF0aC5wb3NpeC5zZXApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHppcEZpbGUgPSBwYXRoLmpvaW4oYXBwUGF0aCwgYnVpbGREaXIsIGAke2hhbmRsZXJIYXNofS56aXBgKTtcbiAgICB6aXAoc3JjUGF0aCwgemlwRmlsZSk7XG4gICAgb3V0Q29kZSA9IGxhbWJkYS5Db2RlLmZyb21Bc3NldCh6aXBGaWxlKTtcbiAgICBvdXRIYW5kbGVyID0gYCR7YnVpbGREaXJ9LyR7aGFuZGxlckhhc2h9LyR7cGF0aC5iYXNlbmFtZShoYW5kbGVyKX1gO1xuICB9XG5cbiAgcmV0dXJuIHsgb3V0Q29kZSwgb3V0SGFuZGxlciB9O1xuXG4gIC8vLy8vLy8vLy8vLy8vL1xuICAvLyBGdW5jdGlvbnMgLy9cbiAgLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gdHJhbnNwaWxlKFxuICAgIGVudHJ5UGF0aDogc3RyaW5nLFxuICAgIGJ1bmRsZTogYm9vbGVhbiB8IEZ1bmN0aW9uQnVuZGxlTm9kZWpzUHJvcHMsXG4gICAgYXBwRXNidWlsZENvbmZpZz86IHN0cmluZ1xuICApIHtcbiAgICAvLyBCdWlsZCBkZWZhdWx0IGVzYnVpbGQgY29uZmlnXG4gICAgY29uc3QgZGVmYXVsdENvbmZpZzogUGFydGlhbDxlc2J1aWxkLkJ1aWxkT3B0aW9ucz4gPSB7XG4gICAgICBleHRlcm5hbDogZ2V0RXNidWlsZEV4dGVybmFsKHNyY1BhdGgsIGJ1bmRsZSksXG4gICAgICBsb2FkZXI6IGdldEVzYnVpbGRMb2FkZXIoYnVuZGxlKSxcbiAgICAgIG1ldGFmaWxlOiB0cnVlLFxuICAgICAgYnVuZGxlOiB0cnVlLFxuICAgICAgbWluaWZ5OiB0eXBlb2YgYnVuZGxlID09PSBcImJvb2xlYW5cIiB8fCBidW5kbGUubWluaWZ5ICE9PSBmYWxzZSxcbiAgICAgIGZvcm1hdDogXCJjanNcIixcbiAgICAgIHNvdXJjZW1hcDogdHJ1ZSxcbiAgICAgIHBsYXRmb3JtOiBcIm5vZGVcIixcbiAgICAgIHRhcmdldDogW2VzYnVpbGRUYXJnZXRNYXBbcnVudGltZS50b1N0cmluZygpXSB8fCBcIm5vZGUxMlwiXSxcbiAgICAgIG91dGRpcjogcGF0aC5qb2luKGJ1aWxkUGF0aCwgcGF0aC5kaXJuYW1lKGVudHJ5UGF0aCkpLFxuICAgICAgZW50cnlQb2ludHM6IFtlbnRyeVBhdGhdLFxuICAgICAgY29sb3I6IHByb2Nlc3MuZW52Lk5PX0NPTE9SICE9PSBcInRydWVcIixcbiAgICAgIHRzY29uZmlnOiBoYXNUc2NvbmZpZyA/IHRzY29uZmlnIDogdW5kZWZpbmVkLFxuICAgICAgbG9nTGV2ZWw6IHByb2Nlc3MuZW52LkRFQlVHID8gXCJ3YXJuaW5nXCIgOiBcImVycm9yXCIsXG4gICAgfTtcblxuICAgIC8vIEdldCBjdXN0b20gZXNidWlsZCBjb25maWdcbiAgICBidW5kbGUgPSBidW5kbGUgYXMgRnVuY3Rpb25CdW5kbGVOb2RlanNQcm9wcztcblxuICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSBzbyB3ZSBkb24ndCBydW4gaW50byBtdXRhdGlvbiBpc3N1ZXNcbiAgICBsZXQgY3VzdG9tQ29uZmlnID0gSlNPTi5wYXJzZShcbiAgICAgIEpTT04uc3RyaW5naWZ5KGFwcEVzYnVpbGRDb25maWcgfHwgYnVuZGxlLmVzYnVpbGRDb25maWcgfHwge30pXG4gICAgKTtcbiAgICAvLyBub3RlOiBcImVzYnVpbGRDb25maWdcIiB1c2VkIHRvIHRha2UgYSBzdHJpbmcsIGEgcGF0aCB0byB0aGUgdXNlclxuICAgIC8vICAgICAgIHByb3ZpZGVkIGNvbmZpZyBmaWxlLiBXaXRoIHRoZSBuZXcgZm9ybWF0LCBlc2J1aWxkQ29uZmlnIGlzXG4gICAgLy8gICAgICAgY29uZmlndXJlZCBpbmxpbmUsIGFuZCB0aGUgZXh0ZXJuYWwgZmlsZSBjYW4gb25seSBiZSB1c2VkXG4gICAgLy8gICAgICAgdG8gcmV0dXJuIFwicGx1Z2luc1wiIGZpZWxkLlxuICAgIGlmICh0eXBlb2YgY3VzdG9tQ29uZmlnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjdXN0b21Db25maWcgPSB7IHBsdWdpbnM6IGN1c3RvbUNvbmZpZyB9O1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGZpZWxkc1xuICAgIGNvbnN0IGRpc2FsbG93ZWRLZXkgPSBPYmplY3Qua2V5cyhjdXN0b21Db25maWcpLmZpbmQoXG4gICAgICAoa2V5KSA9PiAhW1wiZGVmaW5lXCIsIFwia2VlcE5hbWVzXCIsIFwicGx1Z2luc1wiXS5pbmNsdWRlcyhrZXkpXG4gICAgKTtcbiAgICBpZiAoZGlzYWxsb3dlZEtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNvbmZpZ3VyZSB0aGUgXCIke2Rpc2FsbG93ZWRLZXl9XCIgb3B0aW9uIGluIFwiYnVuZGxlLmVzYnVpbGRDb25maWdcIi4gT25seSBcImRlZmluZVwiLCBcImtlZXBOYW1lc1wiLCBhbmQgXCJwbHVnaW5zXCIgb3B0aW9ucyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGN1c3RvbSBlc2J1aWxkIHBsdWdpbnMgcGF0aFxuICAgIGlmIChjdXN0b21Db25maWcgJiYgY3VzdG9tQ29uZmlnLnBsdWdpbnMpIHtcbiAgICAgIGN1c3RvbUNvbmZpZy5wbHVnaW5zID0gcGF0aC5qb2luKGFwcFBhdGgsIGN1c3RvbUNvbmZpZy5wbHVnaW5zKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhjdXN0b21Db25maWcucGx1Z2lucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgZmluZCB0aGUgZXNidWlsZCBjb25maWcgZmlsZSBhdCBcIiR7Y3VzdG9tQ29uZmlnLnBsdWdpbnN9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgZXNidWlsZCBjb21tYW5kXG4gICAgLy8gTm90ZTogcHJvYmFibHkgY291bGQgcGFzcyBKU09OIHN0cmluZyBhbHNvLCBidXQgdGhpcyBmZWx0IHNhZmVyLlxuICAgIGNvbnN0IGVzYnVpbGRTY3JpcHQgPSBwYXRoLmpvaW4oXG4gICAgICBfX2Rpcm5hbWUsXG4gICAgICBcIi4uLy4uL2Fzc2V0cy9ub2RlanMvZXNidWlsZC5qc1wiXG4gICAgKTtcbiAgICBjb25zdCBjbWQgPSBbXG4gICAgICBcIm5vZGVcIixcbiAgICAgIGVzYnVpbGRTY3JpcHQsXG4gICAgICBcIi0tY29uZmlnXCIsXG4gICAgICBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29uZmlnKSkudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICBcIi0tbWV0YWZpbGVcIixcbiAgICAgIG1ldGFmaWxlLFxuICAgICAgXCItLW92ZXJyaWRlc1wiLFxuICAgICAgQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoY3VzdG9tQ29uZmlnKSkudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgXS5qb2luKFwiIFwiKTtcblxuICAgIC8vIFJ1biBlc2J1aWxkXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKGNtZCwge1xuICAgICAgICBjd2Q6IGFwcFBhdGgsXG4gICAgICAgIHN0ZGlvOiBcImluaGVyaXRcIixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNoYWxrLnJlZChgVGhlcmUgd2FzIGEgcHJvYmxlbSB0cmFuc3BpbGluZyB0aGUgTGFtYmRhIGhhbmRsZXIuYCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFsbE5vZGVNb2R1bGVzKFxuICAgIHNyY1BhdGg6IHN0cmluZyxcbiAgICBidW5kbGU6IGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzXG4gICkge1xuICAgIC8vIFZhbGlkYXRlICdub2RlTW9kdWxlcycgaXMgZGVmaW5lZCBpbiBidW5kbGUgb3B0aW9uc1xuICAgIGJ1bmRsZSA9IGJ1bmRsZSBhcyBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzO1xuICAgIGlmICghYnVuZGxlIHx8ICFidW5kbGUubm9kZU1vZHVsZXMgfHwgYnVuZGxlLm5vZGVNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIG5vZGVNb2R1bGVzIGhhdmUgYmVlbiBpbnN0YWxsZWQgZm9yIHRoZSBzYW1lIHNyY1BhdGgsIGNvcHkgdGhlXG4gICAgLy8gXCJub2RlX21vZHVsZXNcIiBmb2xkZXIgb3Zlci4gRG8gbm90IHJlLWluc3RhbGwuXG4gICAgY29uc3QgbW9kdWxlc1N0ciA9IEpTT04uc3RyaW5naWZ5KGJ1bmRsZS5ub2RlTW9kdWxlcy5zbGljZSgpLnNvcnQoKSk7XG4gICAgY29uc3Qgc3JjUGF0aE1vZHVsZXMgPSBgJHtzcmNQYXRofS8ke21vZHVsZXNTdHJ9YDtcbiAgICBjb25zdCBleGlzdGluZ1BhdGggPSBleGlzdGluZ05vZGVNb2R1bGVzQnlTcmNQYXRoTW9kdWxlc1tzcmNQYXRoTW9kdWxlc107XG4gICAgaWYgKGV4aXN0aW5nUGF0aCkge1xuICAgICAgZnMuY29weVN5bmMoXG4gICAgICAgIHBhdGguam9pbihleGlzdGluZ1BhdGgsIFwibm9kZV9tb2R1bGVzXCIpLFxuICAgICAgICBwYXRoLmpvaW4oYnVpbGRQYXRoLCBcIm5vZGVfbW9kdWxlc1wiKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaW5kICdwYWNrYWdlLmpzb24nIGF0IGhhbmRsZXIncyBzcmNQYXRoLlxuICAgIGNvbnN0IHBrZ1BhdGggPSBwYXRoLmpvaW4oc3JjUGF0aCwgXCJwYWNrYWdlLmpzb25cIik7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHBrZ1BhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZmluZCBhIFwicGFja2FnZS5qc29uXCIgaW4gdGhlIGZ1bmN0aW9uJ3Mgc3JjUGF0aDogJHtwYXRoLnJlc29sdmUoXG4gICAgICAgICAgc3JjUGF0aFxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGRlcGVuZGVuY2llcyB2ZXJzaW9ucywgbG9jayBmaWxlIGFuZCBpbnN0YWxsZXJcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBleHRyYWN0RGVwZW5kZW5jaWVzKHBrZ1BhdGgsIGJ1bmRsZS5ub2RlTW9kdWxlcyk7XG4gICAgbGV0IGluc3RhbGxlciA9IFwibnBtXCI7XG4gICAgbGV0IGxvY2tGaWxlO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGguam9pbihzcmNQYXRoLCBcInBhY2thZ2UtbG9jay5qc29uXCIpKSkge1xuICAgICAgaW5zdGFsbGVyID0gXCJucG1cIjtcbiAgICAgIGxvY2tGaWxlID0gXCJwYWNrYWdlLWxvY2suanNvblwiO1xuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4oc3JjUGF0aCwgXCJ5YXJuLmxvY2tcIikpKSB7XG4gICAgICBpbnN0YWxsZXIgPSBcInlhcm5cIjtcbiAgICAgIGxvY2tGaWxlID0gXCJ5YXJuLmxvY2tcIjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgZHVtbXkgcGFja2FnZS5qc29uLCBjb3B5IGxvY2sgZmlsZSBpZiBhbnkgYW5kIHRoZW4gaW5zdGFsbFxuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4oYnVpbGRQYXRoLCBcInBhY2thZ2UuanNvblwiKTtcbiAgICBmcy5lbnN1cmVGaWxlU3luYyhvdXRwdXRQYXRoKTtcbiAgICBmcy53cml0ZUpzb25TeW5jKG91dHB1dFBhdGgsIHsgZGVwZW5kZW5jaWVzIH0pO1xuICAgIGlmIChsb2NrRmlsZSkge1xuICAgICAgZnMuY29weVN5bmMocGF0aC5qb2luKHNyY1BhdGgsIGxvY2tGaWxlKSwgcGF0aC5qb2luKGJ1aWxkUGF0aCwgbG9ja0ZpbGUpKTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YWxsIGRlcGVuZGVuY2llc1xuICAgIHRyeSB7XG4gICAgICBleGVjU3luYyhgJHtpbnN0YWxsZXJ9IGluc3RhbGxgLCB7XG4gICAgICAgIGN3ZDogYnVpbGRQYXRoLFxuICAgICAgICBzdGRpbzogXCJwaXBlXCIsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhjaGFsay5yZWQoYFRoZXJlIHdhcyBhIHByb2JsZW0gaW5zdGFsbGluZyBub2RlTW9kdWxlcy5gKSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSBwYXRoIHRvIHRoZSBpbnN0YWxsZWQgXCJub2RlX21vZHVsZXNcIlxuICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGguam9pbihidWlsZFBhdGgsIFwibm9kZV9tb2R1bGVzXCIpKSkge1xuICAgICAgZXhpc3RpbmdOb2RlTW9kdWxlc0J5U3JjUGF0aE1vZHVsZXNbc3JjUGF0aE1vZHVsZXNdID1cbiAgICAgICAgcGF0aC5yZXNvbHZlKGJ1aWxkUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuQmVmb3JlQnVuZGxpbmcoYnVuZGxlOiBib29sZWFuIHwgRnVuY3Rpb25CdW5kbGVOb2RlanNQcm9wcykge1xuICAgIC8vIEJ1aWxkIGNvbW1hbmRcbiAgICBidW5kbGUgPSBidW5kbGUgYXMgRnVuY3Rpb25CdW5kbGVOb2RlanNQcm9wcztcbiAgICBjb25zdCBjbWRzID0gYnVuZGxlLmNvbW1hbmRIb29rcz8uYmVmb3JlQnVuZGxpbmcoc3JjUGF0aCwgYnVpbGRQYXRoKSA/PyBbXTtcbiAgICBpZiAoY21kcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZXhlY1N5bmMoY21kcy5qb2luKFwiICYmIFwiKSwge1xuICAgICAgICBjd2Q6IHNyY1BhdGgsXG4gICAgICAgIHN0ZGlvOiBcInBpcGVcIixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBjaGFsay5yZWQoYFRoZXJlIHdhcyBhIHByb2JsZW0gcnVubmluZyBcImJlZm9yZUJ1bmRsaW5nXCIgY29tbWFuZC5gKVxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuQmVmb3JlSW5zdGFsbChidW5kbGU6IGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzKSB7XG4gICAgLy8gQnVpbGQgY29tbWFuZFxuICAgIGJ1bmRsZSA9IGJ1bmRsZSBhcyBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzO1xuICAgIGNvbnN0IGNtZHMgPSBidW5kbGUuY29tbWFuZEhvb2tzPy5iZWZvcmVJbnN0YWxsKHNyY1BhdGgsIGJ1aWxkUGF0aCkgPz8gW107XG4gICAgaWYgKGNtZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKGNtZHMuam9pbihcIiAmJiBcIiksIHtcbiAgICAgICAgY3dkOiBzcmNQYXRoLFxuICAgICAgICBzdGRpbzogXCJwaXBlXCIsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgY2hhbGsucmVkKGBUaGVyZSB3YXMgYSBwcm9ibGVtIHJ1bm5pbmcgXCJiZWZvcmVJbnN0YWxsXCIgY29tbWFuZC5gKVxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuQWZ0ZXJCdW5kbGluZyhidW5kbGU6IGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzKSB7XG4gICAgLy8gQnVpbGQgY29tbWFuZFxuICAgIGJ1bmRsZSA9IGJ1bmRsZSBhcyBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzO1xuICAgIGNvbnN0IGNtZHMgPSBidW5kbGUuY29tbWFuZEhvb2tzPy5hZnRlckJ1bmRsaW5nKHNyY1BhdGgsIGJ1aWxkUGF0aCkgPz8gW107XG4gICAgaWYgKGNtZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKGNtZHMuam9pbihcIiAmJiBcIiksIHtcbiAgICAgICAgY3dkOiBzcmNQYXRoLFxuICAgICAgICBzdGRpbzogXCJwaXBlXCIsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgY2hhbGsucmVkKGBUaGVyZSB3YXMgYSBwcm9ibGVtIHJ1bm5pbmcgXCJhZnRlckJ1bmRsaW5nXCIgY29tbWFuZC5gKVxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gemlwKGRpcjogc3RyaW5nLCB6aXBGaWxlOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgemlwTG9jYWwuc3luYy56aXAoZGlyKS5jb21wcmVzcygpLnNhdmUoemlwRmlsZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGdlbmVyYXRpbmcgTGFtYmRhIHBhY2thZ2UuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB6aXBGaWxlO1xuICB9XG59XG4iXX0=