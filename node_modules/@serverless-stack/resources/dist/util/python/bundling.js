"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stageDependencies = exports.bundle = exports.BUNDLER_DEPENDENCIES_CACHE = exports.DEPENDENCY_EXCLUDES = void 0;
/**
 * This file is copied from https://github.com/aws/aws-cdk/blob/master/packages/@aws-cdk/aws-lambda-python/lib/bundling.ts
 */
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const cdk = __importStar(require("aws-cdk-lib"));
const lambda = __importStar(require("aws-cdk-lib/aws-lambda"));
/**
 * Dependency files to exclude from the asset hash.
 */
exports.DEPENDENCY_EXCLUDES = ["*.pyc"];
/**
 * The location in the image that the bundler image caches dependencies.
 */
exports.BUNDLER_DEPENDENCIES_CACHE = "/var/dependencies";
/**
 * Produce bundled Lambda asset code
 */
function bundle(options) {
    const { entry, runtime, outputPathSuffix, installCommands } = options;
    const stagedir = cdk.FileSystem.mkdtemp("python-bundling-");
    const hasDeps = stageDependencies(entry, stagedir);
    const hasInstallCommands = stageInstallCommands(installCommands || [], stagedir);
    const depsCommand = chain([
        hasDeps || hasInstallCommands
            ? `rsync -r ${exports.BUNDLER_DEPENDENCIES_CACHE}/. ${cdk.AssetStaging.BUNDLING_OUTPUT_DIR}/${outputPathSuffix}`
            : "",
        `rsync -r . ${cdk.AssetStaging.BUNDLING_OUTPUT_DIR}/${outputPathSuffix}`,
    ]);
    // Determine which dockerfile to use. When dependencies are present, we use a
    // Dockerfile that can create a cacheable layer. We can't use this Dockerfile
    // if there aren't dependencies or the Dockerfile will complain about missing
    // sources.
    const dockerfile = hasInstallCommands
        ? "Dockerfile.custom"
        : hasDeps
            ? "Dockerfile.dependencies"
            : "Dockerfile";
    // copy Dockerfile to workdir
    fs.copyFileSync(path.join(__dirname, "../../../assets/python", dockerfile), path.join(stagedir, dockerfile));
    const image = cdk.DockerImage.fromBuild(stagedir, {
        buildArgs: {
            IMAGE: runtime.bundlingImage.image,
        },
        file: dockerfile,
    });
    return lambda.Code.fromAsset(entry, {
        assetHashType: options.assetHashType,
        assetHash: options.assetHash,
        exclude: exports.DEPENDENCY_EXCLUDES,
        bundling: {
            image,
            command: ["bash", "-c", depsCommand],
        },
    });
}
exports.bundle = bundle;
/**
 * Checks to see if the `entry` directory contains a type of dependency that
 * we know how to install.
 */
function stageDependencies(entry, stagedir) {
    const prefixes = ["Pipfile", "pyproject", "poetry", "requirements.txt"];
    let found = false;
    for (const file of fs.readdirSync(entry)) {
        for (const prefix of prefixes) {
            if (file.startsWith(prefix)) {
                fs.copyFileSync(path.join(entry, file), path.join(stagedir, file));
                found = true;
            }
        }
    }
    return found;
}
exports.stageDependencies = stageDependencies;
function stageInstallCommands(installCommands, stagedir) {
    let found = false;
    if (installCommands.length > 0) {
        const filePath = path.join(stagedir, "sst-deps-install-command.sh");
        fs.writeFileSync(filePath, installCommands.join(" && "));
        fs.chmodSync(filePath, "755");
        found = true;
    }
    return found;
}
function chain(commands) {
    return commands.filter((c) => !!c).join(" && ");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbC9weXRob24vYnVuZGxpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUM3QixpREFBbUM7QUFDbkMsK0RBQWlEO0FBRWpEOztHQUVHO0FBQ1UsUUFBQSxtQkFBbUIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBRTdDOztHQUVHO0FBQ1UsUUFBQSwwQkFBMEIsR0FBRyxtQkFBbUIsQ0FBQztBQWdFOUQ7O0dBRUc7QUFDSCxTQUFnQixNQUFNLENBQUMsT0FBd0I7SUFDN0MsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLEdBQUcsT0FBTyxDQUFDO0lBRXRFLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDNUQsTUFBTSxPQUFPLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ25ELE1BQU0sa0JBQWtCLEdBQUcsb0JBQW9CLENBQzdDLGVBQWUsSUFBSSxFQUFFLEVBQ3JCLFFBQVEsQ0FDVCxDQUFDO0lBRUYsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLE9BQU8sSUFBSSxrQkFBa0I7WUFDM0IsQ0FBQyxDQUFDLFlBQVksa0NBQTBCLE1BQU0sR0FBRyxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsSUFBSSxnQkFBZ0IsRUFBRTtZQUN4RyxDQUFDLENBQUMsRUFBRTtRQUNOLGNBQWMsR0FBRyxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsSUFBSSxnQkFBZ0IsRUFBRTtLQUN6RSxDQUFDLENBQUM7SUFFSCw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSxXQUFXO0lBQ1gsTUFBTSxVQUFVLEdBQUcsa0JBQWtCO1FBQ25DLENBQUMsQ0FBQyxtQkFBbUI7UUFDckIsQ0FBQyxDQUFDLE9BQU87WUFDVCxDQUFDLENBQUMseUJBQXlCO1lBQzNCLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFFakIsNkJBQTZCO0lBQzdCLEVBQUUsQ0FBQyxZQUFZLENBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsd0JBQXdCLEVBQUUsVUFBVSxDQUFDLEVBQzFELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUNoQyxDQUFDO0lBRUYsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO1FBQ2hELFNBQVMsRUFBRTtZQUNULEtBQUssRUFBRSxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUs7U0FDbkM7UUFDRCxJQUFJLEVBQUUsVUFBVTtLQUNqQixDQUFDLENBQUM7SUFFSCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRTtRQUNsQyxhQUFhLEVBQUUsT0FBTyxDQUFDLGFBQWE7UUFDcEMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxTQUFTO1FBQzVCLE9BQU8sRUFBRSwyQkFBbUI7UUFDNUIsUUFBUSxFQUFFO1lBQ1IsS0FBSztZQUNMLE9BQU8sRUFBRSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDO1NBQ3JDO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQWpERCx3QkFpREM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxLQUFhLEVBQUUsUUFBZ0I7SUFDL0QsTUFBTSxRQUFRLEdBQUcsQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBRXhFLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNsQixLQUFLLE1BQU0sSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDeEMsS0FBSyxNQUFNLE1BQU0sSUFBSSxRQUFRLEVBQUU7WUFDN0IsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUMzQixFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ25FLEtBQUssR0FBRyxJQUFJLENBQUM7YUFDZDtTQUNGO0tBQ0Y7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFkRCw4Q0FjQztBQUVELFNBQVMsb0JBQW9CLENBQzNCLGVBQXlCLEVBQ3pCLFFBQWdCO0lBRWhCLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNsQixJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQzlCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLDZCQUE2QixDQUFDLENBQUM7UUFDcEUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3pELEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzlCLEtBQUssR0FBRyxJQUFJLENBQUM7S0FDZDtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVELFNBQVMsS0FBSyxDQUFDLFFBQWtCO0lBQy9CLE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgaXMgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL0Bhd3MtY2RrL2F3cy1sYW1iZGEtcHl0aG9uL2xpYi9idW5kbGluZy50c1xuICovXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGNkayBmcm9tIFwiYXdzLWNkay1saWJcIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWxhbWJkYVwiO1xuXG4vKipcbiAqIERlcGVuZGVuY3kgZmlsZXMgdG8gZXhjbHVkZSBmcm9tIHRoZSBhc3NldCBoYXNoLlxuICovXG5leHBvcnQgY29uc3QgREVQRU5ERU5DWV9FWENMVURFUyA9IFtcIioucHljXCJdO1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBpbiB0aGUgaW1hZ2UgdGhhdCB0aGUgYnVuZGxlciBpbWFnZSBjYWNoZXMgZGVwZW5kZW5jaWVzLlxuICovXG5leHBvcnQgY29uc3QgQlVORExFUl9ERVBFTkRFTkNJRVNfQ0FDSEUgPSBcIi92YXIvZGVwZW5kZW5jaWVzXCI7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYnVuZGxpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCdW5kbGluZ09wdGlvbnMge1xuICAvKipcbiAgICogRW50cnkgcGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgZW50cnk6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJ1bnRpbWUgb2YgdGhlIGxhbWJkYSBmdW5jdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgcnVudGltZTogbGFtYmRhLlJ1bnRpbWU7XG5cbiAgLyoqXG4gICAqIE91dHB1dCBwYXRoIHN1ZmZpeCAoJ3B5dGhvbicgZm9yIGEgbGF5ZXIsICcuJyBvdGhlcndpc2UpXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQYXRoU3VmZml4OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaG93IGFzc2V0IGhhc2ggaXMgY2FsY3VsYXRlZC4gQXNzZXRzIHdpbGwgZ2V0IHJlYnVpbGQgYW5kXG4gICAqIHVwbG9hZGVkIG9ubHkgaWYgdGhlaXIgaGFzaCBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogSWYgYXNzZXQgaGFzaCBpcyBzZXQgdG8gYFNPVVJDRWAgKGRlZmF1bHQpLCB0aGVuIG9ubHkgY2hhbmdlcyB0byB0aGUgc291cmNlXG4gICAqIGRpcmVjdG9yeSB3aWxsIGNhdXNlIHRoZSBhc3NldCB0byByZWJ1aWxkLiBUaGlzIG1lYW5zLCBmb3IgZXhhbXBsZSwgdGhhdCBpblxuICAgKiBvcmRlciB0byBwaWNrIHVwIGEgbmV3IGRlcGVuZGVuY3kgdmVyc2lvbiwgYSBjaGFuZ2UgbXVzdCBiZSBtYWRlIHRvIHRoZVxuICAgKiBzb3VyY2UgdHJlZS4gSWRlYWxseSwgdGhpcyBjYW4gYmUgaW1wbGVtZW50ZWQgYnkgaW5jbHVkaW5nIGEgZGVwZW5kZW5jeVxuICAgKiBsb2NrZmlsZSBpbiB5b3VyIHNvdXJjZSB0cmVlIG9yIHVzaW5nIGZpeGVkIGRlcGVuZGVuY2llcy5cbiAgICpcbiAgICogSWYgdGhlIGFzc2V0IGhhc2ggaXMgc2V0IHRvIGBPVVRQVVRgLCB0aGUgaGFzaCBpcyBjYWxjdWxhdGVkIGFmdGVyXG4gICAqIGJ1bmRsaW5nLiBUaGlzIG1lYW5zIHRoYXQgYW55IGNoYW5nZSBpbiB0aGUgb3V0cHV0IHdpbGwgY2F1c2UgdGhlIGFzc2V0IHRvXG4gICAqIGJlIGludmFsaWRhdGVkIGFuZCB1cGxvYWRlZC4gQmVhciBpbiBtaW5kIHRoYXQgYHBpcGAgYWRkcyB0aW1lc3RhbXBzIHRvXG4gICAqIGRlcGVuZGVuY2llcyBpdCBpbnN0YWxscywgd2hpY2ggaW1wbGllcyB0aGF0IGluIHRoaXMgbW9kZSBQeXRob24gYnVuZGxlc1xuICAgKiB3aWxsIF9hbHdheXNfIGdldCByZWJ1aWxkIGFuZCB1cGxvYWRlZC4gTm9ybWFsbHkgdGhpcyBpcyBhbiBhbnRpLXBhdHRlcm5cbiAgICogc2luY2UgYnVpbGRcbiAgICpcbiAgICogQGRlZmF1bHQgQXNzZXRIYXNoVHlwZS5TT1VSQ0UgQnkgZGVmYXVsdCwgaGFzaCBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZVxuICAgKiBjb250ZW50cyBvZiB0aGUgc291cmNlIGRpcmVjdG9yeS4gSWYgYGFzc2V0SGFzaGAgaXMgYWxzbyBzcGVjaWZpZWQsIHRoZVxuICAgKiBkZWZhdWx0IGlzIGBDVVNUT01gLiBUaGlzIG1lYW5zIHRoYXQgb25seSB1cGRhdGVzIHRvIHRoZSBzb3VyY2Ugd2lsbCBjYXVzZVxuICAgKiB0aGUgYXNzZXQgdG8gcmVidWlsZC5cbiAgICovXG4gIHJlYWRvbmx5IGFzc2V0SGFzaFR5cGU/OiBjZGsuQXNzZXRIYXNoVHlwZTtcblxuICAvKipcbiAgICogU3BlY2lmeSBhIGN1c3RvbSBoYXNoIGZvciB0aGlzIGFzc2V0LiBJZiBgYXNzZXRIYXNoVHlwZWAgaXMgc2V0IGl0IG11c3RcbiAgICogYmUgc2V0IHRvIGBBc3NldEhhc2hUeXBlLkNVU1RPTWAuIEZvciBjb25zaXN0ZW5jeSwgdGhpcyBjdXN0b20gaGFzaCB3aWxsXG4gICAqIGJlIFNIQTI1NiBoYXNoZWQgYW5kIGVuY29kZWQgYXMgaGV4LiBUaGUgcmVzdWx0aW5nIGhhc2ggd2lsbCBiZSB0aGUgYXNzZXRcbiAgICogaGFzaC5cbiAgICpcbiAgICogTk9URTogdGhlIGhhc2ggaXMgdXNlZCBpbiBvcmRlciB0byBpZGVudGlmeSBhIHNwZWNpZmljIHJldmlzaW9uIG9mIHRoZSBhc3NldCwgYW5kXG4gICAqIHVzZWQgZm9yIG9wdGltaXppbmcgYW5kIGNhY2hpbmcgZGVwbG95bWVudCBhY3Rpdml0aWVzIHJlbGF0ZWQgdG8gdGhpcyBhc3NldCBzdWNoIGFzXG4gICAqIHBhY2thZ2luZywgdXBsb2FkaW5nIHRvIEFtYXpvbiBTMywgZXRjLiBJZiB5b3UgY2hvc2UgdG8gY3VzdG9taXplIHRoZSBoYXNoLCB5b3Ugd2lsbFxuICAgKiBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyB1cGRhdGVkIGV2ZXJ5IHRpbWUgdGhlIGFzc2V0IGNoYW5nZXMsIG9yIG90aGVyd2lzZSBpdCBpc1xuICAgKiBwb3NzaWJsZSB0aGF0IHNvbWUgZGVwbG95bWVudHMgd2lsbCBub3QgYmUgaW52YWxpZGF0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gYmFzZWQgb24gYGFzc2V0SGFzaFR5cGVgXG4gICAqL1xuICByZWFkb25seSBhc3NldEhhc2g/OiBzdHJpbmc7XG5cbiAgcmVhZG9ubHkgaW5zdGFsbENvbW1hbmRzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogUHJvZHVjZSBidW5kbGVkIExhbWJkYSBhc3NldCBjb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidW5kbGUob3B0aW9uczogQnVuZGxpbmdPcHRpb25zKTogbGFtYmRhLkFzc2V0Q29kZSB7XG4gIGNvbnN0IHsgZW50cnksIHJ1bnRpbWUsIG91dHB1dFBhdGhTdWZmaXgsIGluc3RhbGxDb21tYW5kcyB9ID0gb3B0aW9ucztcblxuICBjb25zdCBzdGFnZWRpciA9IGNkay5GaWxlU3lzdGVtLm1rZHRlbXAoXCJweXRob24tYnVuZGxpbmctXCIpO1xuICBjb25zdCBoYXNEZXBzID0gc3RhZ2VEZXBlbmRlbmNpZXMoZW50cnksIHN0YWdlZGlyKTtcbiAgY29uc3QgaGFzSW5zdGFsbENvbW1hbmRzID0gc3RhZ2VJbnN0YWxsQ29tbWFuZHMoXG4gICAgaW5zdGFsbENvbW1hbmRzIHx8IFtdLFxuICAgIHN0YWdlZGlyXG4gICk7XG5cbiAgY29uc3QgZGVwc0NvbW1hbmQgPSBjaGFpbihbXG4gICAgaGFzRGVwcyB8fCBoYXNJbnN0YWxsQ29tbWFuZHNcbiAgICAgID8gYHJzeW5jIC1yICR7QlVORExFUl9ERVBFTkRFTkNJRVNfQ0FDSEV9Ly4gJHtjZGsuQXNzZXRTdGFnaW5nLkJVTkRMSU5HX09VVFBVVF9ESVJ9LyR7b3V0cHV0UGF0aFN1ZmZpeH1gXG4gICAgICA6IFwiXCIsXG4gICAgYHJzeW5jIC1yIC4gJHtjZGsuQXNzZXRTdGFnaW5nLkJVTkRMSU5HX09VVFBVVF9ESVJ9LyR7b3V0cHV0UGF0aFN1ZmZpeH1gLFxuICBdKTtcblxuICAvLyBEZXRlcm1pbmUgd2hpY2ggZG9ja2VyZmlsZSB0byB1c2UuIFdoZW4gZGVwZW5kZW5jaWVzIGFyZSBwcmVzZW50LCB3ZSB1c2UgYVxuICAvLyBEb2NrZXJmaWxlIHRoYXQgY2FuIGNyZWF0ZSBhIGNhY2hlYWJsZSBsYXllci4gV2UgY2FuJ3QgdXNlIHRoaXMgRG9ja2VyZmlsZVxuICAvLyBpZiB0aGVyZSBhcmVuJ3QgZGVwZW5kZW5jaWVzIG9yIHRoZSBEb2NrZXJmaWxlIHdpbGwgY29tcGxhaW4gYWJvdXQgbWlzc2luZ1xuICAvLyBzb3VyY2VzLlxuICBjb25zdCBkb2NrZXJmaWxlID0gaGFzSW5zdGFsbENvbW1hbmRzXG4gICAgPyBcIkRvY2tlcmZpbGUuY3VzdG9tXCJcbiAgICA6IGhhc0RlcHNcbiAgICA/IFwiRG9ja2VyZmlsZS5kZXBlbmRlbmNpZXNcIlxuICAgIDogXCJEb2NrZXJmaWxlXCI7XG5cbiAgLy8gY29weSBEb2NrZXJmaWxlIHRvIHdvcmtkaXJcbiAgZnMuY29weUZpbGVTeW5jKFxuICAgIHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi4vLi4vLi4vYXNzZXRzL3B5dGhvblwiLCBkb2NrZXJmaWxlKSxcbiAgICBwYXRoLmpvaW4oc3RhZ2VkaXIsIGRvY2tlcmZpbGUpXG4gICk7XG5cbiAgY29uc3QgaW1hZ2UgPSBjZGsuRG9ja2VySW1hZ2UuZnJvbUJ1aWxkKHN0YWdlZGlyLCB7XG4gICAgYnVpbGRBcmdzOiB7XG4gICAgICBJTUFHRTogcnVudGltZS5idW5kbGluZ0ltYWdlLmltYWdlLFxuICAgIH0sXG4gICAgZmlsZTogZG9ja2VyZmlsZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGxhbWJkYS5Db2RlLmZyb21Bc3NldChlbnRyeSwge1xuICAgIGFzc2V0SGFzaFR5cGU6IG9wdGlvbnMuYXNzZXRIYXNoVHlwZSxcbiAgICBhc3NldEhhc2g6IG9wdGlvbnMuYXNzZXRIYXNoLFxuICAgIGV4Y2x1ZGU6IERFUEVOREVOQ1lfRVhDTFVERVMsXG4gICAgYnVuZGxpbmc6IHtcbiAgICAgIGltYWdlLFxuICAgICAgY29tbWFuZDogW1wiYmFzaFwiLCBcIi1jXCIsIGRlcHNDb21tYW5kXSxcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBgZW50cnlgIGRpcmVjdG9yeSBjb250YWlucyBhIHR5cGUgb2YgZGVwZW5kZW5jeSB0aGF0XG4gKiB3ZSBrbm93IGhvdyB0byBpbnN0YWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhZ2VEZXBlbmRlbmNpZXMoZW50cnk6IHN0cmluZywgc3RhZ2VkaXI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBwcmVmaXhlcyA9IFtcIlBpcGZpbGVcIiwgXCJweXByb2plY3RcIiwgXCJwb2V0cnlcIiwgXCJyZXF1aXJlbWVudHMudHh0XCJdO1xuXG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IGZpbGUgb2YgZnMucmVhZGRpclN5bmMoZW50cnkpKSB7XG4gICAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgIGlmIChmaWxlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICBmcy5jb3B5RmlsZVN5bmMocGF0aC5qb2luKGVudHJ5LCBmaWxlKSwgcGF0aC5qb2luKHN0YWdlZGlyLCBmaWxlKSk7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIHN0YWdlSW5zdGFsbENvbW1hbmRzKFxuICBpbnN0YWxsQ29tbWFuZHM6IHN0cmluZ1tdLFxuICBzdGFnZWRpcjogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGlmIChpbnN0YWxsQ29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHN0YWdlZGlyLCBcInNzdC1kZXBzLWluc3RhbGwtY29tbWFuZC5zaFwiKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBpbnN0YWxsQ29tbWFuZHMuam9pbihcIiAmJiBcIikpO1xuICAgIGZzLmNobW9kU3luYyhmaWxlUGF0aCwgXCI3NTVcIik7XG4gICAgZm91bmQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBjaGFpbihjb21tYW5kczogc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gY29tbWFuZHMuZmlsdGVyKChjKSA9PiAhIWMpLmpvaW4oXCIgJiYgXCIpO1xufVxuIl19