"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const bundling_1 = require("./python/bundling");
const builder_1 = require("./builder");
// Do not re-bundle dependencies for the same srcPath in the same Stack
// Note: if functions from different stacks have the same srcPath, we need to
//       generate the asset for each srcPath, because an asset is tied to a
//       stack. Otherwise, you will get this error:
//
//       Error: Asset is already associated with another stack 'xxxx'.
//              Create a new Code instance for every stack.
const existingBundlesByStackSrcPath = {};
function builder(builderProps) {
    const { stack, bundle, runtime, srcPath, handler } = builderProps;
    const handlerPosixPath = (0, builder_1.getHandlerFullPosixPath)(srcPath, handler);
    console.log(chalk_1.default.grey(`Building Lambda function ${handlerPosixPath}`));
    // Check entry path exists
    const entryPath = path.join(srcPath, (0, builder_1.addExtensionToHandler)(handler, ".py"));
    if (!fs.existsSync(path.join(entryPath))) {
        throw new Error(`Cannot find a handler file at "${entryPath}".`);
    }
    // Bundle dependency with code
    let outCode;
    const stackSrcPath = `${stack}/${srcPath}`;
    if (existingBundlesByStackSrcPath[stackSrcPath]) {
        outCode = existingBundlesByStackSrcPath[stackSrcPath];
    }
    else {
        console.log(chalk_1.default.grey(`Bundling dependencies for ${srcPath} in Docker...`));
        outCode = (0, bundling_1.bundle)({
            installCommands: bundle && bundle.installCommands,
            runtime,
            entry: srcPath,
            outputPathSuffix: ".",
        });
        existingBundlesByStackSrcPath[stackSrcPath] = outCode;
    }
    return {
        outCode,
        outHandler: handler,
    };
}
exports.builder = builder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uQnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3B5dGhvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUEwQjtBQUMxQiwyQ0FBNkI7QUFDN0IsNkNBQStCO0FBRS9CLGdEQUEyRDtBQUUzRCx1Q0FBMkU7QUFlM0UsdUVBQXVFO0FBQ3ZFLDZFQUE2RTtBQUM3RSwyRUFBMkU7QUFDM0UsbURBQW1EO0FBQ25ELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsMkRBQTJEO0FBQzNELE1BQU0sNkJBQTZCLEdBRS9CLEVBQUUsQ0FBQztBQUVQLFNBQWdCLE9BQU8sQ0FBQyxZQUEwQjtJQUNoRCxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxHQUFHLFlBQVksQ0FBQztJQUNsRSxNQUFNLGdCQUFnQixHQUFHLElBQUEsaUNBQXVCLEVBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRW5FLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBSyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFeEUsMEJBQTBCO0lBQzFCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUEsK0JBQXFCLEVBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDNUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFO1FBQ3hDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLFNBQVMsSUFBSSxDQUFDLENBQUM7S0FDbEU7SUFFRCw4QkFBOEI7SUFDOUIsSUFBSSxPQUF5QixDQUFDO0lBQzlCLE1BQU0sWUFBWSxHQUFHLEdBQUcsS0FBSyxJQUFJLE9BQU8sRUFBRSxDQUFDO0lBQzNDLElBQUksNkJBQTZCLENBQUMsWUFBWSxDQUFDLEVBQUU7UUFDL0MsT0FBTyxHQUFHLDZCQUE2QixDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQ3ZEO1NBQU07UUFDTCxPQUFPLENBQUMsR0FBRyxDQUNULGVBQUssQ0FBQyxJQUFJLENBQUMsNkJBQTZCLE9BQU8sZUFBZSxDQUFDLENBQ2hFLENBQUM7UUFDRixPQUFPLEdBQUcsSUFBQSxpQkFBWSxFQUFDO1lBQ3JCLGVBQWUsRUFBRSxNQUFNLElBQUksTUFBTSxDQUFDLGVBQWU7WUFDakQsT0FBTztZQUNQLEtBQUssRUFBRSxPQUFPO1lBQ2QsZ0JBQWdCLEVBQUUsR0FBRztTQUN0QixDQUFDLENBQUM7UUFDSCw2QkFBNkIsQ0FBQyxZQUFZLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDdkQ7SUFFRCxPQUFPO1FBQ0wsT0FBTztRQUNQLFVBQVUsRUFBRSxPQUFPO0tBQ3BCLENBQUM7QUFDSixDQUFDO0FBbENELDBCQWtDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0ICogYXMgbGFtYmRhIGZyb20gXCJAYXdzLWNkay9hd3MtbGFtYmRhXCI7XG5pbXBvcnQgeyBidW5kbGUgYXMgYnVuZGxlUHl0aG9uIH0gZnJvbSBcIi4vcHl0aG9uL2J1bmRsaW5nXCI7XG5pbXBvcnQgeyBGdW5jdGlvbkJ1bmRsZVB5dGhvblByb3BzIH0gZnJvbSBcIi4uL0Z1bmN0aW9uXCI7XG5pbXBvcnQgeyBhZGRFeHRlbnNpb25Ub0hhbmRsZXIsIGdldEhhbmRsZXJGdWxsUG9zaXhQYXRoIH0gZnJvbSBcIi4vYnVpbGRlclwiO1xuXG5pbnRlcmZhY2UgQnVpbGRlclByb3BzIHtcbiAgcmVhZG9ubHkgc3RhY2s6IHN0cmluZztcbiAgcmVhZG9ubHkgc3JjUGF0aDogc3RyaW5nO1xuICByZWFkb25seSBoYW5kbGVyOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lO1xuICByZWFkb25seSBidW5kbGU6IEZ1bmN0aW9uQnVuZGxlUHl0aG9uUHJvcHM7XG59XG5cbmludGVyZmFjZSBCdWlsZGVyT3V0cHV0IHtcbiAgcmVhZG9ubHkgb3V0Q29kZTogbGFtYmRhLkFzc2V0Q29kZTtcbiAgcmVhZG9ubHkgb3V0SGFuZGxlcjogc3RyaW5nO1xufVxuXG4vLyBEbyBub3QgcmUtYnVuZGxlIGRlcGVuZGVuY2llcyBmb3IgdGhlIHNhbWUgc3JjUGF0aCBpbiB0aGUgc2FtZSBTdGFja1xuLy8gTm90ZTogaWYgZnVuY3Rpb25zIGZyb20gZGlmZmVyZW50IHN0YWNrcyBoYXZlIHRoZSBzYW1lIHNyY1BhdGgsIHdlIG5lZWQgdG9cbi8vICAgICAgIGdlbmVyYXRlIHRoZSBhc3NldCBmb3IgZWFjaCBzcmNQYXRoLCBiZWNhdXNlIGFuIGFzc2V0IGlzIHRpZWQgdG8gYVxuLy8gICAgICAgc3RhY2suIE90aGVyd2lzZSwgeW91IHdpbGwgZ2V0IHRoaXMgZXJyb3I6XG4vL1xuLy8gICAgICAgRXJyb3I6IEFzc2V0IGlzIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGFub3RoZXIgc3RhY2sgJ3h4eHgnLlxuLy8gICAgICAgICAgICAgIENyZWF0ZSBhIG5ldyBDb2RlIGluc3RhbmNlIGZvciBldmVyeSBzdGFjay5cbmNvbnN0IGV4aXN0aW5nQnVuZGxlc0J5U3RhY2tTcmNQYXRoOiB7XG4gIFtzdGFja1NyY1BhdGg6IHN0cmluZ106IGxhbWJkYS5Bc3NldENvZGU7XG59ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZGVyKGJ1aWxkZXJQcm9wczogQnVpbGRlclByb3BzKTogQnVpbGRlck91dHB1dCB7XG4gIGNvbnN0IHsgc3RhY2ssIGJ1bmRsZSwgcnVudGltZSwgc3JjUGF0aCwgaGFuZGxlciB9ID0gYnVpbGRlclByb3BzO1xuICBjb25zdCBoYW5kbGVyUG9zaXhQYXRoID0gZ2V0SGFuZGxlckZ1bGxQb3NpeFBhdGgoc3JjUGF0aCwgaGFuZGxlcik7XG5cbiAgY29uc29sZS5sb2coY2hhbGsuZ3JleShgQnVpbGRpbmcgTGFtYmRhIGZ1bmN0aW9uICR7aGFuZGxlclBvc2l4UGF0aH1gKSk7XG5cbiAgLy8gQ2hlY2sgZW50cnkgcGF0aCBleGlzdHNcbiAgY29uc3QgZW50cnlQYXRoID0gcGF0aC5qb2luKHNyY1BhdGgsIGFkZEV4dGVuc2lvblRvSGFuZGxlcihoYW5kbGVyLCBcIi5weVwiKSk7XG4gIGlmICghZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4oZW50cnlQYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGEgaGFuZGxlciBmaWxlIGF0IFwiJHtlbnRyeVBhdGh9XCIuYCk7XG4gIH1cblxuICAvLyBCdW5kbGUgZGVwZW5kZW5jeSB3aXRoIGNvZGVcbiAgbGV0IG91dENvZGU6IGxhbWJkYS5Bc3NldENvZGU7XG4gIGNvbnN0IHN0YWNrU3JjUGF0aCA9IGAke3N0YWNrfS8ke3NyY1BhdGh9YDtcbiAgaWYgKGV4aXN0aW5nQnVuZGxlc0J5U3RhY2tTcmNQYXRoW3N0YWNrU3JjUGF0aF0pIHtcbiAgICBvdXRDb2RlID0gZXhpc3RpbmdCdW5kbGVzQnlTdGFja1NyY1BhdGhbc3RhY2tTcmNQYXRoXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGNoYWxrLmdyZXkoYEJ1bmRsaW5nIGRlcGVuZGVuY2llcyBmb3IgJHtzcmNQYXRofSBpbiBEb2NrZXIuLi5gKVxuICAgICk7XG4gICAgb3V0Q29kZSA9IGJ1bmRsZVB5dGhvbih7XG4gICAgICBpbnN0YWxsQ29tbWFuZHM6IGJ1bmRsZSAmJiBidW5kbGUuaW5zdGFsbENvbW1hbmRzLFxuICAgICAgcnVudGltZSxcbiAgICAgIGVudHJ5OiBzcmNQYXRoLFxuICAgICAgb3V0cHV0UGF0aFN1ZmZpeDogXCIuXCIsXG4gICAgfSk7XG4gICAgZXhpc3RpbmdCdW5kbGVzQnlTdGFja1NyY1BhdGhbc3RhY2tTcmNQYXRoXSA9IG91dENvZGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG91dENvZGUsXG4gICAgb3V0SGFuZGxlcjogaGFuZGxlcixcbiAgfTtcbn1cbiJdfQ==