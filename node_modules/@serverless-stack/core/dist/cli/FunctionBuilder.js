"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFunctionBuilder = void 0;
const xstate_1 = require("xstate");
const path_1 = __importDefault(require("path"));
const handler_1 = require("../runtime/handler");
const state_1 = require("../state");
const picomatch_1 = __importDefault(require("picomatch"));
const events_1 = require("../events");
const remeda_1 = require("remeda");
function useFunctionBuilder(opts) {
    const ctx = {
        funcs: {},
    };
    const onTransition = new events_1.EventDelegate();
    const onChange = new events_1.EventDelegate();
    function reload() {
        for (const actor of Object.values(ctx.funcs)) {
            actor.stop();
        }
        const defs = state_1.State.Function.read(opts.root);
        const result = {};
        for (const info of defs) {
            const actor = createFuncMachine({
                ctx,
                info,
                checks: opts.checks,
            });
            actor.onTransition((state) => onTransition.trigger({
                state,
                actor,
            }));
            actor.onChange((ctx) => onChange.trigger({
                ctx,
                actor,
            }));
            result[info.id] = actor;
        }
        ctx.funcs = result;
        return result;
    }
    function broadcast(event) {
        Object.values(ctx.funcs).map((f) => f.send(event));
    }
    function send(id, event) {
        const func = ctx.funcs[id];
        return func.send(event);
    }
    return {
        ctx,
        reload,
        send,
        broadcast,
        onTransition,
        onChange,
    };
}
exports.useFunctionBuilder = useFunctionBuilder;
function createFuncMachine(opts) {
    var _a, _b;
    return xstate_1.interpret(funcMachine.withContext({
        info: opts.info,
        instructions: handler_1.Handler.instructions(opts.info),
        dirty: false,
        issues: {},
        checks: opts.checks,
        warm: ((_b = (_a = opts.ctx.funcs[opts.info.id]) === null || _a === void 0 ? void 0 : _a.getSnapshot()) === null || _b === void 0 ? void 0 : _b.context.warm) || false,
    }), {
        name: opts.info.id,
    }).start();
}
function shouldBuild(ctx, evt) {
    if (!ctx.warm)
        return false;
    if (ctx.instructions.watcher.include.every((x) => !picomatch_1.default.isMatch(evt.file, x.split(path_1.default.sep).join(path_1.default.posix.sep))))
        return false;
    if (!ctx.instructions.shouldBuild)
        return true;
    return ctx.instructions.shouldBuild([evt.file]);
}
const funcMachine = xstate_1.createMachine({
    initial: "idle",
    states: {
        idle: {
            on: {
                FILE_CHANGE: [
                    {
                        cond: shouldBuild,
                        target: "building",
                    },
                ],
            },
        },
        building: {
            entry: xstate_1.assign({
                dirty: () => false,
                buildStart: () => Date.now(),
            }),
            invoke: {
                src: async (ctx) => { var _a, _b; return await ((_b = (_a = ctx.instructions).build) === null || _b === void 0 ? void 0 : _b.call(_a)); },
                onDone: [
                    {
                        cond: (ctx) => ctx.dirty,
                        target: "building",
                    },
                    {
                        cond: (_, evt) => evt.data.length > 0,
                        actions: xstate_1.assign({
                            issues: (_ctx, evt) => ({ build: evt.data }),
                        }),
                        target: "idle",
                    },
                    {
                        target: "checking",
                        actions: xstate_1.assign({
                            issues: (_ctx, evt) => ({ build: evt.data }),
                        }),
                    },
                ],
            },
            on: {
                FILE_CHANGE: {
                    actions: xstate_1.assign({
                        dirty: (ctx, evt) => shouldBuild(ctx, evt),
                    }),
                },
            },
        },
        checking: {
            invoke: {
                src: async (ctx) => {
                    const promises = Object.entries(ctx.instructions.checks || {})
                        .filter(([key]) => ctx.checks[key])
                        .map(async ([key, value]) => {
                        return [key, await value()];
                    });
                    return await Promise.all(promises);
                },
                onDone: {
                    actions: xstate_1.assign({
                        issues: (ctx, evt) => ({
                            ...ctx.issues,
                            ...remeda_1.fromPairs(evt.data),
                        }),
                    }),
                    target: "idle",
                },
            },
            on: {
                FILE_CHANGE: "building",
            },
        },
    },
    on: {
        INVOKE: {
            actions: xstate_1.assign({
                warm: (_ctx) => true,
            }),
        },
    },
});
