"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStacksBuilder = void 0;
const chokidar_1 = __importDefault(require("chokidar"));
const xstate_1 = require("xstate");
const stacks_1 = require("../stacks");
const __1 = require("../");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const crypto_1 = __importDefault(require("crypto"));
function stub(name, duration = 1000) {
    return function () {
        console.log(name);
        return new Promise((r) => setTimeout(r, duration));
    };
}
const machine = (0, xstate_1.createMachine)({
    initial: "idle",
    id: "stacksBuilder",
    states: {
        idle: {
            initial: "none",
            on: {
                FILE_CHANGE: "building",
            },
            states: {
                none: {},
                unchanged: {},
                deployed: {},
            },
        },
        failed: {
            on: {
                FILE_CHANGE: "building",
            },
            states: {
                build: {},
                synth: {},
                deploy: {},
            },
        },
        building: {
            entry: (0, xstate_1.assign)({
                dirty: () => false,
            }),
            invoke: {
                src: "build",
                onDone: [
                    {
                        cond: "isDirty",
                        target: "building",
                    },
                    {
                        target: "synthing",
                    },
                ],
                onError: [
                    {
                        cond: "isDirty",
                        target: "building",
                    },
                    {
                        target: "failed.build",
                    },
                ],
            },
        },
        synthing: {
            invoke: {
                src: "synth",
                onDone: [
                    {
                        cond: "isDirty",
                        target: "building",
                    },
                    {
                        cond: "isChanged",
                        target: "deployable",
                        actions: xstate_1.actions.assign({
                            pendingHash: (_, evt) => evt.data,
                        }),
                    },
                    {
                        target: "idle.unchanged",
                    },
                ],
                onError: [
                    {
                        cond: "isDirty",
                        target: "building",
                    },
                    {
                        target: "failed.synth",
                    },
                ],
            },
        },
        deployable: {
            on: {
                TRIGGER_DEPLOY: "deploying",
                FILE_CHANGE: "building",
            },
        },
        deploying: {
            invoke: {
                src: "deploy",
                onDone: [
                    {
                        cond: "isDirty",
                        target: "building",
                        actions: xstate_1.actions.assign({
                            deployedHash: (ctx) => ctx.pendingHash,
                        }),
                    },
                    {
                        target: "idle.deployed",
                        actions: xstate_1.actions.assign({
                            deployedHash: (ctx) => ctx.pendingHash,
                        }),
                    },
                ],
                onError: [
                    {
                        cond: "isDirty",
                        target: "building",
                    },
                    {
                        target: "failed.deploy",
                    },
                ],
            },
        },
    },
    on: {
        FILE_CHANGE: {
            actions: xstate_1.actions.assign({
                dirty: (_ctx) => true,
            }),
        },
    },
}, {
    services: {
        build: stub("build"),
        deploy: stub("deploy"),
        synth: stub("synth"),
    },
    guards: {
        isDirty,
        isChanged,
    },
});
// TODO: The arguments here are hacky because we need to access code from cdkHelper. Should be refactored so that cdkHelpers don't really exist and everything is done inside here.
function useStacksBuilder(root, config, cdkOptions, deployFunc) {
    const cdkOutPath = path_1.default.join(root, cdkOptions.output);
    const service = (0, xstate_1.interpret)(machine
        .withConfig({
        services: {
            build: async () => {
                await stacks_1.Stacks.build(root, config);
            },
            synth: async () => {
                await (0, __1.synth)(cdkOptions);
                return generateChecksum(cdkOutPath);
            },
            deploy: async () => {
                await deployFunc(cdkOptions);
            },
        },
    })
        .withContext({
        dirty: false,
        pendingHash: "",
        deployedHash: generateChecksum(cdkOutPath),
    }));
    chokidar_1.default
        .watch(path_1.default.dirname(config.main) + "/**/*", {
        persistent: true,
        ignoreInitial: true,
        followSymlinks: false,
    })
        .on("change", () => {
        service.send("FILE_CHANGE");
    });
    service.start();
    return service;
}
exports.useStacksBuilder = useStacksBuilder;
function isChanged(ctx, evt) {
    return evt.data !== ctx.deployedHash;
}
function isDirty(ctx) {
    return ctx.dirty;
}
function generateChecksum(cdkOutPath) {
    const manifestPath = path_1.default.join(cdkOutPath, "manifest.json");
    const cdkManifest = fs_extra_1.default.readJsonSync(manifestPath);
    const checksumData = Object.keys(cdkManifest.artifacts)
        .filter((key) => cdkManifest.artifacts[key].type === "aws:cloudformation:stack")
        .map((key) => {
        const { templateFile } = cdkManifest.artifacts[key].properties;
        const templatePath = path_1.default.join(cdkOutPath, templateFile);
        const templateContent = fs_extra_1.default.readFileSync(templatePath);
        return templateContent;
    })
        .join("\n");
    const hash = crypto_1.default.createHash("sha256").update(checksumData).digest("hex");
    return hash;
}
