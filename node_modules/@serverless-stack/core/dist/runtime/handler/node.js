"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeHandler = void 0;
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const state_1 = require("../../state");
const child_process_1 = require("child_process");
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const esbuild = __importStar(require("esbuild"));
const dataloader_1 = __importDefault(require("dataloader"));
const BUILD_CACHE = {};
const TSC_CACHE = {};
const LINT_CACHE = {};
// If multiple functions are effected by a change only run tsc once per srcPath
// TODO: Use the compiler API - this is way too slow
const TYPESCRIPT_LOADER = new dataloader_1.default(async (paths) => {
    const proms = paths.map((srcPath) => {
        var _a, _b;
        const cmd = {
            command: "npx",
            args: ["tsc", "--noEmit"],
        };
        const existing = TSC_CACHE[srcPath];
        if (existing)
            existing.kill();
        const proc = cross_spawn_1.default(cmd.command, cmd.args, {
            env: {
                ...process.env,
            },
            stdio: "pipe",
            cwd: srcPath,
        });
        let collect = "";
        (_a = proc.stderr) === null || _a === void 0 ? void 0 : _a.on("data", (data) => (collect += data));
        (_b = proc.stdout) === null || _b === void 0 ? void 0 : _b.on("data", (data) => (collect += data));
        TSC_CACHE[srcPath] = proc;
        return new Promise((resolve) => {
            proc.on("exit", () => {
                const errs = collect.trim();
                if (!errs) {
                    resolve([]);
                    return;
                }
                resolve([
                    {
                        location: {
                            file: srcPath,
                        },
                        message: errs,
                    },
                ]);
            });
        });
    });
    return Promise.all(proms);
}, {
    cache: false,
});
const NodeHandler = (opts) => {
    var _a, _b, _c;
    const dir = path_1.default.dirname(opts.handler);
    const ext = path_1.default.extname(opts.handler);
    const base = path_1.default.basename(opts.handler).split(".")[0];
    const file = [".ts", ".tsx", ".js", ".jsx"]
        .map((ext) => path_1.default.join(dir, base + ext))
        .find((file) => {
        const p = path_1.default.join(opts.srcPath, file);
        return fs_extra_1.default.existsSync(p);
    });
    if (!file)
        throw new Error(`Cannot find a handler file for "${opts.handler}"`);
    const artifact = state_1.State.Function.artifactsPath(opts.root, opts.id);
    const bundle = opts.bundle || {
        minify: true,
    };
    // If srcPath is an absolute path, we need to convert it to an relative path
    // and append it to the artifact path.
    // Note: absolute "srcPath" should only be used for RDS's internal
    //       migrator function. User provided "srcPath" should always be
    //       relative path.
    const target = path_1.default.join(artifact, absolutePathToRelativePath(opts.srcPath), path_1.default.dirname(file), base + ".js");
    const config = {
        loader: bundle.loader,
        minify: bundle.minify,
        define: (_a = bundle.esbuildConfig) === null || _a === void 0 ? void 0 : _a.define,
        keepNames: (_b = bundle.esbuildConfig) === null || _b === void 0 ? void 0 : _b.keepNames,
        entryPoints: [path_1.default.join(opts.srcPath, file)],
        bundle: opts.bundle !== false,
        external: [
            ...(bundle.format === "esm" ? [] : ["aws-sdk"]),
            ...(bundle.externalModules || []),
            ...(bundle.nodeModules || []),
        ],
        sourcemap: true,
        platform: "node",
        ...(bundle.format === "esm"
            ? {
                target: "esnext",
                format: "esm",
                banner: {
                    js: [
                        `import { createRequire as topLevelCreateRequire } from 'module'`,
                        `const require = topLevelCreateRequire(import.meta.url)`,
                    ].join("\n"),
                },
            }
            : {
                target: "node14",
                format: "cjs",
            }),
        outfile: target,
    };
    const plugins = ((_c = bundle.esbuildConfig) === null || _c === void 0 ? void 0 : _c.plugins)
        ? path_1.default.join(opts.root, bundle.esbuildConfig.plugins)
        : undefined;
    if (plugins && !fs_extra_1.default.existsSync(plugins)) {
        throw new Error(`Cannot find an esbuild plugins file at: ${path_1.default.resolve(plugins)}`);
    }
    return {
        shouldBuild: (files) => {
            const existing = BUILD_CACHE[opts.id];
            if (!existing)
                return true;
            const result = files
                .map((x) => path_1.default.relative(process.cwd(), x).split(path_1.default.sep).join(path_1.default.posix.sep))
                .some((x) => existing.metafile.inputs[x]);
            return result;
        },
        build: async () => {
            const existing = BUILD_CACHE[opts.id];
            try {
                if (existing === null || existing === void 0 ? void 0 : existing.rebuild) {
                    const result = await existing.rebuild();
                    BUILD_CACHE[opts.id] = result;
                    return [];
                }
                fs_extra_1.default.removeSync(artifact);
                fs_extra_1.default.mkdirpSync(artifact);
                const result = await esbuild.build({
                    ...config,
                    plugins: plugins ? require(plugins) : undefined,
                    metafile: true,
                    minify: false,
                    incremental: true,
                });
                fs_extra_1.default.writeJSONSync(path_1.default.join(artifact, "package.json"), {
                    type: bundle.format === "esm" ? "module" : "commonjs",
                });
                BUILD_CACHE[opts.id] = result;
                return [];
            }
            catch (e) {
                return e.errors.map((e) => {
                    var _a, _b, _c, _d;
                    return ({
                        location: {
                            file: ((_a = e.location) === null || _a === void 0 ? void 0 : _a.file) || path_1.default.join(opts.srcPath, file),
                            column: (_b = e.location) === null || _b === void 0 ? void 0 : _b.column,
                            line: (_c = e.location) === null || _c === void 0 ? void 0 : _c.line,
                            length: (_d = e.location) === null || _d === void 0 ? void 0 : _d.length,
                        },
                        message: e.text,
                    });
                });
            }
        },
        bundle: () => {
            runBeforeBundling(opts.srcPath, artifact, bundle);
            // We cannot use esbuild.buildSync(config) because it doesn't support plugins;
            const script = `
        const esbuild = require("esbuild")
        async function run() {
          const config = ${JSON.stringify({
                ...config,
                metafile: true,
                plugins,
            })}
          try {
            await esbuild.build({
              ...config,
              plugins: config.plugins ? require(config.plugins) : undefined
            })
            process.exit(0)
          } catch {
            process.exit(1)
          }
        }
        run()
      `;
            fs_extra_1.default.removeSync(artifact);
            fs_extra_1.default.mkdirpSync(artifact);
            const builder = path_1.default.join(artifact, "builder.cjs");
            fs_extra_1.default.writeFileSync(builder, script);
            fs_extra_1.default.writeJSONSync(path_1.default.join(artifact, "package.json"), {
                type: bundle.format === "esm" ? "module" : "commonjs",
            });
            const result = cross_spawn_1.default.sync("node", [builder], {
                stdio: "pipe",
            });
            if (result.status !== 0) {
                const err = (result.stderr.toString() + result.stdout.toString()).trim();
                throw new Error("There was a problem transpiling the Lambda handler: " + err);
            }
            fs_extra_1.default.removeSync(builder);
            runBeforeInstall(opts.srcPath, artifact, bundle);
            installNodeModules(opts.srcPath, artifact, bundle);
            runAfterBundling(opts.srcPath, artifact, bundle);
            // If handler is an absolute path, we need to convert it to an relative
            // path. This is because the Lambda's handler path always needs to be
            // an relative path.
            // Note: absolute "srcPath" should only be used for RDS's internal
            //       migrator function. User provided "srcPath" should always be
            //       relative path.
            const handler = path_1.default.join(opts.srcPath, opts.handler).replace(/\\/g, "/");
            return {
                directory: artifact,
                handler: absolutePathToRelativePath(handler),
            };
        },
        run: {
            command: "npx",
            args: ["aws-lambda-ric", target.replace(".js", ext)],
            env: {
                // NODE_OPTIONS: "--enable-source-maps",
                AWS_LAMBDA_NODEJS_USE_ALTERNATIVE_CLIENT_1: "true",
            },
        },
        watcher: {
            include: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"].map((glob) => path_1.default.resolve(path_1.default.join(opts.srcPath, glob))),
            ignore: [],
        },
        checks: {
            type: () => {
                return TYPESCRIPT_LOADER.load(opts.srcPath);
            },
            lint: async () => {
                const existing = LINT_CACHE[opts.srcPath];
                if (existing)
                    existing.kill();
                const cmd = {
                    command: "npx",
                    args: ["eslint", file],
                };
                const proc = cross_spawn_1.default(cmd.command, cmd.args, {
                    env: {
                        ...process.env,
                    },
                    stdio: "inherit",
                    cwd: opts.srcPath,
                });
                LINT_CACHE[opts.srcPath] = proc;
                return [];
            },
        },
    };
};
exports.NodeHandler = NodeHandler;
// Do not re-install nodeModules for the same srcPath and nodeModules settings
const existingNodeModulesBySrcPathModules = {};
function installNodeModules(srcPath, targetPath, bundle) {
    if (!bundle.nodeModules)
        return;
    // If nodeModules have been installed for the same srcPath, copy the
    // "node_modules" folder over. Do not re-install.
    const modulesStr = JSON.stringify(bundle.nodeModules.slice().sort());
    const srcPathModules = `${srcPath}/${modulesStr}`;
    const existingPath = existingNodeModulesBySrcPathModules[srcPathModules];
    if (existingPath) {
        fs_extra_1.default.copySync(path_1.default.join(existingPath, "node_modules"), path_1.default.join(targetPath, "node_modules"));
        return;
    }
    // Find 'package.json' at handler's srcPath.
    const pkgPath = path_1.default.join(srcPath, "package.json");
    if (!fs_extra_1.default.existsSync(pkgPath)) {
        throw new Error(`Cannot find a "package.json" in the function's srcPath: ${path_1.default.resolve(srcPath)}`);
    }
    // Determine dependencies versions, lock file and installer
    const dependencies = extractDependencies(pkgPath, bundle.nodeModules);
    let installer = "npm";
    let lockFile;
    if (fs_extra_1.default.existsSync(path_1.default.join(srcPath, "package-lock.json"))) {
        installer = "npm";
        lockFile = "package-lock.json";
    }
    else if (fs_extra_1.default.existsSync(path_1.default.join(srcPath, "yarn.lock"))) {
        installer = "yarn";
        lockFile = "yarn.lock";
    }
    // Create dummy package.json, copy lock file if any and then install
    const outputPath = path_1.default.join(targetPath, "package.json");
    fs_extra_1.default.ensureFileSync(outputPath);
    const existing = fs_extra_1.default.readJsonSync(outputPath) || {};
    fs_extra_1.default.writeJsonSync(outputPath, { ...existing, dependencies });
    if (lockFile) {
        fs_extra_1.default.copySync(path_1.default.join(srcPath, lockFile), path_1.default.join(targetPath, lockFile));
    }
    // Install dependencies
    try {
        child_process_1.execSync(`${installer} install`, {
            cwd: targetPath,
            stdio: "pipe",
        });
    }
    catch (e) {
        console.log(chalk_1.default.red(`There was a problem installing nodeModules.`));
        throw e;
    }
    // Store the path to the installed "node_modules"
    if (fs_extra_1.default.existsSync(path_1.default.join(targetPath, "node_modules"))) {
        existingNodeModulesBySrcPathModules[srcPathModules] =
            path_1.default.resolve(targetPath);
    }
}
/**
 * Extract versions for a list of modules.
 *
 * First lookup the version in the package.json and then fallback to requiring
 * the module's package.json. The fallback is needed for transitive dependencies.
 */
function extractDependencies(pkgPath, modules) {
    var _a, _b, _c, _d;
    const dependencies = {};
    const pkgJson = fs_extra_1.default.readJsonSync(pkgPath);
    const pkgDependencies = {
        ...((_a = pkgJson.dependencies) !== null && _a !== void 0 ? _a : {}),
        ...((_b = pkgJson.devDependencies) !== null && _b !== void 0 ? _b : {}),
        ...((_c = pkgJson.peerDependencies) !== null && _c !== void 0 ? _c : {}),
    };
    for (const mod of modules) {
        try {
            const version = (_d = pkgDependencies[mod]) !== null && _d !== void 0 ? _d : require(`${mod}/package.json`).version; // eslint-disable-line @typescript-eslint/no-var-requires
            dependencies[mod] = version;
        }
        catch (err) {
            throw new Error(`Cannot extract version for module '${mod}'. Check that it's referenced in your package.json or installed.`);
        }
    }
    return dependencies;
}
function runBeforeBundling(srcPath, buildPath, bundle) {
    var _a, _b;
    // Build command
    const cmds = (_b = (_a = bundle.commandHooks) === null || _a === void 0 ? void 0 : _a.beforeBundling(srcPath, buildPath)) !== null && _b !== void 0 ? _b : [];
    if (cmds.length === 0) {
        return;
    }
    try {
        child_process_1.execSync(cmds.join(" && "), {
            cwd: srcPath,
            stdio: "pipe",
        });
    }
    catch (e) {
        console.log(chalk_1.default.red(`There was a problem running "beforeBundling" command.`));
        throw e;
    }
}
function runBeforeInstall(srcPath, buildPath, bundle) {
    var _a, _b;
    // Build command
    const cmds = (_b = (_a = bundle.commandHooks) === null || _a === void 0 ? void 0 : _a.beforeInstall(srcPath, buildPath)) !== null && _b !== void 0 ? _b : [];
    if (cmds.length === 0) {
        return;
    }
    try {
        child_process_1.execSync(cmds.join(" && "), {
            cwd: srcPath,
            stdio: "pipe",
        });
    }
    catch (e) {
        console.log(chalk_1.default.red(`There was a problem running "beforeInstall" command.`));
        throw e;
    }
}
function runAfterBundling(srcPath, buildPath, bundle) {
    var _a, _b;
    // Build command
    const cmds = (_b = (_a = bundle.commandHooks) === null || _a === void 0 ? void 0 : _a.afterBundling(srcPath, buildPath)) !== null && _b !== void 0 ? _b : [];
    if (cmds.length === 0) {
        return;
    }
    try {
        child_process_1.execSync(cmds.join(" && "), {
            cwd: srcPath,
            stdio: "pipe",
        });
    }
    catch (e) {
        console.log(chalk_1.default.red(`There was a problem running "afterBundling" command.`));
        throw e;
    }
}
function absolutePathToRelativePath(absolutePath) {
    if (!path_1.default.isAbsolute(absolutePath)) {
        return absolutePath;
    }
    // For win32: root for D:\\path\\to\\dir is D:\\
    // For posix: root for /path/to/dir is /
    const { root } = path_1.default.parse(absolutePath);
    return absolutePath.substring(root.length);
}
