"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WS = void 0;
const ws_1 = __importDefault(require("ws"));
const events_1 = require("../events");
const logger_1 = require("../logger");
const s3_1 = __importDefault(require("aws-sdk/clients/s3"));
const zlib_1 = __importDefault(require("zlib"));
const s3 = new s3_1.default();
const wsLogger = logger_1.getChildLogger("websocket");
const WEBSOCKET_CLOSE_CODE = {
    NEW_CLIENT_CONNECTED: 4901,
};
class WS {
    constructor() {
        this.onMessage = new events_1.EventDelegate();
    }
    onRequest(cb) {
        this.handleRequest = cb;
    }
    start(debugEndpoint, debugBucketName) {
        this.debugBucketName = debugBucketName;
        wsLogger.debug("startWebSocketClient", debugEndpoint, debugBucketName);
        this.socket = new ws_1.default(debugEndpoint);
        this.socket.on("open", () => {
            wsLogger.debug("WebSocket connection opened");
            this.send({ action: "client.register" });
            this.keepAlive = setInterval(() => this.sendKeepAlive(), 60000);
        });
        this.socket.on("error", (e) => {
            wsLogger.error("WebSocket connection error", e);
        });
        this.socket.on("close", (code, reason) => {
            wsLogger.debug("Websocket connection closed", { code, reason });
            // Stop keep-alive timer first to timer sending a keep alive call before
            // the reconnect is finished. Which will throw an exception.
            this.stop();
            // Case: disconnected due to new client connected => do not reconnect
            if (code === WEBSOCKET_CLOSE_CODE.NEW_CLIENT_CONNECTED) {
                wsLogger.debug("Websocket connection closed due to new client connected");
                return;
            }
            // Case: disconnected due to 10min idle or 2hr WebSocket connection limit => reconnect
            wsLogger.debug("Reconnecting to websocket server...");
            this.start(debugEndpoint, debugBucketName);
        });
        this.socket.on("message", (msg) => this.handleMessage(msg));
    }
    async handleMessage(message) {
        const data = JSON.parse(message.toString());
        // Handle actions
        if (data.action === "server.clientRegistered") {
            this.onMessage.trigger(data);
            return;
        }
        if (data.action === "server.clientDisconnectedDueToNewClient") {
            this.onMessage.trigger(data);
            this.socket.close(WEBSOCKET_CLOSE_CODE.NEW_CLIENT_CONNECTED);
            return;
        }
        if (data.action === "server.failedToSendResponseDueToStubDisconnected") {
            this.onMessage.trigger(data);
            return;
        }
        if (data.action === "server.failedToSendResponseDueToUnknown") {
            this.onMessage.trigger(data);
            return;
        }
        if (data.action === "register") {
            this.onMessage.trigger(data);
            return;
        }
        if (data.action === "stub.lambdaRequest") {
            if (!this.handleRequest)
                return;
            // Parse payload
            const { stubConnectionId, debugRequestId, payload, payloadS3Key } = data;
            const buffer = payload
                ? Buffer.from(payload, "base64")
                : (await s3
                    .getObject({
                    Bucket: this.debugBucketName,
                    Key: payloadS3Key,
                })
                    .promise()).Body;
            const req = JSON.parse(zlib_1.default.unzipSync(buffer).toString());
            const resp = await this.handleRequest(req);
            // Zipping payload
            const zipped = zlib_1.default.gzipSync(JSON.stringify(resp.type === "success"
                ? {
                    responseData: resp.body,
                }
                : {
                    responseError: resp.body,
                }));
            if (zipped.length < 32000) {
                this.send({
                    action: "client.lambdaResponse",
                    debugRequestId,
                    stubConnectionId,
                    payload: zipped.toString("base64"),
                });
                return;
            }
            // payload does NOT fit into 1 WebSocket frame
            const uploaded = await s3
                .upload({
                Bucket: this.debugBucketName,
                Key: `payloads/${debugRequestId}-response`,
                Body: zipped,
            })
                .promise();
            this.send({
                action: "client.lambdaResponse",
                debugRequestId,
                stubConnectionId,
                payloadS3Key: uploaded.Key,
            });
        }
    }
    stop() {
        if (this.keepAlive)
            clearInterval(this.keepAlive);
    }
    sendKeepAlive() {
        this.send({ action: "client.keepAlive" });
    }
    send(input) {
        var _a;
        (_a = this.socket) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(input));
    }
}
exports.WS = WS;
